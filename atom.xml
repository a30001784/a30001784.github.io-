<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>带你走进美丽的墨尔本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ozairs.com/"/>
  <updated>2019-03-23T08:40:39.070Z</updated>
  <id>http://blog.ozairs.com/</id>
  
  <author>
    <name>Mark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 实战应用</title>
    <link href="http://blog.ozairs.com/Docker/Docker-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Docker/Docker-实战应用/</id>
    <published>2019-03-23T08:39:20.000Z</published>
    <updated>2019-03-23T08:40:39.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Docker平台部署"><a href="#一、Docker平台部署" class="headerlink" title="一、Docker平台部署"></a>一、Docker平台部署</h3><p>Amazon ECS 的 Docker 基本知识</p><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Docker平台部署&quot;&gt;&lt;a href=&quot;#一、Docker平台部署&quot; class=&quot;headerlink&quot; title=&quot;一、Docker平台部署&quot;&gt;&lt;/a&gt;一、Docker平台部署&lt;/h3&gt;&lt;p&gt;Amazon ECS 的 Docker 基本知识&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>AWS 实战部署</title>
    <link href="http://blog.ozairs.com/AWS/AWS-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/AWS/AWS-实战部署/</id>
    <published>2019-03-22T11:30:34.000Z</published>
    <updated>2019-03-22T11:33:28.244Z</updated>
    
    <content type="html"><![CDATA[<p>如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon ECS 首次运行向导或 Amazon ECS 命令行界面 (CLI) 启动首个集群的准备。</p><p>注意</p><p>因为 Amazon ECS 使用 Amazon EC2 的许多组件，所以，您可以将 Amazon EC2 控制台用于这些步骤中的许多步骤。</p><p>要开始设置 Amazon ECS，请完成以下任务。如果您已完成以下任何步骤，可以将其跳过并继续安装自定义 AWS CLI。</p><ol><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#sign-up-for-aws" target="_blank" rel="noopener">注册 AWS</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-user" target="_blank" rel="noopener">创建 IAM 用户</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-role" target="_blank" rel="noopener">创建 IAM 角色</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-key-pair" target="_blank" rel="noopener">创建密钥对</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-vpc" target="_blank" rel="noopener">创建 Virtual Private Cloud</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#install_aws_cli" target="_blank" rel="noopener">安装 AWS CLI</a></li></ol><h2 id="注册-AWS"><a href="#注册-AWS" class="headerlink" title="注册 AWS"></a>注册 AWS</h2><p>当您注册 AWS 时，您的 AWS 账户会自动注册所有服务，包括 Amazon EC2 和 Amazon ECS。您只需为使用的服务付费。</p><p>如果您已有 AWS 账户，请跳到下一个任务。如果您还没有 AWS 账户，请使用以下步骤创建。</p><p><strong>创建 AWS 账户</strong></p><ol><li><p>打开 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html" target="_blank" rel="noopener">https://aws.amazon.com/</a>，然后选择 <strong>Create an AWS Account (创建 AWS 账户)</strong>。</p><p>注意</p><p>如果您之前曾使用 AWS 账户根用户 凭证登录 AWS 管理控制台，请选择 <strong>Sign in to a different account (登录其他账户)</strong>。如果您之前曾使用 IAM 凭证登录控制台，请选择 <strong>Sign-in using root account credentials (使用根账户凭证登录)</strong>。然后选择 <strong>Create a new AWS account (创建新的 AWS 账户)</strong>。</p></li><li><p>按照联机说明操作。</p><p>在注册时，您将接到一通电话，要求您使用电话键盘输入一个验证码。</p></li></ol><p>请记下您的 AWS 账号，因为在下一个任务中您会用到它。</p><h2 id="创建-IAM-用户"><a href="#创建-IAM-用户" class="headerlink" title="创建 IAM 用户"></a>创建 IAM 用户</h2><p>AWS 中的服务（如 Amazon EC2 和 Amazon ECS）要求您在访问时提供凭证，以便服务可以确定您是否有权限访问其资源。控制台要求您的密码。您可以为您的 AWS 账户创建访问密钥以访问命令行界面或 API。但是，我们不建议您使用 AWS 账户的凭证访问 AWS，而建议您改用 AWS Identity and Access Management (IAM)。创建 IAM 用户，然后将该用户添加到具有管理权限的 IAM 组或授予此用户管理权限。然后，您就可以使用专门的 URL 和该 IAM 用户的凭证来访问 AWS。</p><p>如果您已注册 AWS 但尚未为自己创建一个 IAM 用户，则可以使用 IAM 控制台自行创建。</p><p><strong>为您自己创建一个 IAM 用户并将该用户添加到管理员组</strong></p><ol><li><p>使用 AWS 账户电子邮件地址和密码，以 <em>AWS 账户根用户</em> 身份登录到 IAM 控制台 (<a href="https://console.aws.amazon.com/iam/" target="_blank" rel="noopener">https://console.aws.amazon.com/iam/</a>)。</p><p>注意</p><p>强烈建议您遵守以下使用 <strong>Administrator</strong> IAM 用户的最佳实践，妥善保存根用户凭证。只在执行少数<a href="https://docs.aws.amazon.com/general/latest/gr/aws_tasks-that-require-root.html" target="_blank" rel="noopener">账户和服务管理任务</a>时才作为根用户登录。</p></li><li><p>在控制台的导航窗格中，选择 <strong>Users (用户)</strong>，然后选择 <strong>Add user (添加用户)</strong>。</p></li><li><p>对于 <strong>User name (用户名)</strong>，键入 <strong>Administrator</strong>。</p></li><li><p>选中 <strong>AWS 管理控制台 access (AWS 管理控制台访问)</strong> 旁边的复选框，选择 <strong>Custom password (自定义密码)</strong>，然后在文本框中键入新用户的密码。您可以选择 <strong>Require password reset</strong> (需要重置密码) 以强制用户在下次登录时创建新密码。</p></li><li><p>选择<strong>下一步: 权限</strong>。</p></li><li><p>在<strong>设置权限</strong>页面上，选择<strong>将用户添加到组</strong>。</p></li><li><p>选择 <strong>Create group</strong>。</p></li><li><p>在 <strong>Create group (创建组)</strong> 对话框中，对于 <strong>Group name (组名称)</strong>，键入 <strong>Administrators</strong>。</p></li><li><p>对于 <strong>Filter policies (筛选策略)</strong>，选中 <strong>AWS managed - job function (AWS 托管 - 工作职能)</strong> 的复选框。</p></li><li><p>在策略列表中，选中 <strong>AdministratorAccess</strong> 的复选框。然后选择 <strong>Create group</strong>。</p></li><li><p>返回到组列表中，选中您的新组所对应的复选框。如有必要，选择 <strong>Refresh</strong> 以在列表中查看该组。</p></li><li><p>选择 <strong>Next: Tags (下一步: 标签)</strong> 通过以键值对的形式附加标签来向用户添加元数据。</p></li><li><p>选择 <strong>Next: Review</strong> 以查看要添加到新用户的组成员资格的列表。如果您已准备好继续，请选择 <strong>Create user</strong>。</p></li></ol><p>您可使用此相同的流程创建更多的组和用户，并允许您的用户访问 AWS 账户资源。要了解有关使用策略限制用户对特定 AWS 资源的权限的信息，请参阅<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html" target="_blank" rel="noopener">访问管理</a>和<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_examples.html" target="_blank" rel="noopener">示例策略</a>。</p><p>要以该新 IAM 用户的身份登录，请从 AWS 控制台注销，然后使用以下 URL，其中 <em>your_aws_account_id</em> 是您不带连字符的 AWS 账号（例如，如果您的 AWS 账号是 <code>1234-5678-9012</code>，则您的 AWS 账户 ID 是 <code>123456789012</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_aws_account_id.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>输入您刚创建的 IAM 用户名和密码。登录后，导航栏显示 <em>your_user_name</em> @ <em>your_aws_account_id</em>。</p><p>如果您不希望您的登录页面 URL 包含 AWS 账户 ID，可以创建账户别名。从 IAM 控制面板中，选择 <strong>Create Account Alias (创建账户别名)</strong>，然后输入一个别名，例如您的公司名称。要在创建账户别名后登录，请使用以下 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_account_alias.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>要为您的账户验证 IAM 用户的登录链接，请打开 IAM 控制台并在控制面板的 <strong>IAM users sign-in link (IAM 用户登录链接)</strong> 下进行检查。</p><p>有关 IAM 的更多信息，请参阅 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/" target="_blank" rel="noopener">AWS Identity and Access Management 用户指南</a>。</p><h2 id="创建-IAM-角色"><a href="#创建-IAM-角色" class="headerlink" title="创建 IAM 角色"></a>创建 IAM 角色</h2><p>在 Amazon ECS 容器代理可以代表您调用 Amazon ECS API 操作之前，它需要服务的 IAM 策略和角色，以便了解属于您的代理。</p><p>对于使用 EC2 启动类型的任务，您可以创建一个 IAM 角色，该角色可让代理知道应向哪个账户注册容器实例。当您使用 Amazon 通过此角色提供的经 Amazon ECS 优化的 AMI 启动容器实例时，代理会自动将容器实例注册到 <code>default</code> 集群中。此角色称为 Amazon ECS 容器实例 IAM 角色。有关更多信息，请参阅<a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/instance_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 容器实例 IAM 角色</a>。</p><p>Amazon ECS 容器代理还会代表您调用 Amazon EC2 和 Elastic Load Balancing API，以便在负载均衡器中注册和取消注册容器实例。您必须在启动服务前为其创建一个 IAM 角色，然后才能将负载均衡器附加到 Amazon ECS 服务。此要求适用于您计划用于负载均衡器的任意 Amazon ECS 服务。此角色称为 Amazon ECS 服务计划程序 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/service_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 服务计划程序 IAM 角色</a>。</p><p>对于使用 Fargate 启动类型的任务，您可以创建一个 IAM 角色，该角色允许代理从 Amazon ECR 中提取容器映像或者使用 awslogs 日志驱动程序，该驱动程序是当前唯一受支持的此启动类型的日志记录选项。此角色称为 Amazon ECS 任务执行 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/task_execution_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 任务执行 IAM 角色</a>。</p><p>注意</p><p>在 Amazon ECS 控制台首次运行体验中，将自动为您创建这些 IAM 角色，因此，如果您打算使用控制台，则可以继续下一个部分。如果您不打算使用控制台，而是计划使用 AWS CLI，则需要手动创建这些 IAM 角色。</p><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>对于 Amazon ECS，密钥对只有在您打算使用 EC2 启动类型时才需要。</p><p>AWS 使用公有密钥密码术来保护实例的登录信息。 Linux 实例（例如 Amazon ECS 容器实例）没有用于 SSH 访问的密码。您使用密钥对安全地登录到实例。您可以在启动容器实例时指定密钥对的名称，然后提供私有密钥（使用 SSH 登录时）。</p><p>如果您尚未创建密钥对，则可以通过 Amazon EC2 控制台自行创建。如果您计划在多个区域启动实例，则需要在每个区域中创建密钥对。有关区域的更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p><strong>创建密钥对</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中，选择密钥对所在的区域。您可以选择向您提供的任何区域，无需理会您身处的位置。但是，密钥对特定于区域。例如，如果您计划在美国东部（俄亥俄）区域中启动容器实例，则必须在美国东部（俄亥俄）区域中为实例创建密钥对。</p><p><img src="/AWS/AWS-实战部署/1.png" alt="                         选择一个区域                     "></p></li><li><p>在导航窗格中的 <strong>NETWORK &amp; SECURITY</strong> 下，选择 <strong>Key Pairs</strong>。</p><p>提示</p><p>导航窗格位于控制台的左侧。如果您看不到窗格，它可能被最小化了；请选择箭头展开该窗格。您可能必须向下滚动才能看到 <strong>Key Pairs</strong> 链接。</p><p><img src="/AWS/AWS-实战部署/2.png" alt="                         打开密钥对页                     "></p></li><li><p>选择 <strong>Create Key Pair</strong>。</p></li><li><p>在 <strong>Create Key Pair</strong> 对话框的 <strong>Key pair name</strong> 字段中输入新密钥对的名称，然后选择 <strong>Create</strong>。使用一个容易记住的名称 (如您的 IAM 用户名) 后跟 <code>-key-pair</code> 加区域名称。例如，<em>me</em>-key-pair-<em>useast2</em>。</p></li><li><p>您的浏览器会自动下载私有密钥文件。基本文件名是您为密钥对指定的名称，文件扩展名为 <code>.pem</code>。将私有密钥文件保存在安全位置。</p><p>重要</p><p>这是您保存私有密钥文件的唯一机会。启动实例时，提供密钥对的名称；每次连接到实例时，提供相应的私有密钥。</p></li><li><p>如果您在 macOS 或 Linux 计算机上使用 SSH 客户端连接到您的 Linux 实例，请使用以下命令设置您私有密钥文件的权限，以确保只有您可以读取它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 your_user_name-key-pair-region_name.pem</span><br></pre></td></tr></table></figure></li></ol><p>有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" target="_blank" rel="noopener">Amazon EC2 密钥对</a>。</p><p><strong>使用密钥对连接到实例</strong></p><p>要从运行 macOS 或 Linux 的计算机连接到 Linux 实例，需要使用 <code>-i</code> 选项对 SSH 客户端指定 <code>.pem</code> 文件和私有密钥的路径。若要从运行 Windows 的计算机连接到 Linux 实例，可以使用 MindTerm 或 PuTTY。如果您计划使用 PuTTY，则需要安装它并遵循以下过程将 <code>.pem</code> 文件转换为 <code>.ppk</code> 文件。</p><p><strong>（可选）准备使用 PuTTY 从 Windows 连接到 Linux 实例</strong></p><ol><li><p>从 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a> 下载并安装 PuTTY。请务必安装整个套件。</p></li><li><p>启动 PuTTYgen（例如，在<strong>开始</strong>菜单中，依次单击<strong>所有程序 &gt; PuTTY &gt; PuTTYgen</strong> ）。</p></li><li><p>在 <strong>Type of key to generate</strong> 下，选择 <strong>RSA</strong>。</p><p><img src="/AWS/AWS-实战部署/3.png" alt="                         PuTTYgen 中的 SSH-2 RSA 密钥                     "></p></li><li><p>选择 <strong>Load</strong>。默认情况下，PuTTYgen 仅显示扩展名为 <code>.ppk</code> 的文件。要找到您的 <code>.pem</code> 文件，请选择显示所有类型的文件的选项。</p><p><img src="/AWS/AWS-实战部署/4.png" alt="                         选择所有文件类型                     "></p></li><li><p>选择您在上一个过程中创建的私有密钥文件，然后选择 <strong>Open</strong>。选择 <strong>OK</strong> 关闭确认对话框。</p></li><li><p>选择 <strong>Save private key (保存私有密钥)</strong>。PuTTYgen 会显示一条警告，提示将在未提供口令的情况下保存密钥。选择<strong>是</strong>。</p></li><li><p>为密钥指定密钥对所用的相同名称。PuTTY 会自动添加 <code>.ppk</code> 文件扩展名。</p></li></ol><h2 id="创建-Virtual-Private-Cloud"><a href="#创建-Virtual-Private-Cloud" class="headerlink" title="创建 Virtual Private Cloud"></a>创建 Virtual Private Cloud</h2><p>Amazon Virtual Private Cloud (Amazon VPC) 允许您在已定义的虚拟网络内启动 AWS 资源。强烈建议您在 VPC 中启动您的容器实例。</p><p>注意</p><p>Amazon ECS 控制台首次运行体验会为您的集群创建 VPC，因此，如果您打算使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您有默认 VPC，也可以跳过此部分并进入下一个任务，即 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a>。要确定您是否具有默认 VPC，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html#console-updates" target="_blank" rel="noopener">Amazon EC2 控制台中支持的平台</a>。否则，您可以使用以下步骤在账户中创建非默认 VPC。</p><p>重要</p><p>如果您的账户在某个区域中支持 Amazon EC2 Classic，则您在该区域没有默认 VPC。</p><p><strong>创建非默认 VPC</strong></p><ol><li>打开 Amazon VPC 控制台 <a href="https://console.aws.amazon.com/vpc/" target="_blank" rel="noopener">https://console.aws.amazon.com/vpc/</a>。</li><li>从导航栏中，为 VPC 选择区域。VPC 特定于某一区域，因此您应选择已创建密钥对的区域。</li><li>在 VPC 控制面板上，选择 <strong>Launch VPC Wizard (启动 VPC 向导)</strong>。</li><li>在 <strong>Step 1: Select a VPC Configuration</strong> 页面上，确保选中 <strong>VPC with a Single Public Subnet</strong>，然后选择 <strong>Select</strong>。</li><li>在 <strong>Step 2: VPC with a Single Public Subnet (步骤 2: 带有单个公有子网的 VPC)</strong> 页面上，在 <strong>VPC name (VPC 名称)</strong> 字段中为您的 VPC 输入友好名称。保留其他默认配置设置，然后选择 <strong>Create VPC</strong>。在确认页面上，请选择 <strong>OK</strong>。</li></ol><p>有关 Amazon VPC 的更多信息，请参阅 <em>Amazon VPC 用户指南</em> 中的 <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/" target="_blank" rel="noopener">Amazon VPC 是什么？</a>。</p><h2 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h2><p>安全组用作相关容器实例的防火墙，可在容器实例级别控制入站和出站流量。您可以向安全组添加规则，以便使用 SSH 从您的 IP 地址连接到容器实例。您还可以添加允许来自任意位置的入站和出站 HTTP 和 HTTPS 访问的规则。向任务所需的开放端口添加任意规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。</p><p>注意</p><p>Amazon ECS 控制台首次运行时会为您的实例创建安全组并根据您使用的任务定义创建负载均衡器，因此，如果要使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您计划在多个区域中启动容器实例，则需要在每个区域中创建安全组。有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p>提示</p><p>您需要本地计算机的公有 IP 地址，可以使用服务获得该地址。例如，我们提供以下服务：<a href="http://checkip./" target="_blank" rel="noopener">http://checkip.amazonaws.com/</a> 或 <a href="https://checkip./" target="_blank" rel="noopener">https://checkip.amazonaws.com/</a>。要查找另一项可提供您的 IP 地址的服务，请使用搜索短语“what is my IP address”。 如果您通过 Internet 服务提供商 (ISP) 连接或者在不使用静态 IP 地址的情况下从防火墙后面连接，则必须找出客户端计算机使用的 IP 地址范围。</p><p><strong>为您的 VPC 创建具有最小特权的</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中选择安全组的区域。安全组特定于某一区域，因此您应选择已创建密钥对的区域。</p></li><li><p>在导航窗格中，选择 <strong>Security Groups</strong>，然后选择 <strong>Create Security Group</strong>。</p></li><li><p>输入新安全组的名称和描述。选择一个您容易记住的名称，例如 <em>ecs-instances-default-cluster</em>。</p></li><li><p>在 <strong>VPC</strong> 列表中，确保选择了您的默认 VPC。它标有星号 (*)。</p><p>注意</p><p>如果您的账户支持 Amazon EC2 Classic，请选择您在上一个任务中创建的 VPC。</p></li><li><p>Amazon ECS 容器实例不需要打开任何入站端口。但您可能需要添加 SSH 规则，以便登录容器实例并使用 Docker 命令检查任务。如果您希望容器实例托管运行 Web 服务器的任务，也可以添加适用于 HTTP 和 HTTPS 的规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。完成以下步骤可添加这些可选的安全组规则。</p><p>在 <strong>Inbound</strong> 选项卡上，创建以下规则 (为每个新规则选择 <strong>Add Rule</strong>)，然后选择 <strong>Create</strong>：</p><ul><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTP</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTPS</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>SSH</strong>。在 <strong>Source</strong> 字段中，确保选中 <strong>Custom IP</strong>，然后采用 CIDR 表示法指定您计算机或网络的公有 IP 地址。要采用 CIDR 表示法指定单个 IP 地址，请添加路由前缀 <code>/32</code>。例如，如果您的 IP 地址是 <code>203.0.113.25</code>，请指定 <code>203.0.113.25/32</code>。如果您的公司要分配同一范围内的地址，请指定整个范围，例如 <code>203.0.113.0/24</code>。</p><p>重要</p><p>出于安全原因，我们不建议您允许从所有 IP 地址 (<code>0.0.0.0/0</code>) 对您的实例进行 SSH 访问（以测试为目的的短暂访问除外）。</p></li></ul></li></ol><h2 id="安装-AWS-CLI"><a href="#安装-AWS-CLI" class="headerlink" title="安装 AWS CLI"></a>安装 AWS CLI</h2><p>可以在 AWS 管理控制台中手动管理 Amazon ECS 的所有操作。但是，您可以在本地桌面上安装 AWS CLI 或开发人员工具包并生成脚本，以便在 Amazon ECS 中自动执行常见管理任务。</p><p>要对 Amazon ECS 使用 AWS CLI，请安装最新版本的 AWS CLI。有关安装 AWS CLI 或升级到最新版本的信息，请参阅 <em>AWS Command Line Interface 用户指南</em> 中的<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" target="_blank" rel="noopener">安装 AWS 命令行界面</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon E
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="ECS" scheme="http://blog.ozairs.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Splunk入门手册</title>
    <link href="http://blog.ozairs.com/Big-Data/Splunk%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://blog.ozairs.com/Big-Data/Splunk入门手册/</id>
    <published>2019-03-22T04:07:41.000Z</published>
    <updated>2019-03-22T04:20:08.795Z</updated>
    
    <content type="html"><![CDATA[<p>一、关于搜索不同时间段的记录</p><p>*earliest=-24h@h latest=-12h@h</p><p>二、关于搜索不同目录的记录</p><p>*source=”/var/log/ansible.log” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、关于搜索不同时间段的记录&lt;/p&gt;
&lt;p&gt;*earliest=-24h@h latest=-12h@h&lt;/p&gt;
&lt;p&gt;二、关于搜索不同目录的记录&lt;/p&gt;
&lt;p&gt;*source=”/var/log/ansible.log” &lt;/p&gt;

      
    
    </summary>
    
      <category term="Big Data" scheme="http://blog.ozairs.com/categories/Big-Data/"/>
    
    
      <category term="Splunk" scheme="http://blog.ozairs.com/tags/Splunk/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes实战应用</title>
    <link href="http://blog.ozairs.com/Kubernetes/Kubernetes%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Kubernetes/Kubernetes实战应用/</id>
    <published>2019-03-20T22:35:07.000Z</published>
    <updated>2019-03-22T02:45:54.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、平台构建"><a href="#一、平台构建" class="headerlink" title="一、平台构建"></a>一、平台构建</h3><p>1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Service Mesh</p><p><a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md</a></p><h3 id="二、集群部署命令"><a href="#二、集群部署命令" class="headerlink" title="二、集群部署命令"></a>二、集群部署命令</h3><ol><li><p>运营应用：kubectl run helloworld –image=karthequian/helloworld –port=80</p></li><li><p>查看部署，资源，pods</p><p>kubectl get deployments</p><p>kubectl get rs</p><p>kuebectl get pods</p></li><li><p>部署服务</p><p>kubectl expose deployment helloworld –type=NodePort</p></li><li><p>通过文件方式部署服务和Deployment</p><p>kubectl create -f deploy-all.yml</p></li><li><p>查看服务</p><p>kubectl get services</p></li><li><p>扩展集群服务器</p><p>kubectl scale –replicas=3 deploy/helloworld</p></li><li><p>启动应用</p><p>minikube service helloworld</p></li><li><p>查看所有部署服务</p><p>minikube get all</p></li><li><p>将部署服务导出到YAML文件</p><p>kubectl get deploy/helloworld -o yaml</p></li><li><p>查看服务器集群状态： kubectl cluster-info</p></li><li><p>定位故障</p><p>kubectl describe deploy/depolyname</p><p>kubectl describe po/podname</p><p>kubectl log podname</p><p>登陆到服务节点：kubectl exec -it podname /bin/bash</p><p>如果单节点存在多个Container，登陆到某个服务节点：<code>kubectl exec -it -c containername podname /bin/bash</code></p><p>查看所有服务进程：<code>ps -ef</code></p></li></ol><h3 id="三、图形化管理工具"><a href="#三、图形化管理工具" class="headerlink" title="三、图形化管理工具"></a>三、图形化管理工具</h3><ol><li><p>查看minikube 插件</p><p><code>minikube addons list</code></p><p><code>minikube addon enable heapester</code></p></li></ol><h3 id="四、如何配置数据"><a href="#四、如何配置数据" class="headerlink" title="四、如何配置数据"></a>四、如何配置数据</h3><ol><li><p>To create a configmap for this literal type <code>kubectl create configmap logger --from-literal=log_level=debug</code></p></li><li><p>To see all your configmaps: <code>kubectl get configmaps</code></p></li><li><p>To read the value in the logger configmap: <code>kubectl get configmap/logger -o yaml</code></p></li><li><p>To edit the value, we can run <code>kubectl edit configmap/logger</code></p></li></ol><p>`</p><h3 id="五、如何配置应用密钥"><a href="#五、如何配置应用密钥" class="headerlink" title="五、如何配置应用密钥"></a>五、如何配置应用密钥</h3><ol><li><p>To create a secret: <code>kubectl create secret generic apikey --from-literal=api_key=123456789</code></p></li><li><p>Notice that we can’t read the value of the secret directly:<br><code>kubectl get secret apikey -o yaml</code></p></li><li><p>Understand how to add a secret to a deployment</p><p>​         Adding a secret to a deployment is similar to what we did for configmaps. You can add a secret to the env portion, and start up the deployment with:<br><code>kubectl create -f secretreader-deployment.yaml</code></p></li></ol><h3 id="六、如何创建任务"><a href="#六、如何创建任务" class="headerlink" title="六、如何创建任务"></a>六、如何创建任务</h3><h3 id="How-to-run-jobs"><a href="#How-to-run-jobs" class="headerlink" title="How to run jobs"></a>How to run jobs</h3><p>Jobs are a construct that run a pod once, and then stop. However, unlike pods in deployments, the output of the job is kept around until you decide to remove it.</p><p>Running a job is similar to running a deployment, and we can create this by <code>kubectl create -f simplejob.yaml</code></p><p>To see the output of the job: <code>kubectl get jobs</code></p><p>You can find the pod that ran by doing a <code>kubectl get pods --all-pods</code>, and then get the logs from it as well.</p><h3 id="How-to-run-cron-jobs"><a href="#How-to-run-cron-jobs" class="headerlink" title="How to run cron jobs"></a>How to run cron jobs</h3><p>Cron jobs are like jobs, but they run periodically.</p><p>Start your cron by running <code>kubectl create -f cronjob.yaml</code></p><p>We can use the cronjob api to view your cronjobs: <code>kubectl get cronjobs</code>. It adds the last schedule date</p><h3 id="七、如何创建DaemonSet"><a href="#七、如何创建DaemonSet" class="headerlink" title="七、如何创建DaemonSet"></a>七、如何创建DaemonSet</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、平台构建&quot;&gt;&lt;a href=&quot;#一、平台构建&quot; class=&quot;headerlink&quot; title=&quot;一、平台构建&quot;&gt;&lt;/a&gt;一、平台构建&lt;/h3&gt;&lt;p&gt;1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Serv
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Istio - Kubernetes和云原生系统的服务网格</title>
    <link href="http://blog.ozairs.com/Kubernetes/Istio-Kubernetes%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>http://blog.ozairs.com/Kubernetes/Istio-Kubernetes和云原生系统的服务网格/</id>
    <published>2019-03-20T21:17:38.000Z</published>
    <updated>2019-03-20T21:19:23.004Z</updated>
    
    <content type="html"><![CDATA[<p>微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改进授权和安全性，管理路由，收集指标等的能力。点击上面的视频观看剧集并获取所有详细信息。</p><iframe width="987" height="555" src="https://www.youtube.com/embed/rL_p8KIUgwE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong>编辑成绩单</strong><br><em>对于那些喜欢阅读的人，我们已经通过我们的编辑运行成绩单，以获得更顺畅的阅读体验。</em></p><p>如果您在过去几年中一直在微服务领域工作，那么服务网格的概念对您来说可能并不陌生。对于我们其他人来说，它有点诞生于微服务空间带来的一些需求，特别是对可见性，流量路由，身份验证，安全性和指标收集的一些需求。问题源于这样一个事实，即在云空间内，特别是微服务空间，当我们将服务转移到容器中时，这是一种非常常见的模型，我们失去了一些我们能够用来获得经典可见性的仪器单片应用。</p><p>例如，在单一应用程序中，应用程序内的内部服务将通过内部消息传递进行通信，并且这些消息通信范例通常通过应用程序本身内的交互来管理。您基本上可以监视在不同资源之间传递的消息的内存空间。当我们突然去微服务时，不再容易完成。当我们去容器时，我们突然失去了将一些额外服务添加到我们的基础虚拟机中以收集该信息的能力。</p><p>嗯，这就是服务网格概念发挥作用的地方。让我们在所有微服务之间放置一些东西，然后捕获它们之间的所有流量。这会产生一些问题。特别是在分布式系统中，我突然想知道如何管理实际监控和计量我的服务的所有那些交互式小组件。</p><p>随之而来的是Kubernetes，突然之间游戏发生了巨大的变化。并不是我们无法实现这些服务功能，而是现在我们可以直接在各个服务容器本身旁边注入该功能。这通过一种称为服务注入的技术或有效地将另一个容器添加到我们的环境中来完成 然后最重要的是，由于我们通常关注网络流量，我们再次谈到微服务是这种通信的主要模型，我们实际上可以开始在pod中绑定服务，我们实际上是重定向本地流量现在。</p><p>通过这样做，我们解决了微服务所带来的一些问题。特别是监视资源之间通信的能力。这是Google实际带入Istio领域的事情之一，能够有效地捕获这些数据，有效地扩展了容器引擎（cAdvisor引擎）的概念，用于人们在应用程序空间中使用的容器运行时。基本上，然后能够查看应用程序数据流，然后集中该度量数据并可能监视通信。</p><p>一旦我完成了这一切 - 一旦我在那个级别注入了自己 - 我正在看着来回流动的数据包我可以做一些非常有趣的事情。我可以添加身份验证，因此这是IBM为这一组合做出的贡献之一。在路由之上是能够对这些不同服务之间的连接进行排序。路由是我可以控制的另一件事; 任何帧被发送而不是只是说好我将永远转发到负载均衡器，它将分配给n个资源，负载均衡器成为我沟通的一部分。现在我可以确定我实际上要将这些帧发送到哪个目标非常强大。</p><p>由于我有这种控制水平，我甚至可以做一些有趣的事情，比如注入错误。因此，当我开始将我的应用程序分发给这些微服务时，如果出现问题，我很难弄清楚我的应用程序将如何表现。我如何在任何一个特定的微服务中实际强制失败，以检查我的应用程序在遇到这种故障时如何保持弹性？好吧，我现在可以开始注入它作为我的QA或开发过程的一部分，甚至包括生产级别的注入。我可以继续创建故障以确保我的系统继续正常运行，如果不是，我实际上可以提醒它。</p><p>所以这些是微服务网格的一些交互 - 服务网格 - 空间实际提供，而Istio通过可注入代理提供这一点。基本上，我将采用代理引擎，在这种情况下，Istio空间正在使用Envoy代理。Envoy最初由Lyft开发，现在是CNCF的一个开源项目。实际上，Isto也是CNCF的一部分，对于那些没有听说过的人来说，它是Cloud Native Computing Foundation，它是Linux Foundation空间中的一个子基础。</p><p>所以这个服务功能真的是Istio提供的。Istio提供此Envoy代理功能，可以在Kubernetes空间中注入每个容器，或者如果要使用非Kubernetes模型，则将其插入转发路径。使用像Docker这样的容器甚至是虚拟机; 您实际上可以将此代理添加为虚拟机中的进程，并通过该方式注入流量。所以我们可以使用微服务…我们也可以使用大型服务，单片服务，我们可以使用这个服务网格将它们连接在一起。</p><p>但是有了Istio，我们就会获得身份验证，所以因为所有流量都通过这些Envoy代理，我实际上可以验证和结束通信。我可以监控和计量流量，以了解延迟发生的情况; 看看我在路径基础上获得了什么样的吞吐量。我可以将它发送到中央跟踪服务开放跟踪，例如，Jaeger项目是在那里使用的相当常见的项目之一。我也可以像我说的那样开始研究路由。我可以重定向流量并在Kubernetes空间内，例如，我可以使用标签来实际定义我的端点在哪里以及应该在哪里提供服务。</p><p>这一切都非常强大，但现在我也有中央控制权。这是这个Istio带来的最后一件事 - 中央证书控制。这对TLS身份验证很重要。使用名为Mixer的工具收集中心指标，实际上将所有指标数据收集在一起，然后集中配置控制，这实际上是为什么Envoy被选为代理。因为使用Envoy，我现在有一个中央控制器，可以将配置分发到该网格内的所有分布式代理。Envoy以非常有效的方式实现这一点，因为它实际上不需要重新配置重启; 它可以进行热重新配置 - 一个非常强大的功能！</p><p>因此，服务网格是微服务空间的重要组成部分。它真正改变了微服务如何拼接在一起，如何对它们进行计量/监控，甚至通过从具有安全性的集中控制平面注入故障来改善这些服务的性能和弹性。所以在这一大捆绑中有很多东西，但那真的是Istio的能力。更一般地说，它是云本机引擎中更大的服务网格空间的一部分，它真正接管了当今应用程序的构建方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Ant简介以及两者的区别</title>
    <link href="http://blog.ozairs.com/DevOps/Maven%E5%92%8CAnt%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ozairs.com/DevOps/Maven和Ant简介以及两者的区别/</id>
    <published>2019-03-20T20:59:39.000Z</published>
    <updated>2019-03-20T21:02:59.763Z</updated>
    
    <content type="html"><![CDATA[<p>一．Maven简介<br>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代工具）不能满足绝大多数开发人员的需要。通过检查 Ant 构建文件，很难发现项目的相关性信息和其它信息（如开发人员/拥有者、版本或站点主页）。<br>Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。<br>Maven这个单词来自于意第绪语，意为知识的积累，最早在Jakata Turbine项目中它开始被用来试图简化构建过程。当时有很多项目，它们的Ant build文件仅有细微的差别，而JAR文件都由CVS来维护。于是Maven创始者开始了Maven这个项目，该项目的清晰定义包括，一种很方便的发布项目信息的方式，以及一种在多个项目中共享JAR的方式.<br>二．Maven常用命令<br>mvn archetype：create 创建Maven项目<br>mvn compile 编译源代码<br>mvn deploy 发布项目<br>mvn test-compile 编译测试源代码<br>mvn test 运行应用程序中的单元测试<br>mvn site 生成项目相关信息的网站<br>mvn clean 清除项目目录中的生成结果<br>mvn package 根据项目生成的jar<br>mvn install 在本地Repository中安装jar<br>mvn eclipse:eclipse 生成eclipse项目文件<br>mvnjetty:run 启动jetty服务<br>mvntomcat:run 启动tomcat服务</p><pre><code>Ant</code></pre><p>Ant简介<br>Ant是一种基于Java的build工具。理论上来说，它有些类似于（Unix）C中的make ，但没有make的缺陷。目前的最新版本为：Ant 1.9.1<br>既然我们已经有了make, gnumake, nmake, jam以及其他的build工具为什么还要要一种新的build工具呢？因为Ant的原作者在多种(硬件)平台上开发软件时，无法忍受这些工具的限制和不便。类似于make的工具本质上是基于shell（语言）的：他们计算依赖关系，然后执行命令（这些命令与你在命令行敲的命令没太大区别）。这就意味着你可以很容易地通过使用OS特有的或编写新的（命令）程序扩展该工具；然而，这也意味着你将自己限制在了特定的OS，或特定的OS类型上，如Unix。<br>Ant就不同了。与基于shell命令的扩展模式不同，Ant用Java的类来扩展。（用户）不必编写shell命令，配置文件是基于XML的，通过调用target树，就可执行各种task。每个task由实现了一个特定Task接口的对象来运行。<br>当一个代码项目大了以后，每次重新编译，打包，测试等都会变得非常复杂而且重复，因此c语言中有make脚本来帮助这些工作的批量完成。在Java 中应用是平台无关性的，当然不会用平台相关的make脚本来完成这些批处理任务了，ANT本身就是这样一个流程脚本引擎，用于自动化调用程序完成项目的编译，打包，测试等。除了基于JAVA是平台无关的外，脚本的格式是基于XML的，比make脚本来说还要好维护一些。<br>每个ant脚本（缺省叫build.xml）中设置了一系列任务(target)：比如对于一个一般的项目可能需要有以下任务。</p><ul><li>任务1：usage 打印本脚本的帮助信息（缺省）</li><li>任务2：clean &lt;– init 清空初始化环境</li><li>任务3：javadoc &lt;– build &lt;– init 生成JAVADOC</li><li>任务4：jar &lt;– build &lt;– init 生成JAR</li><li>任务5：all &lt;– jar + javadoc &lt;– build &lt;– init 完成以上所有任务：jar javadoc<br>注：我看到很多项目的ant脚本中的命名基本上都是一致的，比如：编译一般叫build或者compile；打包一般叫jar或war；生成文档一般命名为 javadoc或javadocs；执行全部任务all。在每个任务的中，ANT会根据配置调用一些外部应用并配以相应参数执行。虽然ANT可调用的外部应用种类非常丰富，但其实最常用的就2，3个：比如javac javadoc jar等。<br>二．Ant的优点<br>Ant是Apache软件基金会JAKARTA目录中的一个子项目，它有以下的优点。<br>跨平台性。Ant是纯Java语言编写的，因此具有很好的跨平台性。<br>操作简单。Ant是由一个内置任务和可选任务组成的。Ant运行时需要一个XML文件(构建文件)。<br>Ant通过调用target树，就可以执行各种task。每个task实现了特定接口对象。由于Ant构建文件时XML格式的文件，所以很容易维护和书写，而且结构很清晰。<br>Ant可以集成到开发环境中。由于Ant的跨平台性和操作简单的特点，它很容易集成到一些开发环境中去。<br>三．Ant 开发<br>Ant的构建文件<br>当开始一个新的项目时，首先应该编写Ant构建文件。构建文件定义了构建过程，并被团队开发中每个人使用。Ant构建文件默认命名为build.xml，也可以取其他的名字。只不过在运行的时候把这个命名当作参数传给Ant。构建文件可以放在任何的位置。一般做法是放在项目顶层目录中，这样可以保持项目的简洁和清晰。下面是一个典型的项目层次结构。<br>(1) src存放文件。<br>(2) class存放编译后的文件。<br>(3) lib存放第三方JAR包。<br>(4) dist存放打包，发布以后的代码。<br>Ant构建文件是XML文件。每个构建文件定义一个唯一的项目(Project元素)。每个项目下可以定义很多目标(target元素)，这些目标之间可以有依赖关系。当执行这类目标时，需要执行他们所依赖的目标。<br>每个目标中可以定义多个任务，目标中还定义了所要执行的任务序列。Ant在构建目标时必须调用所定义的任务。任务定义了Ant实际执行的命令。Ant中的任务可以为3类。<br>（1） 核心任务。核心任务是Ant自带的任务。<br>（2） 可选任务。可选任务实来自第三方的任务，因此需要一个附加的JAR文件。<br>（3） 用户自定义的任务。用户自定义的任务是用户自己开发的任务。<br>1.<project>标签<br>每个构建文件对应一个项目。<project>标签时构建文件的根标签。它可以有多个内在属性，就如代码中所示，其各个属性的含义分别如下。<br>(1) default表示默认的运行目标，这个属性是必须的。<br>(2) basedir表示项目的基准目录。<br>(3) name表示项目名。<br>(4) description表示项目的描述。<br>每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有自己的构建文件。<br>2.<target>标签<br>一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。<br>例如，有一个target用于编译程序，另一个target用于生成可执行文件。在生成可执行文件之前必须先编译该文件，因此可执行文件的target依赖于编译程序的target。Target的所有属性如下。<br>(1).name表示标明，这个属性是必须的。<br>(2).depends表示依赖的目标。<br>(3)if表示仅当属性设置时才执行。<br>(4)unless表示当属性没有设置时才执行。<br>(5)description表示项目的描述。<br>Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行每个target。在执行之前，首先需要执行它所依赖的target。程序中的名为run的target的depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执行的顺序是prepare-&gt;compile-&gt;run。<br>一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总会被执行。<br>3.<mkdir>标签<br>该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：<br><mkdir dir="”${class.root}”/"><br>通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。<br>4<jar>标签<br>该标签用来生成一个JAR文件，其属性如下。<br>(1) destfile表示JAR文件名。<br>(2) basedir表示被归档的文件名。<br>(3) includes表示被归档的文件模式。<br>(4) exchudes表示被排除的文件模式。<br>5．&lt;javac标签&gt;<br>该标签用于编译一个或一组java文件，其属性如下。<br>(1).srcdir表示源程序的目录。<br>(2).destdir表示class文件的输出目录。<br>(3).include表示被编译的文件的模式。<br>(4).excludes表示被排除的文件的模式。<br>(5).classpath表示所使用的类路径。<br>(6).debug表示包含的调试信息。<br>(7).optimize表示是否使用优化。<br>(8).verbose 表示提供详细的输出信息。<br>(9).fileonerror表示当碰到错误就自动停止。<br>6．<java>标签<br>该标签用来执行编译生成的.class文件，其属性如下。<br>(1).classname 表示将执行的类名。<br>(2).jar表示包含该类的JAR文件名。<br>(3).classpath所表示用到的类路径。<br>(4).fork表示在一个新的虚拟机中运行该类。<br>(5).failonerror表示当出现错误时自动停止。<br>(6).output 表示输出文件。<br>(7).append表示追加或者覆盖默认文件。<br>7.<delete>标签<br>该标签用于删除一个文件或一组文件，其属性如下。<br>(1)/file表示要删除的文件。<br>(2).dir表示要删除的目录。<br>(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。<br>(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。<br>(5).verbose表示指定是否列出所删除的文件，默认值为不列出。<br>8.<copy>标签<br>该标签用于文件或文件集的拷贝，其属性如下。<br>(1).file 表示源文件。<br>(2).tofile 表示目标文件。<br>(3).todir 表示目标目录。<br>(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。<br>(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。<br>(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。<br>(7).verbose 表示制定是否显示详细信息，默认值不显示。<br>四．Ant的数据类型<br>在构建文件中为了标识文件或文件组，经常需要使用数据类型。数据类型包含在org.apache.tool.ant.types包中。下面镜简单介绍构建文件中一些常用的数据类型。</copy></delete></java></jar></mkdir></mkdir></target></project></project></li></ul><ol><li><p>argument 类型<br>由Ant构建文件调用的程序，可以通过<arg>元素向其传递命令行参数，如apply,exec和java任<br>务均可接受嵌套<arg>元素，可以为各自的过程调用指定参数。以下是<arg>的所有属性。<br>(1).values 是一个命令参数。如果参数中有空格，但又想将它作为单独一个值，则使用此属性。<br>(2).file表示一个参数的文件名。在构建文件中，此文件名相对于当前的工作目录。<br>(3).line表示用空格分隔的多个参数列表。<br>(4).path表示路径。<br>2.ervironment 类型<br>由Ant构建文件调用的外部命令或程序，<env>元素制定了哪些环境变量要传递给正在执行的系统命令，<env>元素可以接受以下属性。<br>(1).file表示环境变量值的文件名。此文件名要被转换位一个绝对路径。<br>(2).path表示环境变量的路径。Ant会将它转换为一个本地约定。<br>(3).value 表示环境变量的一个直接变量。<br>(4).key 表示环境变量名。<br>注意 file path 或 value只能取一个。<br>3.filelist类型<br>Filelist 是一个支持命名的文件列表的数据类型，包含在一个filelist类型中的文件不一定是存在的文件。以下是其所有的属性。<br>(1).dir是用于计算绝对文件名的目录。<br>(2).files 是用逗号分隔的文件名列表。<br>(3).refid 是对某处定义的一个<filelist>的引用。<br>注意 dir 和 files 都是必要的，除非指定了refid(这种情况下，dir和files都不允许使用)。<br>4.fileset类型<br>Fileset 数据类型定义了一组文件，并通常表示为<fileset>元素。不过，许多ant任务构建成了隐式的fileset,这说明他们支持所有的fileset属性和嵌套元素。以下为fileset 的属性列表。<br>(1).dir表示fileset 的基目录。<br>(2).casesensitive的值如果为false，那么匹配文件名时，fileset不是区分大小写的，其默认值为true.<br>(3).defaultexcludes 用来确定是否使用默认的排除模式，默认为true。<br>(4).excludes 是用逗号分隔的需要派出的文件模式列表。<br>(5).excludesfile 表示每行包含一个排除模式的文件的文件名。<br>(6).includes 是用逗号分隔的，需要包含的文件模式列表。<br>(7).includesfile 表示每行包括一个包含模式的文件名。<br>5.patternset 类型<br>Fileset 是对文件的分组，而patternset是对模式的分组，他们是紧密相关的概念。<patternset>支持4个属性：includes excludex includexfile 和 excludesfile,与fileset相同。Patternset 还允许以下嵌套元素：include,exclude,includefile 和 excludesfile.<br>6.filterset 类型<br>Filterset定义了一组过滤器，这些过滤器将在文件移动或复制时完成文件的文本替换。<br>主要属性如下：<br>(1).begintoken 表示嵌套过滤器所搜索的记号，这是标识其开始的字符串。<br>(2).endtoken表示嵌套过滤器所搜索的记号这是标识其结束的字符串。<br>(3).id是过滤器的唯一标志符。<br>(4).refid是对构建文件中某处定义一个过滤器的引用。<br>7.Path类型<br>Path元素用来表示一个类路径，不过它还可以用于表示其他的路径。在用作几个属性时，路经中的各项用分号或冒号隔开。在构建的时候，此分隔符将代替当前平台中所有的路径分隔符，其拥有的属性如下。<br>(1).location 表示一个文件或目录。Ant在内部将此扩展为一个绝对路径。<br>(2).refid 是对当前构建文件中某处定义的一个path的引用。<br>(3).path表示一个文件或路径名列表。<br>8.mapper类型<br>Mapper类型定义了一组输入文件和一组输出文件间的关系，其属性如下。<br>(1).classname 表示实现mapper类的类名。当内置mapper不满足要求时，用于创建定制mapper.<br>(2).classpath表示查找一个定制mapper时所用的类型路径。<br>(3).classpathref是对某处定义的一个类路径的引用。<br>(4).from属性的含义取决于所用的mapper.<br>(5).to属性的含义取决于所用的mapper.<br>(6).type属性的取值为identity，flatten glob merge regexp 其中之一，它定义了要是用的内置mapper的类型。<br>五．Ant的安装<br>解包后在系统可执行路径中加入指向ant的bin的路径就可以了，比如可以在GNU/Linux上把以下配置加入/etc/profile中：<br>export ANT_HOME=/home/ant<br>export JAVA_HOME=/usr/java/j2sdk1.4.1<br>export PATH=$PATH:$JAVA_HOME/bin:$ANT_HOME/bin<br>Windows 下的安装：<br>下载后解压到某个目录我这里以D:\apache-ant-1.7.1为例子：<br>添加path全局环境变量:D:\apache-ant-1.7.1\bin<br>这样在command line就可以运行ant命令了<br>测试：运行-&gt;cmd/command-&gt;ant 如果没有安装成功则回报找不到这个命令，安装成功会有相关的提示信息显示。<br>这样执行ant 后，如果不指定配置文件ant会缺省找build.xml这个配置文件，并根据配置文件执行任务，缺省的任务设置可以指向最常用的任务，比如： build，或指向打印帮助信息：usage，告诉用户有那些脚本选项可以使用。<br>六．Ant的运行<br>安装好Ant并且配置好路径之后，在命令行中切换到构建文件的目录，输入Ant命令就可以运行Ant.若没有指定任何参数，Ant会在当前目录下查询build.xml文件。如果找到了就用该文件作为构建文件。如果使用了 –find 选项，Ant 就会在上级目录中找构建文件，直至到达文件系统的根目录。如果构建文件的名字不是build.xml ，则Ant运行的时候就可以使用 –buildfile file,这里file 指定了要使用的构建文件的名称，示例如下：<br>Ant如下说明了表示当前目录的构建文件为build.xml 运行 ant 执行默认的目标。<br>Ant –buildfile test.xml<br>使用当前目录下的test.xml 文件运行Ant ,执行默认的目标</patternset></fileset></filelist></env></env></arg></arg></arg></p><pre><code>Moven与Ant的区别</code></pre><p>Maven 和 Ant 针对构建问题的两个不同方面。Ant 为 Java 技术开发项目提供跨平台构建任务。Maven 本身描述项目的高级方面，它从 Ant 借用了绝大多数构建任务。因此，由于 Maven 和 Ant 代表两个差异很大的工具，所以接下来只说明这两个工具的等同组件之间的区别。</p></li></ol><p>Maven Ant<br>标准构建文件 project.xml 和 maven.xml build.xml<br>特性处理顺序 ${maven.home}/bin/driver.properties<br>${project.home}/project.properties<br>${project.home}/build.properties<br>${user.home}/build.properties<br>通过 -D 命令行选项定义的系统特性<br>最后一个定义起决定作用。 通过 -D 命令行选项定义的系统特性<br>由 <property> 任务装入的特性<br>第一个定义最先被处理。<br>构建规则 构建规则更为动态（类似于编程语言）；它们是基于 Jelly 的可执行 XML。 构建规则或多或少是静态的，除非使用 <script> 任务。（请参阅 参考资料以获得相关教程。）<br>扩展语言 插件是用 Jelly（XML）编写的。 插件是用 Java 语言编写的。<br>构建规则可扩展性 通过定义 <preGoal> 和 <postGoal> 使构建 goal 可扩展。 构建规则不易扩展；可通过使用 <script> 任务模拟 <preGoal> 和 <postGoal> 所起的作用。<br>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。</p></script></property></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一．Maven简介&lt;br&gt;Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。&lt;br&gt;目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Maven" scheme="http://blog.ozairs.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation经验贴汇总</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation经验贴汇总/</id>
    <published>2019-03-19T12:30:11.000Z</published>
    <updated>2019-03-19T13:02:08.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CloudFormation两年：经验教训"><a href="#1-CloudFormation两年：经验教训" class="headerlink" title="1. CloudFormation两年：经验教训"></a>1. CloudFormation两年：经验教训</h2><p><a href="https://www.colabug.com/4023693.html" target="_blank" rel="noopener">https://www.colabug.com/4023693.html</a></p><h1 id="2-您的基础架构代码CloudFormation与Terraform？"><a href="#2-您的基础架构代码CloudFormation与Terraform？" class="headerlink" title="2.您的基础架构代码CloudFormation与Terraform？"></a>2.您的基础架构代码CloudFormation与Terraform？</h1><p><a href="https://www.colabug.com/3313548.html" target="_blank" rel="noopener">https://www.colabug.com/3313548.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CloudFormation两年：经验教训&quot;&gt;&lt;a href=&quot;#1-CloudFormation两年：经验教训&quot; class=&quot;headerlink&quot; title=&quot;1. CloudFormation两年：经验教训&quot;&gt;&lt;/a&gt;1. CloudFormatio
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>使用Cloud Formation为AWS上的私有实例设置绝对可靠的Bastion节点</title>
    <link href="http://blog.ozairs.com/AWS/%E4%BD%BF%E7%94%A8Cloud-Formation%E4%B8%BAAWS%E4%B8%8A%E7%9A%84%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E7%BB%9D%E5%AF%B9%E5%8F%AF%E9%9D%A0%E7%9A%84Bastion%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.ozairs.com/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/</id>
    <published>2019-03-19T10:43:25.000Z</published>
    <updated>2019-03-19T10:47:22.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg" alt=""></p><p>在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是在实例的安全组的入站规则中简单地允许端口22上的SSH流量，然后通过弹性IP和Internet网关将实例暴露给公共Internet。然而，由于攻击者可能很容易访问您的安全密钥对，并且如果这样的密钥对也可用于其他私有实例，则这会变得有缺陷，那么此类攻击者可以完全访问和控制您的基础结构。</p><p>为了避免这种情况，公司现在使用遍布所有可用区域（AZ）的堡垒实例，其中已经设置了基础架构。Bastion节点是一个专门的实例，故意暴露在互联网上，其设计和配置仅限于遭受攻击的唯一原因。看到堡垒节点暴露在非军事区（DMZ）的公共互联网中，面临潜在攻击的大量风险，因此有必要确保堡垒节点完全万无一失。本文提供了如何设置可靠的堡垒节点的实用见解。使用CloudFormation是因为它通过简单地调整云形成模板中的一些参数，简化了为每个AZ设置堡垒实例的整个瓶颈。</p><p><strong>先修知识：</strong></p><ol><li>基本了解以下Amazon Web服务/概念：EC2，VPC，子网，NAT，安全组和访问控制列表（ACL）</li><li>对云形成的基本认识。</li></ol><p>我们将在10.6.0.0/16 VPC中考虑在10.6.0.0/24子网上具有私有实例的假设网络。此外，我们的堡垒实例应存在于10.5.0.0/24子网中的10.5.0.0/16 VPC中，如下图所示：</p><p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/2.png" alt="img"></p><p>从上图可以看出，NAT网关也已添加到架构中。这为我们的私有实例提供了额外的安全层，只要他们需要访问公共互联网进行软件更新。NAT网关允许来自私有实例的所有出站流量，但阻止从Internet到私有实例的所有始发流量。使用NAT网关，因为我们只想允许来自堡垒节点的SSH流量并阻止来自互联网的所有其他流量。出于简化/清晰的目的，有意地从上面的图中省略了每个实例的安全组信息，但是应该在云形成模板中进行研究。该图还包含10.6.0的访问控制列表（ACL）信息。<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html" target="_blank" rel="noopener">有状态的</a>。我们将在以下部分中探索Bastion节点，私有实例和NAT网关的配置细节：</p><p><strong>堡垒节点</strong></p><p>它存在于自己的VPC中，该VPC暴露于Internet网关并使用VPC对等连接与VPC2（我们的私有实例的VPC）进行通信。互联网网关已与VPC相关联，并且已将弹性IP（EIP）分配给堡垒节点以允许来自互联网的流量。</p><p>路由表清楚地表明，除了10.5.0.0/16和10.6.0.0/16网络之外，所有来自堡垒节点的出站流量都应通过互联网网关转发。发往10.6.0.0/16的流量应使用VPC对等连接作为网关，这样，SSH流量就可以到达我们的私有实例。</p><p>对于安全组，我们只允许来自/到公共互联网的所有SSH流量并阻止所有其他流量。以下是使用云形成实现这一目标的方法：</p><p><strong>私有集群中的实例</strong></p><p>我们决定将我们的假设私有集群放在10.6.0.0/24子网上。路由表描述了发往10.5.0.0/16网络的所有流量都应使用对等连接作为网关。特定于Internet的出站流量使用NAT实例作为网关。</p><p>对于安全组，我们仅允许来自10.5.0.0/24子网的SSH流量和来自Internet上的Internet（0.0.0.0/0）的HTTP / HTTPS流量，并拒绝所有其他协议。</p><p>要添加额外的安全层，我们使用ACL，仅允许SSH，HTTP和HTTPS流量，如上图所示，同时显示入口和出口。由于NAT网关请求此端口以便与私有实例通信，因此端口1024-65535已保持打开以进行<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html#VPC_ACLs_Ephemeral_Ports" target="_blank" rel="noopener">短暂</a>连接。下面使用此云形成模板显示：</p><p><strong>NAT网关</strong></p><p>NAT网关也已放置在自己的10.6.1.0/24子网中。路由表描述了互联网的所有出站流量应使用Internet网关正确分段网络，因为NAT不需要访问对等连接。</p><p>NAT网关的安全组仅允许来自Internet的HTTP和HTTPs流量。以下是云形成如何实现：</p><p>现在我们有了堡垒架构的完整设置。还剩下最后一件事就是<a href="https://brainsik.net/2011/ssh-agent-forwarding/" target="_blank" rel="noopener">SSH Agent Forwarding</a></p><p><strong>SSH代理转发</strong></p><p>为什么需要这个？我们可以简单地进入堡垒，然后跳转到我们的任何私有实例中。为什么这是真的，这是一个巨大的安全风险。有权访问堡垒主机的任何人都可以访问其他所有用户的私钥，并可以模拟该用户。因此，凭证不应存储在堡垒主机上，而应通过<em>SSH代理</em>转发从本地计算机转发到堡垒<em>。</em></p><p><code>-A</code>使用SSH命令添加一段时间应该将您的本地凭据转发到下一台机器上，但是，我们将通过<strong>〜/ .ssh / config</strong>文件进行此配置以简化我们的生活并避免尝试在每次ssh尝试时转发代理。</p><p>将以下行添加到ssh配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host bastion</span><br><span class="line">  HostName       [Bastion Public Ip address]</span><br><span class="line">  User           ec2-user #For example</span><br><span class="line">  IdentityFile   [Path to Identity file]</span><br><span class="line">  ForwardAgent    Yes</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果该文件不存在，您可以直接触摸该文件<code>touch ~/.ssh/config</code></p><p>现在，我们可以简单地说<code>ssh bastion</code>，我们可以进入我们的堡垒实例，我们可以从中跳转到所有其他实例。</p><p>为了进一步简化，我们可以将以下行添加到文件<code>~/.bashrc</code>或<code>~/.zshrc</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ssh-instance（）&#123; </span><br><span class="line">  BASTION_USER =＃你的堡垒用户名</span><br><span class="line">  BASTION_IP =＃你的堡垒IP </span><br><span class="line">  SSH_OPTIONS =“ProxyCommand ssh -q -A -W％h：％p $ BASTION_USER @ $ BASTION_IP” </span><br><span class="line">  ssh $ 1 @ $ 2 -o $ SSH_OPTIONS </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件，通过它来源<code>source ~/.bashrc</code>，现在你可以简单地说<code>ssh-instance ec2-user [my instance ip]</code>，瞧，你直接进入你的私人实例，而不必首先通过堡垒。</p><p><strong>其他提示</strong></p><p>建议对堡垒节点和私有实例使用不同的ssh密钥，并经常轮换这些密钥以减少攻击者获取访问权限的可能性。</p><p>此外，专用的SysAdmin或DevOps工程师还可以在每个堡垒节点中设置用户组，并创建分配给具有各种管理权限的这些不同用户组的用户。应将每个用户的公共ssh密钥复制到<code>~/.ssh/authorized_keys</code>文件中。</p><p><strong>结论</strong></p><p>本文探讨了如何在AWS上为我们的私有实例设置一个万无一失的堡垒节点，而不会在需要系统/软件更新时损害这些实例的Internet可访问性。</p><p>本文的云形成模板可以在这里找到：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">https</a>：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">//github.com/nwochaadim/BastionNode-with-CloudFormation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>玩转Jenkins Pipeline</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%8E%A9%E8%BD%ACJenkins-Pipeline/"/>
    <id>http://blog.ozairs.com/Jenkins/玩转Jenkins-Pipeline/</id>
    <published>2019-03-18T08:47:54.000Z</published>
    <updated>2019-03-18T08:51:11.320Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins Pipeline的总体介绍<br>1.Jenkins Pipeline 的核心概念</p><p>Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。</p><p>Pipeline是Jenkins2.X的最核心的特性，帮助Jenkins实现从CI到CD与DevOps的转变</p><p>Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。</p><p>持续交付管道（CD Pipeline）是将软件从版本控制阶段到交付给用户或客户的完整过程的自动化表现。软件的每一次更改（提交到源代码管理系统）都要经过一个复杂的过程才能被发布。</p><p>Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language（DSL）syntax可以达到Pipeline as Code（Jenkinsfile存储在项目的源代码库）的目的。</p><p>Stage：阶段，一个Pipeline可以划分成若干个Stage，每个Stage代表一组操作，例如：“Build”，“Test”，“Deploy”。</p><p>注意，Stage是一个逻辑分组的概念，可以跨多个Node</p><p>Node：节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行环境。</p><p>Step：步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenklins Plugin提供，例如：sh ‘make’</p><p>Pipeline五大特性</p><p>1、代码:Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑、审查和迭代其CD流程。<br>2、可持续性：Jenklins重启或者中断后都不会影响Pipeline Job。<br>3、停顿：Pipeline可以选择停止并等待任工输入或批准，然后再继续Pipeline运行。<br>4、多功能：Pipeline支持现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力<br>5、可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。</p><p>Pipeline和Freestyle的区别</p><p>Freestyle：<br>上游/下游Job调度，如<br>BuildJob —&gt; TestJob —&gt; DeployJob<br>在DSL Job里面调度多个子Job（利用Build Flow Plugin）</p><p>Pipeline：<br>单个Job中完成所有的任务编排<br>全局视图</p><p>Multibranch Pipeline根据你的代码中Jenlinsfile自动创建Job</p><p>Jenlins Pipeline的基础语法<br>Pipeline脚本是由Groovy语言实现（无需专门学习）</p><p>支持两种语法<br>Declarative 声明式（在Pipeline plugin 2.5中引入）<br>Scripted Pipeline 脚本式</p><p>如何创建最基本的PIpeline<br>直接在Jenkins Web UI 网页界面中输入脚本<br>通过创建一个jenkinsfile可以检入项目的源代码管理库</p><p>通常推荐在Jenkins中直接从源代码控制（SCM）中载入Jenklinsfile Pipeline</p><p>声明式Pipeline</p><p>声明式Pipeline的基本语法和表达式遵循与Groovy语法相同的规则，但有以下例外：</p><p>声明式pipeline必须包含在固定格式pipeline{}快内<br>每个声明语句必须独立一行，行尾无需使用分号<br>块（blocks{}）只能包含章节（Sections），指令（Directives），步骤（Steps）或赋值语句<br>属性引用语句被视为无参数方法调用。例：输入被视为 input()<br>块（blocks{}）<br>由大括号括起来的语句，如pipeline{},Section{},parameters{},script{}<br>章节（Sections）<br>通常包含一个或多个指令或步骤。如 agent 、post、stages、steps<br>指令（Directives）<br>environment、options、parameters、triggers（触发）、stage、tools、when<br>步骤（Steps）<br>Pipeline steps reference<br>执行脚本式pipeline：使用script{}</p><p>agent<br>必须存在，agent必须在pipeline块内的顶层定义，但stage内是否使用使可选的<br>参数：any/none/label/node/docker/dockerfile<br>常用选项 label/cuetomWorkspace/reuseNode</p><p>示例</p><p>agent { label ‘my-label’ }</p><p>agent {<br>    node {<br>        label ‘my-label’<br>        customWorkspace ‘/some/other/path’<br>    }<br>}</p><p>agent {<br>    docker {<br>        image ‘nginx:1.12.2’<br>        label ‘my-label’<br>        args ‘-v /tmp:/tmp’<br>    }<br>}</p><p>post 不是必须的，用于pipeline的最外层或者stage{}中</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps {<br>            echo ‘Hello world’<br>            }<br>        }<br>    }<br>    post {<br>        always {<br>            echo ‘say goodbay’<br>        }<br>    }<br>}</p><p>stages 必须，包括顺序执行的一个或多个stage命令，在pipeline内仅能使用一次，通常位于agent/options后面，例子如上</p><p>steps 必须，steps位于stage指令块内部，包括一个或多个step。仅有一个step的情况下可以忽略关键字step及其{},例子如上</p><p>environment 不是必须的，environment定义了一组全局的环境变量键值对，存在于pipeline{}或者stage指令内。执行特殊方法credentials()可以获取jenkins中预定义的凭证明文内容</p><p>environment {CC=’clang’}<br>environment {AN_ACCESS_KEY = credentials(‘my-prefined-secret-text’)}<br>steps {sh ‘printenv’}</p><p>options 不是必须的 预定义pipeline专有的配置信息，仅可定义一次</p><p>pipeline {<br>    agent any<br>    options{<br>    timeout(time:1,unit: ‘HOURS’)<br>    }<br>    …<br>}</p><p>parameters 不是必须的 定义参数化构建的参数可选参数 booleanParam,choice,file,text,password,run,string</p><p>paramenters {<br>    choice(name:’PerformMavenRelease’,choices:’False\nTrue’,description:’desc’)<br>    password(name:’CredsToUse’,description:’Apassword to build with’,defaultValue:’’)<br>}<br>environment {<br>    BUILD_USR_CHOICE=”${params.PerformMavenRelease}”<br>    BUILD_USR_CREDS=”${params.CredsToUse}”<br>}</p><p>triggers 不是必须的 定义pipeline被自动触发的方式选项 cron、pollSCM、upstream</p><p>triggers {cron(‘H 4/<em> 0 0 1-5’)}<br>triggers {pollSCM(‘H 4/</em> 0 0 1-5’)}<br>triggers {upstream(upstreamProjects:’job1,job2’,threshold:hudson.model.Result.SUCCESS)}</p><p>快速创建一个pipeline<br>新建 选择pipeline 填写Job 的名字 </p><p>填写相应的pipeline script</p><p>pipeline{<br>    agent any<br>    stages {<br>        stage(‘Build’) {<br>            steps{<br>                echo ‘This is a build step’<br>            }<br>        }<br>        stage(‘Test’) {<br>            steps{<br>                echo ‘This is a test step’<br>            }<br>        }<br>        stage(‘Deploy’) {<br>            steps{<br>                echo ‘This is a deploy step’<br>            }<br>        }<br>    }<br>}<br>1</p><p>保存之后，立即构建</p><p>常用的辅助工具</p><p>Snipper Generator（代码片段生成器，语法检查器）<br>Replay Pipeline（重放pipeline，可以修改script，修改后的不存入config.xml）<br>DSL Reference 语法参考手册<br>全局变量引用<br>Stage View<br>BlueOcean(可视化)<br>Pipeline神器：可视化编辑器<br>命令行Pipeline调试工具<br>变量的传递</p><p>自定义变量（局部）<br>def username = ‘Jenkins’<br>echo “Hello Mr.${username}”</p><p>#注意一定要用双引号，单引号识别为字符串</p><p>环境变量（局部）<br>withEnv([‘MYTOOL_HOME=/usr/local/mytool’]){<br>    sh ‘$MYTOOL_HOME/bin/start’<br>}<br>1<br>2<br>3<br>环境变量（全局）<br>environment {CC=’clang’}<br>echo “Compiler is ${env.CC}”</p><p>参数化构建（全局）<br>parameters {string(name:’Jenkins’,defaultValue:’Hello’,description:’How should I greet the world’)}<br>ehco “${params.Greeting} World!”</p><p>判断<br>when仅用于stage内部<br>when的内置条件为：</p><ul><li>when {branch ‘master’}</li><li>when {environment name:’DEPLOY_TO’,value:’production’}<br>#当有环境变量 name 为 DEPLOY_TO 值是 production 条件成立</li><li>when {expression {return params.DEBUG_BUILD}}<br>#表达式返回值为真时</li><li>when {not {branch ‘master’}}</li><li>when {allOf {branch ‘master’; environment name:’DEBUG_TO’,value:’production’}}<br>#allOf 所有条件都满足时</li><li>when {anyOf {branch ‘master’ ; branch ‘staging’}}<br>#anyOf有一个条件满足时即可</li></ul><p>判断和异常处理<br>流程控制if/else条件</p><p>node {<br>    stage(‘Example’){<br>        if(env.BRANCH_NAME == ‘master’){<br>            echo ‘I only execute on the master branch’<br>        }else {<br>            echo ‘Iexecute elsewhere’<br>        }<br>    }<br>}</p><p>异常处理try/catch/finally</p><p>node{<br>    stage(‘Example’){<br>        try{<br>            sh ‘exit 1’<br>        }<br>        catch (exc) {<br>            echo ‘something failed,I should sound the klaxons!’<br>            throw<br>        }<br>    }<br>}</p><p>for循环仅存在域脚本式pipeline中，但是可以通过在声明式pipeline中调用script step来执行</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps{<br>                echo ‘Hello world!’<br>                script {<br>                    def browsers = [‘chrome’,’firefox’]<br>                    for (int i = 0;i &lt; browers.size();++i){<br>                        echo “Testing the ${browsers[i]} browser”<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</p><p>并发需要放在stages中，stages可以嵌套使用<br>stage下的steps和parallel不能共存，只能二选一<br>使用了并发的stage不能再有agent/tools </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jenkins Pipeline的总体介绍&lt;br&gt;1.Jenkins Pipeline 的核心概念&lt;/p&gt;
&lt;p&gt;Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins+ant 构建非maven项目</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%BD%BF%E7%94%A8jenkins-ant-%E6%9E%84%E5%BB%BA%E9%9D%9Emaven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.ozairs.com/Jenkins/使用jenkins-ant-构建非maven项目/</id>
    <published>2019-03-18T05:06:47.000Z</published>
    <updated>2019-03-18T05:14:51.282Z</updated>
    
    <content type="html"><![CDATA[<p>使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下</p><h2 id="1-安装构建环境"><a href="#1-安装构建环境" class="headerlink" title="1. 安装构建环境"></a>1. 安装构建环境</h2><p>除普通必要的环境外，需要额外安装ANT</p><p>到官方主页<a href="http://ant.apache.org下载新版的ant，" target="_blank" rel="noopener">http://ant.apache.org下载新版的ant，</a></p><p>得到的是一个apache-ant-1.10.1-bin.zip的压缩包。将其解压到你的硬盘上</p><p>接下来配置环境变量即可，配置和java类似</p><p>ANT_HOME   :  D:\MyWorkApps\apache-ant-1.10.1</p><p>CLASSPATH  :  D:\MyWorkApps\apache-ant-1.10.1\lib</p><p>PATH:                D:\MyWorkApps\apache-ant-1.10.1\bin</p><p>注意：配置没有使用%ANT_HOME%bin</p><p> 原因:经测试部分系统path不识别%ANT_HOME%</p><p> 解决方法：换成解压目录路径，如上即可</p><p>测试一下是否安装成功</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/1.png" alt=""></p><p>build failed 即成功，只是没有build.xml而已</p><h2 id="2-jenkins安装ant插件并进行环境配置"><a href="#2-jenkins安装ant插件并进行环境配置" class="headerlink" title="2. jenkins安装ant插件并进行环境配置"></a>2. jenkins安装ant插件并进行环境配置</h2><p>进入系统设置，插件管理，安装ant插件</p><p>我这里已经安装好了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/2.png" alt=""></p><p>然后进入 系统管理 =》 <a href="http://localhost:8091/configureTools" target="_blank" rel="noopener"><strong>Global Tool Configuration</strong></a></p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/3.png" alt=""></p><p>配置<a href="https://www.baidu.com/s?wd=JDK&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">JDK</a>也是必须的，若果使用ANT构建就需配置ANT,使用MAVEN构建即要配置MAVEN</p><p>配置也很简单 如下</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/4.png" alt=""></p><p>Name 可以随意取 ,HOME即为安装目录</p><h2 id="3-进入jenkins构建项目"><a href="#3-进入jenkins构建项目" class="headerlink" title="3. 进入jenkins构建项目"></a>3. 进入jenkins构建项目</h2><p>点击新建</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/5.png" alt=""></p><p>如上填写选择，点击ok</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/6.png" alt=""></p><p>继续，到源码管理，选择svn,输入地址和账号密码</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/7.png" alt=""></p><p>继续</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.png" alt=""></p><p>可以看到这里实用最简单的配置，构建触发器，和构建环境都没有选，</p><p>构建里选择一下我们刚刚安装配置的ANT</p><p>点击保存即可</p><p>\4. build.xml文件配置</p><p>使用ANT进行构建，最主要的就是build.xml文件的编写</p><p>这里只需要修改property的几个属性即可</p><property name="catalina.home" value="D:\MyProject\tomcat-6.0.45"><p>由于我们在构建中指定了ANT，所以下面的这个可以去除掉</p><property name="ant.dir" value="D:\MyWorkApps\apache-ant-1.10.1"><p>project name 这个name即是打包之后的包名，也是我们进入工程的工程名称</p><p>如：<a href="http://localhost:8099/myweb/hello/world.do" target="_blank" rel="noopener">http://localhost:8099/myweb/hello/world.do</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"hellojk"</span> <span class="attr">default</span>=<span class="string">"deploy"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name"</span> <span class="attr">value</span>=<span class="string">"hellojk"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"catalina.home"</span> <span class="attr">value</span>=<span class="string">"D:\Program Files\Apache Software Foundation\Tomcat 8.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/dist"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webRoot.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/WebRoot"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/src"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/config"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lib.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/lib"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用eclipse jdt进行编译，而不使用JDK编译  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter" /&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="D:\MyWorkApps\Java\jdk1.8.0_51" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 初始化classpath --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加tomcat类路径 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/lib"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ant lib包  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;fileset dir="$&#123;ant.dir&#125;"&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;include name="**/*.jar" /&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/fileset&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- get the source compile classpath in a printable form --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pathconvert</span> <span class="attr">pathsep</span>=<span class="string">"$&#123;line.separator&#125;|   |-- "</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">property</span>=<span class="string">"echo.path.compile"</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">refid</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pathconvert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- show classpath jars --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"print_classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|-- compile classpath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |-- $&#123;echo.path.compile&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 删除之前的目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"清理旧文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;.war"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span> <span class="attr">depends</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"创建初始化目录结构"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编译java --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span> <span class="attr">description</span>=<span class="string">"编译java文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src.dir&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">includeantruntime</span>=<span class="string">"false"</span> <span class="attr">nowarn</span>=<span class="string">"on"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">source</span>=<span class="string">"1.8"</span> <span class="attr">target</span>=<span class="string">"1.8"</span> <span class="attr">deprecation</span>=<span class="string">"true"</span> <span class="attr">debug</span>=<span class="string">"true"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">encoding</span>=<span class="string">"UTF-8"</span> <span class="attr">classpathref</span>=<span class="string">"project.classpath"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-Xlint:unchecked"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;classpath refid="project.classpath" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;build.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;src.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;config.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将class文件打成 jar包 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;target name="pack" depends="compile"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;jar jarfile="$&#123;build.dir&#125;/$&#123;webapp.name&#125;.jar"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;fileset dir="$&#123;build.dir&#125;/classes"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &lt;include name="**/*.class"/&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;/fileset&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;/jar&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;/target&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打成war包, 名称默认为 项目名 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"war"</span> <span class="attr">depends</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"将工程打成war包"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">webxml</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/web.xml"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"***.*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">war</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- copy war包 tomcat的deploy目录 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"deploy"</span> <span class="attr">depends</span>=<span class="string">"war"</span> <span class="attr">description</span>=<span class="string">"部署项目"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">todir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如构建出现这样的错误（之前使用别的build.xml构建时错误）</p><p>大多是工程里缺少文件夹，手动创建即可</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.1.png" alt=""></p><p>走了很多弯路，不过最后成功了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/9.png" alt=""></p></blockquote></property></property>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下&lt;/p&gt;
&lt;h2 id=&quot;1-安装构建环境&quot;&gt;&lt;a href=&quot;#1-安装构建环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装构建环境&quot;&gt;&lt;/a&gt;1. 安装构建环境
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>从Docker到Jenkins再到Ansible的部署经验</title>
    <link href="http://blog.ozairs.com/Ansible/%E4%BB%8EDocker%E5%88%B0Jenkins%E5%86%8D%E5%88%B0Ansible%E7%9A%84%E9%83%A8%E7%BD%B2%E7%BB%8F%E9%AA%8C/"/>
    <id>http://blog.ozairs.com/Ansible/从Docker到Jenkins再到Ansible的部署经验/</id>
    <published>2019-03-17T10:53:04.000Z</published>
    <updated>2019-03-17T10:56:53.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Docker-到Jenkins-到Ansible的部署经验"><a href="#从Docker-到Jenkins-到Ansible的部署经验" class="headerlink" title="从Docker 到Jenkins 到Ansible的部署经验"></a>从Docker 到Jenkins 到Ansible的部署经验</h1><p>工作中，除了开发功能，还负责系统的部署工作。我从频繁的部署工作中，逐渐找到了一些偷懒的方法。从传统的Java -jar命令启动服务，到通过Docker 容器构建部署服务，再后来通过自动化部署工具Jenkins来完成部署，最后再结合Ansible完成远程部署。一步步的进步极大的减少部署工作，提高了工作效率（增加了许多划水时间）。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>Docker给我的印象很深，没有什么环境是docker pull 解决不了的，</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker ps           ， docker ps 默认显示运行中的容器，-a 显示所有，-l显示近期创建的容器</span><br><span class="line"></span><br><span class="line">docker start xxx    ， 启动xxx容器</span><br><span class="line"></span><br><span class="line">docker restart xxx  ， 重启xxx容器</span><br><span class="line"></span><br><span class="line">docker run xxx      ， 创建并运行xxx容器</span><br><span class="line"></span><br><span class="line">docker build -t xxx .   ，使用 Dockerfile 创建镜像</span><br><span class="line"></span><br><span class="line">docker stop xxx     ， 关闭容器</span><br><span class="line"></span><br><span class="line">docker rm xxx       ， 删除容器</span><br><span class="line"></span><br><span class="line">docker images       ， 查看所有镜像</span><br><span class="line"></span><br><span class="line">docker rmi xxx      ， 删除xxx镜像</span><br><span class="line"></span><br><span class="line">docker exec -it xxx sh          ， 进入xxx容器中，用quit退出</span><br><span class="line"></span><br><span class="line">docker logs -f xxx --tail 500   ， 查看xxx容器的日志，显示最后500行，常用命令</span><br><span class="line"></span><br><span class="line">docker inspect xxxx             ， 查看容器配置信息</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml up -d ， 按照app.yml文件配置以debug形式启动</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml down  ， 按照app.yml文件配置形式关闭</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：在gradle项目加入docker插件，即在gradle.build 文件中加入以下代码。需要注意的有插件的版本，项目打包后的名称，Dockerfile文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath(&quot;se.transmode.gradle:gradle-docker:1.2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;docker&apos;</span><br><span class="line"></span><br><span class="line">task buildDocker(type: Docker, dependsOn: build) &#123;</span><br><span class="line">    push = false</span><br><span class="line">    applicationName = &quot;项目名&quot;</span><br><span class="line">    dockerfile = file(&apos;src/main/docker/Dockerfile文件目录&apos;)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：创建Dockerfile文件，文件目录要和第一步中设置的保持一致。需要配置jdk镜像和基本的启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM frolvlad/alpine-oraclejdk8:slim</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD 项目jar名称.jar app.jar</span><br><span class="line">RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line">ENV JAVA_OPTS=&quot;&quot;</span><br><span class="line">ENV PORT=&quot;6666&quot;</span><br><span class="line">ENV DB_CONNECTION=&quot;jdbc:mysql://ip:port/database&quot;</span><br><span class="line">ENV DB_USER=&quot;user&quot;</span><br><span class="line">ENV DB_PASSWORD=&quot;password&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar --spring.datasource.url=$DB_CONNECTION --spring.datasource.usernam=$DB_USER --spring.datasource.password=$DB_PASSWORD --port=$PORT&quot;]</span><br></pre></td></tr></table></figure><p>第三步：将jar拷贝到服务器上，然后执行编译，运行的docker命令</p><p>一）、通过gradle的bootJar，将项目打包。同时需要把引入的第三方jar也要一起打入到项目jar中。</p><p>二）、Windows系统中可以通过Xftp将jar和Dockerfile文件拷贝同一个目录下。Linux系统可以通过scp命令上传文件。</p><p>三）、执行docker ps，查看当前运行的容器，执行docker stop和docker rm 关闭和删除之前旧版本的容器</p><p>四）、找到jar的目录，并在当前目录下，执行 docker build -t 镜像名称 . 的命令编译项目，注意后面的点不要漏了。</p><p>五）、编译成功后执行 docker run –name 容器名 -v /tmp:/tmp -p 对外开发的端口:项目启动的端口 镜像名:latest 。启动容器</p><p>六）、执行docker ps，查看容器启动是否正常启动。同时执行docker logs -f 容器名 –tail 500，查看容器启动日志，检查是否有异常</p><p>七）、最后浏览器访问一下，已确保部署成功。</p><p>全称大概需要几分钟的时间，虽然不算麻烦。可次数多了，就很麻烦了。有没有什么好的工具帮助我们完成这一系列操作呢？答案是肯定的。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>The leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.</p></blockquote><p>Jenkins 的logo是一个管家的形象，很贴切。对它的理解比较肤浅。他通过管理Git上的项目，来确保每次打包的jar都是最新的。同时在构建成功后执行我们输入的shell命令，来达到自动化部署的工作。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：创建一个负责编译的Jenkins项目，</p><p>在Jenkins控制台页面，点击页面左上角的“新建”按钮。再输入项目名后，可以选择创建一个空项目，也可以在页面最下面选择copy from 其他项目。不管如何创建，我们需要Jenkins管理项目的源码，构建和构建后的操作。</p><p>第二步：创建一个负责运行的Jenkins项目</p><p>以同样的方式创建项目，在构建触发器上，选择第一步创建的项目，构建的Shell命令是先删除之前的容器，然后在重新运行容器。若之前的容器不存在，则会构建失败。所以第一次构建的时候把第一行命令删掉。解决方案傻乎乎的，只是因为没有花时间去处理。</p><p>第三步：选择编译项目，点击立即构建，当第一个项目构成成功后，会自动触发运行项目。等待两个项目都成功后，就可以访问浏览器，检查功能。</p><p>有了Jenkins，一切变得轻松很多。但他也有一个较大的弊端，就是使用前必须要先安装。特别是在客户的服务器上，也许别人就只跑这一个服务，你给别人整了一个Jenkins，似乎有点大材小用了。有没有好的解决方法？答案是肯定的。</p><h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Ansible is an IT automation tool. It can configure systems, deploy software, and orchestrate more advanced IT tasks such as continuous deployments or zero downtime rolling updates.</p></blockquote><p>从接触到使用Ansible大概有一天的时间，对它的理解也是比较肤浅。我单纯的认为，他可以帮助我们在服务器之间传输文件，同时还可以执行一些shell命令。抱着这样的想法，我们可以通过Jenkins完成自动化编译，再通过Ansible传输资源文件到部署的环境中，同时执行启动Shell命令。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：修改Jenkins运行项目的构建Shell，将之前的docker run改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook ansible命令文件路径/app.yaml</span><br></pre></td></tr></table></figure><p>第二步：创建Ansible脚本文件app.yaml，目录和第一步中设置的保存一致，模版大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- hosts: &apos;需要部署的远程服务ip&apos;</span><br><span class="line">  tasks:</span><br><span class="line">   - name: &quot;关闭旧版本的容器&quot;</span><br><span class="line">     shell: docker stop xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除旧版本的容器&quot;</span><br><span class="line">     shell: docker rm xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除之前的旧文件&quot;</span><br><span class="line">     shell: rm -rf /旧文件路径/*</span><br><span class="line">   - name: &quot;传输Dockerfile文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/文件目录/Dockerfile</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;传输Jar文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/jar目录/xxx.jar</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;构建docker 镜像&quot;</span><br><span class="line">     shell: chdir=/jar所在目录 nohup docker build -t 镜像名 .</span><br><span class="line">   - name: &quot;启动容器&quot;</span><br><span class="line">     shell: nohup docker run --name 容器名 -v /挂载路径/:/挂载路径/ -p 对外端口:服务端口 -d 镜像名:latest</span><br></pre></td></tr></table></figure><p>第三步：在Jenkins上构建编译项目。</p><h2 id="前后端项目的部署"><a href="#前后端项目的部署" class="headerlink" title="前后端项目的部署"></a>前后端项目的部署</h2><p>到这里，三种部署的流程就完成了。如果你熟悉Docker的方式构建，再用Jenkins和Ansible的时候，就会简单很多。我在实际开发中，项目是前后端分离的。公司做了两个方案，</p><p>第一种：前后端分开部署，即Jenkins上有四个项目。前端和后端各两个项目。这样的好处就是前后端互不影响。不会因为对方的错误而从新编译。缺点也是有的，很难保证对方部署的环境是最新的。</p><p>第二种：把前后端放在一个项目中，一次构建完成两个项目的打包部署。缺点是构建慢，优点就是保证两端的代码都是最新的，适合发布到预发布环境和正式环境。</p><p>那么，针对前后端一起部署的需求，Jenkins和Ansible同样也需要简单的修改。其思路就是Jenkins负责编译项目，将资源文件压缩，再通过Ansible上传到其他服务器上。执行解压，构建，启动的命令。</p><p>看起来视乎很简单，但有一个坑希望你们跨过去。前端打包需要npm或者其他工具，但是你的服务器上没有安装。此时请务必通过Jenkins控制台，或者用Jenkins帐号登录服务器安装这些工具。笔者就是通过root帐号登录服务器安装的npm，通过Jenkins编译时提示没有权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从Docker-到Jenkins-到Ansible的部署经验&quot;&gt;&lt;a href=&quot;#从Docker-到Jenkins-到Ansible的部署经验&quot; class=&quot;headerlink&quot; title=&quot;从Docker 到Jenkins 到Ansible的部署经验&quot;&gt;
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ansible-playbook之roles实现</title>
    <link href="http://blog.ozairs.com/Ansible/ansible-playbook%E4%B9%8Broles%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.ozairs.com/Ansible/ansible-playbook之roles实现/</id>
    <published>2019-03-17T10:19:21.000Z</published>
    <updated>2019-03-17T10:26:15.653Z</updated>
    
    <content type="html"><![CDATA[<p>一、目标<br>两台主机：192.168.50.138（安装ansible）、192.168.50.139</p><p>[webservers]<br>192.168.50.138 httpd_point=80<br>192.168.50.139 httpd_point=8080<br>实现在两台主机上同时安装apache，提供配置文件，并启动。在139主机上提供mysql服务。</p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>二、roles之apache<br>1、创建目录</li></ul><p>mkdir -pv /ansible_playbooks/roles/{apache,mysql}/{tasks,files,templates,meta,handlers,vars}<br>2、复制一份httpd配置文件作为template</p></li></ul><p>cp /etc/httpd/conf/httpd.conf /ansible_playbooks/roles/apache/templates/<br>编辑此配置文件做变量引用</p><p>Listen <br>3、编写tasks任务</p><p>[root@node1 apache]# vim tasks/main.yml </p><ul><li>name: install httpd<br>yum: name=httpd state=latest</li><li>name: install config<br>template: src=httpd.conf dest=/etc/httpd/conf/httpd.conf<br>notify:<ul><li>restart apache</li></ul></li><li>name: start apache<br>service: name=httpd state=started<br>4、编写handlers</li></ul><p>[root@node1 apache]# vim handlers/main.yml </p><ul><li>name: restart apache<br>service: name=httpd state=restarted<br>三、roles之mysql<br>1、复制一份mysql配置文件到files文件中</li></ul><p>cp /etc/my.cnf /ansible_playbooks/roles/mysql/files/<br>2、编写tasks任务<br>[root@node1 mysql]# vim /ansible_playbooks/roles/mysql/tasks/main.yml </p><ul><li>name: install mysql<br>yum: name=mariadb state=latest</li><li>name: install config-mysql<br>copy: src=my.cnf dest=/etc/my.cnf</li><li>name: start mariadb<br>service: name=mariadb state=started<br>四、编写剧本</li></ul><p>[root@node1 mysql]# vim /ansible_playbooks/site.yml </p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>五、执行剧本</li></ul></li></ul><p>[root@node1 handlers]# ansible-playbook /ansible_playbooks/site.yml </p><p>PLAY [all] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.138]<br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>PLAY [192.168.50.139] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install config-mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>TASK [mysql : start mariadb] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>PLAY RECAP <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>192.168.50.138             : ok=4    changed=0    unreachable=0    failed=0<br>192.168.50.139             : ok=11   changed=2    unreachable=0    failed=0   </p><h2 id="成功！！！"><a href="#成功！！！" class="headerlink" title="成功！！！"></a>成功！！！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、目标&lt;br&gt;两台主机：192.168.50.138（安装ansible）、192.168.50.139&lt;/p&gt;
&lt;p&gt;[webservers]&lt;br&gt;192.168.50.138 httpd_point=80&lt;br&gt;192.168.50.139 httpd_point=
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible实战汇总</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%AE%9E%E6%88%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible实战汇总/</id>
    <published>2019-03-17T10:05:37.000Z</published>
    <updated>2019-03-17T11:02:01.798Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 实战目录</p><p>一、Ansible与Terraform相结合</p><p>1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；</p><p><a href="https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d" target="_blank" rel="noopener">https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d</a></p><p>二、Ansible操作Docker容器</p><p>1、使用 Ansible 高效交付 Docker 容器</p><p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html</a></p><p>2、基于 docker 的 jenkins-ansible-gitlab 实现自动化部署</p><p><a href="https://www.jianshu.com/p/191f0c81c6bb" target="_blank" rel="noopener">https://www.jianshu.com/p/191f0c81c6bb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible 实战目录&lt;/p&gt;
&lt;p&gt;一、Ansible与Terraform相结合&lt;/p&gt;
&lt;p&gt;1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/setu
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们抛弃ECS而选择了Kubernetes</title>
    <link href="http://blog.ozairs.com/Kubernetes/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%8A%9B%E5%BC%83ECS%E8%80%8C%E9%80%89%E6%8B%A9%E4%BA%86Kubernetes/"/>
    <id>http://blog.ozairs.com/Kubernetes/为什么我们抛弃ECS而选择了Kubernetes/</id>
    <published>2019-03-17T05:18:22.000Z</published>
    <updated>2019-03-17T05:20:40.489Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。</p><p>3个月前，我们在</p><p>nanit.com</p><p>希望选择一个合适的Docker编排框架，ECS成为了我们的首选，毕竟，我们对AWS的服务较为熟悉，并且我们的基础设施都是建立在AWS的。经过一段时间的测试，我们发现ECS并不成熟，缺少一些我们需要的关键功能，因此我们开始尝试其他的框架：Kubernetes。令人意外的是，Kubernetes非常成熟，几乎支持我们需要的所有功能。对于我们来说，Kubernetes在ECS的主场完胜了ECS。接下来，就让我们一起来看看Kubernetes赢在哪些方面。</p><p>注意：ECS一直在更新，我们会尽可能的跟进这些内容，但部分内容可能被忽略了，希望读者不要介意。</p><h3 id="构建集群（Cluster-Setup）"><a href="#构建集群（Cluster-Setup）" class="headerlink" title="构建集群（Cluster Setup）"></a>构建集群（Cluster Setup）</h3><p>ECS:为了启动一个ECS集群，用户需要设置一个Auto Scaling Group。用户可以编辑user-data来将EC2实例添加到指定的ECS集群上。当ASG被设置，实例启动之后，用户可以在ECS控制台看到这部分内容。现在，用户可以开始进行task-definition，方式类似于Docker-compose。</p><p>Kubernetes：想要在AWS上启动一个Kubernetes，用户需要先启动一个具有一定权限的EC2实例（通过IAM）。这将会创建多个AWS constructs来支持你的集群：VPC、ASG、一些安全组（Security Groups）和一个Kubernetes主实例。集群需要几分钟来启动，之后用户就能够在上面运行自己的容器。</p><p>比较结果：使用这两种框架来启动一个集群都非常的简单和友好。</p><h3 id="启动基础服务（Basic-Service-Setup）"><a href="#启动基础服务（Basic-Service-Setup）" class="headerlink" title="启动基础服务（Basic Service Setup）"></a>启动基础服务（Basic Service Setup）</h3><p>我们的任务是启动一个Nginx 镜像，并且让其他人能够访问这个Web服务。</p><p>ECS: 首先，我们需要创建一个ELB(Elastic Load Balancer)，它负责80端口的转发。然后，我们需要创建一个task-definition，它负责在80端口上启动一个Docker镜像。最后，需要创建一个Service，它会显示出有多少实例会同时运行。我们需要将它绑定到我们之前创建的ELB上。</p><p>Kubernetes：首先需要创建一个Replication Controller，它会显示出我们希望运行的Docker镜像和有多少镜像会同时运行。之后，我们需要创建一个Service object，这会启动一个ELB并且将ELB的流量转发到对应的容器上。</p><p>比较结果：Kubernetes的方式更舒服一些，更简洁。用户并不需要手工启动或者管理ELB。Kubernetes会完全负责管理：当用户创建了一个service，一个ELB会自动创建；当用户删除了一个service，它会自动从AWS上删除。</p><h3 id="服务发现（Service-Discovery）"><a href="#服务发现（Service-Discovery）" class="headerlink" title="服务发现（Service Discovery）"></a>服务发现（Service Discovery）</h3><p>当你使用了微服务架构和Docker，一个好的服务发现解决方案是至关重要的。Docker容器总是在不同虚拟机中迁移，用户必须有一个可靠的方法来发现在集群内和集群外的服务。</p><p>ECS: ECS并没有提供任何服务发现的解决方案。我能想到的最好方法就是构建一个内部加载平衡器（internal load balancer），并且将每一个service附加到一个平衡器上。平衡器的host name不会被改变，然后你就能够利用这个host name来作为服务的端点。其他的方法还有集成一个外部的程序，比如</p><p>Consul</p><p>。</p><p>Kubernetes：我认为这是Kubernetes的亮点之一。Kubernetes内置了一个完全的解决方案。它是一个插件，因此用户可以选择是否使用，但我强烈建议使用。它能够和namespace一起很好的工作。简单来说，当你创建了一个Kubernetes服务，比如说叫做redis，你就能够在集群的任何地方引用redis这个名字，即便是跨虚拟机。这就像是让docker网络跨越了特定的虚拟机，连通了整个集群。Namespaces允许你将多个服务归纳到一个具有逻辑的组中。现在假设我们有两个命名空间，分别是production和staging，他们都包含有一个redis的服务。一个在production命名空间下的容器可以通过redis来引用在production命名空间下的redis服务，同样的，在stagin命名空间下的容器也能通过redis来引用到位于stagine命名空间下的redis服务。这种自动化识别使得用户不需要花费时间去配置信息就能够构建一个隔离的环境，并且你可以随意在所有的命名空间中使用redis来引用对应的服务，接下来kunernetes会为你自动解析它们。</p><p>比较结果：毫无疑问，Kubernetes小胜一局。使用Kubernetes，用户完全不用关心服务发现的事情，全部交给Kubernetes来做就好了：）</p><h3 id="部署（Deployments）"><a href="#部署（Deployments）" class="headerlink" title="部署（Deployments）"></a>部署（Deployments）</h3><p>当我们升级一个服务的时候，即便还在部署，我们也想要确保它百分之百能用。我们的测试包括一个简单的NginX服务和一些简单的静态网页。我们启动了一个并发为30个请求的负载测试，并且在负载测试期间，我们会对该服务进行升级。</p><p>在部署期间，我们发现ECS丢失了比Kubernetes更多的请求。其中，Kubernetes丢失了0-2个请求，而ECS丢失了9-14个。</p><p>比较结果：说实话，我对ECS非常的失望。同样，我也对Kubernetes表示失望，但是它至少比ECS好多了。值得注意的是，Kubernetes 1.1.1版本应该会对轮询升级机制（rollong update mechanism）进行改善，还有一些其他的系统系能提升，这些改进都会使得这些数字变得更好看。</p><h3 id="持久卷（Persistent-Volumes）"><a href="#持久卷（Persistent-Volumes）" class="headerlink" title="持久卷（Persistent Volumes）"></a>持久卷（Persistent Volumes）</h3><p>我们经常需要挂载一些持久性的文件系统到一个指定的容器上，MySQL就是一个典型的例子。</p><p>ECS：ECS支持Docker原生的解决方案——用户可以启动一个数据容器，然后使用volumes-from命令来挂载它到其他容器上。就拿MySQL来看，你首先需要设置一个mysql-data容器，这个容器仅仅拥有一个数据卷。然后设置另外一个mysql-db容器，这个容器使用volumes-from命令来挂载之前创建的数据卷容器。这个方法看起来不错，但是它是host-sepicific的，这意味着你的mysql-db容器不能够在主机之间移动。你必须指定mysql-db容器在哪一个主机上运行，以此来防止容器被重新分配到其他主机上，最终失去了持久性。</p><p>Kubernetes：除了从一个指定的主机上挂载数据卷，Kubernetes还提供了一个选项：挂载一个EBS（Elastic Book Store）数据卷。这意味着一个容器的持久性存储可以在多个不同的虚拟机之间保留。你再也不需要强制你的MySQL容器必须运行在哪一个具体的虚拟机上。</p><p>注意：EBS同一时间只能被一个虚拟机挂载，这意味着如果有一个服务，它有两个运行在不同虚拟机的容器，他们将不能够挂载和共享这个EBS。</p><p>比较结果：即便Kubernetes的EBS挂载有一定的限制，但它依旧非常的独特和有用。</p><h3 id="健康检查（Health-Checks）"><a href="#健康检查（Health-Checks）" class="headerlink" title="健康检查（Health-Checks）"></a>健康检查（Health-Checks）</h3><p>确保拥有足够的服务容量是高可用性和冗余性的核心思想。健康检查就是用来确保服务不仅仅是运行的，并且它们还是健康和可操作的。</p><p>ECS：ECS使用ELB(Elastic Load Balancer)健康检查，这种方式有三个主要的缺点：</p><p>\1. ELB健康检查仅仅限于HTTP/TCP检查</p><p>\2. 如果你想要对一个不开放TCP端口的服务进行检查，这是不行的。仅仅是为了能够进行健康检查，你就必须运行一个HTTP/TCP服务器。</p><p>\3. 即便你拥有一个支持HTTP/TCP的服务，你还需要创建一个ELB，并将它绑定到这个服务上，这样才能进行健康检查。</p><p>Kubernetes：除了基于HTTP/TCP的健康检查，Kubernetes还提供了一种叫做Exec的方式。Exec可以让用户在容器中运行命令。如果命令结束，并且返回0则表示这个服务是健康的，否则这个服务很可能是不健康的，它会被其他的实例所替换。</p><p>比较结果：Kubernetes的方式更灵活，更简单配置。用户并不需要去启动一个冗余的HTTP/TCP服务器仅仅为了进行健康检查，并且即便服务没有绑定ELB，你也可以对它们进行健康检查。</p><h3 id="端口管理（Port-Management）"><a href="#端口管理（Port-Management）" class="headerlink" title="端口管理（Port Management）"></a>端口管理（Port Management）</h3><p>从我们的上篇文章中可以看出，端口管理在Docker中是比较困难的。我们想通过一个简单的例子来说明Kubernetes如何比ECS更优雅的解决了这个问题。我们拥有一台虚拟机和两个监听80端口的网站。我们不能够在同一个虚拟机上开2个80端口，因此我们需要寻找一个方法来解决这个问题。</p><p>ECS:用户必须手工确定两个服务没有使用同一个端口。我们只有一台虚拟机，因此只能运行一个开放80端口的容器。当我们想要开启第二个开放80端口的容器时，这是不行的，因为我们没有多余的虚拟机了。也就是说，能够开放多少个x端口的服务取决于拥有多少个虚拟机。在小型集群中，这是非常容易满足的条件，但是当你的服务数量变得越来越多时，这将成为一个头疼的问题，因为当你想要扩充容器时，你必须确认你还有足够的端口。</p><p>Kubernetes：Kubernetes非常优雅的解决了这个问题。它为每一个虚拟机上的容器都分配了一个随机的端口。然后它创建了2个ELB，一个将80端口转发到容器A的随机端口上，另外一个转发到容器B的随机端口上。一个内部的路由机制会负责将数据包转发到对应容器端口。</p><p>比较结果：Kubernetes使用虚拟端口的方式代替绑定原始端口的方法，很好的解决了这个头疼的问题。</p><h3 id="记录（Logging）"><a href="#记录（Logging）" class="headerlink" title="记录（Logging）"></a>记录（Logging）</h3><p>没有什么系统不需要记录功能。</p><p>我从没有想过记录会成为一个大问题，但能够为你解决问题令我非常的高兴，即便这个问题非常简单。我们之前提到Kubernetes提供了一个服务发现的扩展功能，在这里，我想说的是记录的扩展功能。它含有两个不同的记录和度量收集（metric collection）的机制。第一种是著名的</p><p>ELK</p><p>方法，ELK会收集容器的所有记录，并且能够让用户通过Kibana接口来查询和可视化这些记录。第二种是InfluxDB，它使用</p><p>Grafana</p><p>作为可视化工具来查询系统信息，如CPU和内存使用情况。</p><p>比较结果：Kubernetes的扩展功能更胜一筹。当然，你会说我并不需要这些扩展，系统也能很好工作，但是，它们效果如此之好，并且能适用于99%的用例，为什么不使用呢？ECS并没有提供内置的记录功能，用户想要集成一个进去并不是很困难，但是这些并不能和Kubernetes提供的功能相提并论。</p><h3 id="未知的云平台（Cloud-Agnostic）"><a href="#未知的云平台（Cloud-Agnostic）" class="headerlink" title="未知的云平台（Cloud Agnostic）"></a>未知的云平台（Cloud Agnostic）</h3><p>其实，Kubernetes和ECS之间并不存在竞争：）</p><p>ECS会专注于AWS平台，如果你已经在ECS上构建了你的基础架构，当你想要转移到其他云平台时，你将会遇到很多困难。</p><p>Kubernetes适用于多个云平台。你可以在AWS，Google Cloud，微软的ZURE，Rackspace等等上运行你的集群，并且运行效果或多或少都是相同的。在这里，或多或少指的是有一些功能只有部分云供应商提供。你必须确认你选择的新供应商能够支持Kubernetes中使用的功能，至少确保迁移是可能的。</p><h3 id="开源软件（OSS）"><a href="#开源软件（OSS）" class="headerlink" title="开源软件（OSS）"></a>开源软件（OSS）</h3><p>Kubernetes是开源的项目，而ECS不是。这意味着，所有的一切，从源代码到未来的发展路线都是对你开放的。发现了漏洞？你可以创建一个issue或者直接提交一个pull 请求来修复它。新的功能会被添加到每一个新版本，其中的贡献人数和pull请求是惊人的。</p><p>ECS有着不同的性质，我不能够在网上找到关于它未来发展路线的规划。你不能够获得一个漏洞和issue的列表，你必须深入到论坛上去寻找想要的答案。并且你寻找的答案往往都是缺乏实际的，并不能够提供任何帮助（请看</p><p>这里</p><p>）。也许这仅仅是因为我个人的糟糕经历，但是不管怎么说，这都是令人烦躁和失望的。</p><p>比较结果：就我个人而言，我更喜欢开源软件。我喜欢Kubernetes的开放性，每个人都能够参与讨论和贡献代码。我相信社区的力量会给我们带来一个更好的产品。</p><h3 id="多可用区域（Multi-AZ）"><a href="#多可用区域（Multi-AZ）" class="headerlink" title="多可用区域（Multi-AZ）"></a>多可用区域（Multi-AZ）</h3><p>当谈论到Kubernetes时，有一件事情困扰着我：它不支持AWS上的多可用区域集群（multiple availability-zones cluters）。这意味着所有EC2实例都集中在一个AZ上，这使得你的集群很可能会遭受到中断问题。</p><p>ECS有对Multi-AZ有很好的支持。</p><p>比较结果：在Kubernetes的issue上，已经有一些工作正在进行。我十分确定下个版本会很好的得到改善。因此ECS在这一点上的胜利并不会长久。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很多公司都开始使用Docker作为他们的主要基础设置，传递机制（delivery mechanism）和编排框架（orchestration frameworks）成为了系统的核心，并且影响着我们开发，迁移，运行，升级的方式。当我想要比较ECS和Kubernetes时，我找不到类似的文章。所以我认为把我们的经验公布出来非常的重要，这样其他人能够站在我们的肩膀上看的更远。</p><p>对于nanit.com来说，Kubernetes毫无疑问获得了胜利。如果你有任何的异议，请告诉我理由，我非常想要知道这些内容：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。&lt;/p&gt;
&lt;p&gt;3个月前，我们在&lt;/p&gt;
&lt;p&gt;nanit.com&lt;/p&gt;
&lt;p&gt;希望选择一个合适的Docker
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与Docker的自动化CI/CD实战</title>
    <link href="http://blog.ozairs.com/DevOps/Jenkins%E4%B8%8EDocker%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96CI-CD%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Jenkins与Docker的自动化CI-CD实战/</id>
    <published>2019-03-17T02:48:26.000Z</published>
    <updated>2019-03-17T03:02:41.598Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。</p><h2 id="一、发布流程设计"><a href="#一、发布流程设计" class="headerlink" title="一、发布流程设计"></a>一、发布流程设计</h2><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.1.png" alt=""></p><p>工作流程：**</p><ol><li>开发人员提交代码到Git版本仓库；</li><li>Jenkins人工/定时触发项目构建；</li><li>Jenkins拉取代码、代码编码、打包镜像、推送到镜像仓库；</li><li>Jenkins在Docker主机创建容器并发布。</li></ol><p>环境规划如下：</p><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>Jenkins/Docker</td><td>192.168.0.217</td></tr><tr><td>Docker</td><td>192.168.0.218</td></tr><tr><td>Git/Registry</td><td>192.168.0.219</td></tr></tbody></table><p>操作系统：CentOS7.4</p><h2 id="二、部署Git仓库"><a href="#二、部署Git仓库" class="headerlink" title="二、部署Git仓库"></a>二、部署Git仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install git -y</span><br></pre></td></tr></table></figure><ol><li><p>创建Git用户并设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># useradd git</span><br><span class="line"># passwd git</span><br></pre></td></tr></table></figure></li><li><p>创建仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># su - git</span><br><span class="line"># mkdir solo.git</span><br><span class="line"># cd solo.git</span><br><span class="line"># git --bare init</span><br></pre></td></tr></table></figure></li><li><p>访问创建的这个仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone git@192.168.0.212:/home/git/solo.git</span><br></pre></td></tr></table></figure><h2 id="三、准备Jenkins环境"><a href="#三、准备Jenkins环境" class="headerlink" title="三、准备Jenkins环境"></a>三、准备Jenkins环境</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于代码编译、部署、测试等工作。 Jenkins也是一个跨平台的，大多数主流的平台都支持，而且安装很简单，我们这里以部署war包方式安装它。<br>官网下载地址：<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a> </p><p>在安装前需要具备Java环境，安装方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tar zxf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8 </span><br><span class="line"># vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8 </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar </span><br><span class="line">export JAVA_HOME PATH CLASSPATH</span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>在192.168.0.217主机安装Jenkins，下载Tomcat二进制包将war包到webapps下即可：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war </span><br><span class="line"># wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># tar zxf apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># mv apache-tomcat-8.5.32 /usr/local/tomcat-jenkins </span><br><span class="line"># rm /usr/local/tomcat-jenkins/webapps/* -rf </span><br><span class="line"># unzip jenkins.war -d /usr/local/tomcat-jenkins/webapps/ROOT </span><br><span class="line"># cd /usr/local/tomcat-jenkins/bin/ </span><br><span class="line"># ./startup.sh </span><br><span class="line"># tail ../logs/catalina.out -f </span><br><span class="line">... </span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated. </span><br><span class="line">Please use the following password to proceed to installation: </span><br><span class="line"></span><br><span class="line">a5f1f7c167fd4b8ab62f9497d32d97db </span><br><span class="line"></span><br><span class="line">This may also be found at: /root/.jenkins/secrets/initialAdminPassword ...</span><br></pre></td></tr></table></figure><p>部署成功，访问Jenkins：<a href="http://ip:8080/" target="_blank" rel="noopener">http://ip:8080</a></p><p>第一步：输入上面日志输出的密码：a5f1f7c167fd4b8ab62f9497d32d97db，或者从本机/root/.jenkins/secrets/initialAdminPassword文件获取，点击继续<br>第二步：点击“选择插件来安装”<br>第三步：保持默认，点击继续<br>第四步：创建管理员用户，保存并完成<br>第五步：设置Jenkins访问地址，保持默认，点击保存完成</p><p>安装完成，开始使用Jenkins：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/2.png" alt=""></p><h2 id="四、部署私有镜像仓库"><a href="#四、部署私有镜像仓库" class="headerlink" title="四、部署私有镜像仓库"></a>四、部署私有镜像仓库</h2><p>Docker Hub作为Docker默认官方公共镜像；如果想自己搭建私有镜像仓库，官方也提供registry镜像，使得搭建私有仓库非常简单。<br>在192.168.0.219部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>接下来测试registry可用性。<br>由于Docker CLI默认以HTTPS访问，而部署的registry并未提供HTTPS，因此，需要在pull镜像的Docker主机（192.168.0.217，192.168.0.218）添加HTTP可信任：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> # vi /etc/docker/daemon.json </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.0.219:5000&quot;]&#125;</span><br><span class="line"># service docker restart</span><br></pre></td></tr></table></figure><h2 id="五、安装Docker"><a href="#五、安装Docker" class="headerlink" title="五、安装Docker"></a>五、安装Docker</h2><p>在192.168.0.217/192.168.0.218/192.168.0.219主机安装Docker，如下：</p><ol><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>添加Docker软件包源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install docker-ce -y</span><br></pre></td></tr></table></figure></li><li><p>配置加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://bc437cce.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>启动并开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="六、构建Tomcat基础镜像"><a href="#六、构建Tomcat基础镜像" class="headerlink" title="六、构建Tomcat基础镜像"></a>六、构建Tomcat基础镜像</h2><p>JAVA程序必须有JDK环境才可以运行，为了减少镜像大小及提高性能，这里直接把JDK放到宿主机上，容器以挂载形式使用。<br>在192.168.0.217/192.168.0.218安装JDK：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8</span><br></pre></td></tr></table></figure><p>Tomcat基础镜像Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.aliangedu.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.32</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk</span><br><span class="line"></span><br><span class="line">RUN yum install wget -y</span><br><span class="line"></span><br><span class="line">RUN wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v$&#123;VERSION&#125;/bin/apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    mv apache-tomcat-$&#123;VERSION&#125; /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    rm -rf apache-tomcat-$&#123;VERSION&#125;.tar.gz /usr/local/tomcat/webapps/* &amp;&amp; \</span><br><span class="line">    mkdir /usr/local/tomcat/webapps/ROOT</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure><p>构建镜像并上传到registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t 192.168.0.219:5000/tomcat-85 -f Dockerfile .</span><br><span class="line"># docker push 192.168.0.219:5000/tomcat-85</span><br></pre></td></tr></table></figure><h2 id="七、Jenkins配置全局工具配置"><a href="#七、Jenkins配置全局工具配置" class="headerlink" title="七、Jenkins配置全局工具配置"></a>七、Jenkins配置全局工具配置</h2><p>主页面 -&gt; 系统管理 -&gt; 全局工具配置</p><p>指定JDK、Maven路径，Git保持默认：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/3.png" alt=""><br>如果Jenkins主机没有git命令，需要安装Git：<br><code># yum install git -y</code></p><h2 id="八、Jenkins安装必要插件"><a href="#八、Jenkins安装必要插件" class="headerlink" title="八、Jenkins安装必要插件"></a>八、Jenkins安装必要插件</h2><p><strong>1. Jenkins安装必要插件</strong><br>主页面 -&gt; 系统管理 -&gt;管理插件：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/4.png" alt=""><br>安装SSH与Git Parameter插件。</p><p>插件说明：</p><ul><li>SSH：用于SSH远程Docker主机执行Shell命令</li><li>Git Parameter：动态获取Git仓库Branch、Tag</li></ul><p><strong>2. 配置SSH插件</strong><br><strong>第一步：先创建一个用于连接Docker主机的凭据。</strong><br>主页面 -&gt; 凭据 -&gt; 系统 -&gt; 右击全局凭据 -&gt; 添加凭据：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/5.png" alt="">输入连接Docker主机的用户名和密码：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/6.png" alt=""><br><strong>第二步：添加SSH远程主机</strong><br>主页面 -&gt; 系统管理 -&gt; 系统设置 -&gt; SSH remote hosts：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/7.png" alt=""></p><h2 id="九、上传JAVA项目代码到Git仓库"><a href="#九、上传JAVA项目代码到Git仓库" class="headerlink" title="九、上传JAVA项目代码到Git仓库"></a>九、上传JAVA项目代码到Git仓库</h2><p>从Github拉取开源JAVA博客系统solo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/b3log/solo</span><br><span class="line"># cd solo</span><br><span class="line">移除旧的推送地址，添加新的：</span><br><span class="line"># git remote remove origin </span><br><span class="line"># git remote add origin git@192.168.0.219:/home/git/solo.git</span><br><span class="line">提交代码到Git仓库并创建tag：</span><br><span class="line"># touch src/main/webapp/a.html</span><br><span class="line"># git add .</span><br><span class="line"># git commit -m “a”</span><br><span class="line">创建标签：</span><br><span class="line"># git tag 1.0.0</span><br><span class="line">推送到Git服务器：</span><br><span class="line"># git push origin 1.0.0</span><br></pre></td></tr></table></figure><h2 id="十、Jenkins创建项目并发布测试"><a href="#十、Jenkins创建项目并发布测试" class="headerlink" title="十、Jenkins创建项目并发布测试"></a>十、Jenkins创建项目并发布测试</h2><p>主页面 -&gt; 新建任务 -&gt; 输入任务名称，构建一个Maven项目：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/8.png" alt=""><br>注意：如果没有显示“构建一个Maven项目”选项，需要在管理插件里安装“Maven Integration plugin”插件。<br>配置Git参数化构建：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/9.png" alt=""><br>动态获取Git仓库tag，与用户交互选择Tag发布：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/10.png" alt=""><br>指定项目Git仓库地址：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/11.png" alt=""><br>修改*/master为$Tag，Tag是上面动态获取的变量名，表示根据用户选择打代码版本。</p><p>设置maven构建命令选项：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/12.png" alt=""></p><p>利用pom.xml文件构建项目。<br>在Jenkins本机镜像构建与推送到镜像仓库，并SSH远程连接到Docker主机使用推送的镜像创建容器：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/13.png" alt=""><br>上图中，在Jenkins主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 构建镜像</span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM 192.168.0.219:5000/tomcat-85:latest</span><br><span class="line">RUN rm -rf /usr/local/tomcat/webapps/ROOT</span><br><span class="line">COPY target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">EOF</span><br><span class="line">docker build -t $REPOSITORY .</span><br><span class="line"># 上传镜像</span><br><span class="line">docker push $REPOSITORY</span><br></pre></td></tr></table></figure><p>上图中，SSH远程Docker主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 部署</span><br><span class="line">docker rm -f blog-solo |true</span><br><span class="line">docker image rm $REPOSITORY |true</span><br><span class="line">docker container run -d --name blog-solo -v /usr/local/jdk1.8:/usr/local/jdk -p 88:8080 $REPOSITORY</span><br></pre></td></tr></table></figure><p>注：容器名称blog-solo，暴露宿主机端口88，即使用宿主机IP:88访问blog-solo项目。<br>blog-solo项目已配置完成，开始构建：</p><p>选择tag，开始构建：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/14.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/15.png" alt=""></p><p>点击左下角构建历史里，右击第一个查看控制台输出：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/16.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/17.png" alt=""></p><p>浏览器访问solo项目：<a href="http://192.168.0.218:88/" target="_blank" rel="noopener">http://192.168.0.218:88</a><br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/18.png" alt=""><br>如果输出上述页面说明是正常的，页面没有加载成功样式，需要修改下项目里访问地址。</p><p>至此，自动化CI环境搭建完成，你可以模拟提交代码并打tag测试自动化发布流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。&lt;/p&gt;
&lt;h2 id=&quot;一、发布流程设计&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>把一个Node.js web应用程序给Docker化</title>
    <link href="http://blog.ozairs.com/DevOps/%E6%8A%8A%E4%B8%80%E4%B8%AANode-js-web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%99Docker%E5%8C%96/"/>
    <id>http://blog.ozairs.com/DevOps/把一个Node-js-web应用程序给Docker化/</id>
    <published>2019-03-17T02:26:13.000Z</published>
    <updated>2019-03-17T03:02:41.595Z</updated>
    
    <content type="html"><![CDATA[<p>本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 <em>非</em> 产品发布人员。此教程同样假定你有一个可以正常工作的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装</a>，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。</p><p>在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。</p><p>Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。</p><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"First Last &lt;first.last@example.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><p>然后，创建一个 <code>server.js</code> 文件，使用 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a> 框架定义一个 Web 应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello world\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。</p><h2 id="创建一个名称为-Dockerfile-的文件"><a href="#创建一个名称为-Dockerfile-的文件" class="headerlink" title="创建一个名称为 Dockerfile 的文件"></a>创建一个名称为 <code>Dockerfile</code> 的文件</h2><p>创建一个空文件，命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>用你最喜欢的文本编辑器打开这个 <code>Dockerfile</code>。</p><p>我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），<code>Node</code> 的版本号为 <code>8</code>。你可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker 站点</a> 获取相关镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure><p>此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 <code>npm</code> 安装你的应用程序的所有依赖。请注意，如果你的 <code>npm</code> 的版本是 4 或者更早的版本，<code>package-lock.json</code> 文件将不会自动生成。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install app dependencies</span></span><br><span class="line"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span><br><span class="line"><span class="comment"># where available (npm@5+)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br></pre></td></tr></table></figure><p>请注意，我们只是拷贝了 <code>package.json</code> 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">见此</a>。 进一步说，对于生产环境而言，注释中提及的 <code>npm ci</code> 命令协助提供了一个更快、可靠、可再生的构建环境。欲知详情，可以参考<a href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" target="_blank" rel="noopener">此处</a>。</p><p>在 Docker 镜像中使用 <code>COPY</code> 命令绑定你的应用程序：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure><p>你的应用程序绑定的端口为 <code>8080</code>，所以你可以使用 <code>EXPOSE</code> 命令使它与 <code>docker</code> 的镜像做映射：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>最后但同样重要的事是，使用定义运行时的 <code>CMD</code> 定义命令来运行应用程序。这里我们使用最简单的 <code>npm start</code> 命令，它将运行 <code>node server.js</code> 启动你的服务器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>你的 <code>Dockerfile</code> 现在看上去是这个样子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>在 <code>Dockerfile</code> 的同一个文件夹中创建一个 <code>.dockerignore</code> 文件，带有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。</p><h2 id="构建你的镜像"><a href="#构建你的镜像" class="headerlink" title="构建你的镜像"></a>构建你的镜像</h2><p>进入到 <code>Dockerfile</code> 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 <code>-t</code> 让你标记你的镜像，以至于让你以后很容易地用 <code>docker images</code> 找到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;your username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><p>Docker 现在将给出你的镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">REPOSITORY                      TAG        ID              CREATED</span><br><span class="line">node                            8          1934b0b038d1    5 days ago</span><br><span class="line">&lt;your username&gt;/node-web-app    latest     d64d3505b0d2    1 minute ago</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用 <code>-d</code> 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 <code>-p</code> 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app</span><br></pre></td></tr></table></figure><p>把你应用程序的输出打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get container ID</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print app output</span></span><br><span class="line">$ docker logs &lt;container id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">Running on http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果你需要进入容器中，请运行 <code>exec</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter the container</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container id&gt; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为测试你的应用程序，给出与 Docker 映射过的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">ID            IMAGE                                COMMAND    ...   PORTS</span><br><span class="line">ecce33b30ebf  &lt;your username&gt;/node-web-app:latest  npm start  ...   49160-&gt;8080</span><br></pre></td></tr></table></figure><p>在上面的例子中，在容器中 Docker 把端口号 <code>8080</code> 映射到你机器上的 <code>49160</code> 。</p><p>现在你可以使用 <code>curl</code>（如果需要的话请通过 <code>sudo apt-get install curl</code> 安装）调用你的程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:49160</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 12</span><br><span class="line">ETag: W/<span class="string">"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"</span></span><br><span class="line">Date: Mon, 13 Nov 2017 20:53:59 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。</p><p>你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容：</p><ul><li><a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener">官方 Node.js 的 Docker 镜像</a></li><li><a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">Node.js 基于 Docker 使用的最佳经验</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方 Docker 文档</a></li><li><a href="https://stackoverflow.com/questions/tagged/docker" target="_blank" rel="noopener">在 StackOverFlow 上有关 Docker 标记内容</a></li><li><a href="https://reddit.com/r/docker" target="_blank" rel="noopener">Docker Subreddit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 &lt;em&gt;非&lt;/em&gt; 产品发布人员。此教程同样假定你有一个可以正常工作的 &lt;a href=&quot;https://docs.docker.com/engine/in
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="NodeJs" scheme="http://blog.ozairs.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation CLI命令</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation-CLI%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation-CLI命令/</id>
    <published>2019-03-16T11:47:59.000Z</published>
    <updated>2019-03-16T11:52:06.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Creating-a-Stack"><a href="#Creating-a-Stack" class="headerlink" title="Creating a Stack"></a>Creating a Stack</h2><p>You must provide the stack name, the location of a valid template, and any input parameters. If you specify a local template file, AWS CloudFormation uploads it to an Amazon S3 bucket in your AWS account.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation create-stack --stack-name myteststack --template-body file:///home/testuser/mytemplate.json --parameters ParameterKey=Parm1,ParameterValue=test1 ParameterKey=Parm2,ParameterValue=test2</span><br></pre></td></tr></table></figure><h2 id="Listing-Your-Stacks"><a href="#Listing-Your-Stacks" class="headerlink" title="Listing Your Stacks"></a>Listing Your Stacks</h2><p>Note The aws cloudformation list-stacks command returns information on deleted stacks for 90 days after they have been deleted.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE</span><br></pre></td></tr></table></figure><h2 id="Describing-Your-Stacks"><a href="#Describing-Your-Stacks" class="headerlink" title="Describing Your Stacks"></a>Describing Your Stacks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stacks --stack-name myteststack</span><br></pre></td></tr></table></figure><p>By default, aws cloudformation describe-stacks returns parameter values. To prevent sensitive parameter values such as passwords from being returned, include a NoEcho property set to TRUE in your AWS CloudFormation template.</p><h2 id="Viewing-Stack-Event-History"><a href="#Viewing-Stack-Event-History" class="headerlink" title="Viewing Stack Event History"></a>Viewing Stack Event History</h2><p>You can track the status of the resources AWS CloudFormation is creating and deleting with the aws cloudformation describe-stack-events command. The amount of time to create or delete a stack depends on the complexity of your stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stack-events --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Listing-Stack-Resources"><a href="#Listing-Stack-Resources" class="headerlink" title="Listing Stack Resources"></a>Listing Stack Resources</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stack-resources --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Retrieving-a-Template"><a href="#Retrieving-a-Template" class="headerlink" title="Retrieving a Template"></a>Retrieving a Template</h2><p>AWS CloudFormation stores the template you use to create your stack as part of the stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation get-template --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Validating-a-Template"><a href="#Validating-a-Template" class="headerlink" title="Validating a Template"></a>Validating a Template</h2><p>You can validate templates locally by using the –template-body parameter, or remotely with the –template-url parameter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation validate-template --template-url https://s3.amazonaws.com/cloudformation-templates-us-east-1/S3_Bucket.template</span><br><span class="line">$ aws cloudformation validate-template --template-body file:///home/local/test/sampletemplate.json</span><br></pre></td></tr></table></figure><h2 id="Deleting-a-Stack"><a href="#Deleting-a-Stack" class="headerlink" title="Deleting a Stack"></a>Deleting a Stack</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation delete-stack --stack-name myteststack</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Creating-a-Stack&quot;&gt;&lt;a href=&quot;#Creating-a-Stack&quot; class=&quot;headerlink&quot; title=&quot;Creating a Stack&quot;&gt;&lt;/a&gt;Creating a Stack&lt;/h2&gt;&lt;p&gt;You must provi
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>Ansible常用模块</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible常用模块/</id>
    <published>2019-03-16T11:25:04.000Z</published>
    <updated>2019-03-16T11:26:18.285Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（<a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。</a></p><p>1，ping模块。测试主机是否是通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m ping</span></span><br><span class="line">Server5 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br><span class="line">Server6 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，远程命令模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webserver -m <span class="built_in">command</span> -a <span class="string">"free -m"</span>  <span class="comment">#远程命令。</span></span><br><span class="line">ansible webserver -m script -a <span class="string">"/home/test.sh"</span> <span class="comment">#远程主机执行主控服务器ansible上的脚本</span></span><br><span class="line">ansible webserver -m shell -a <span class="string">"/home/test.sh"</span>   <span class="comment">#执行远程主机上的脚本命令</span></span><br></pre></td></tr></table></figure><p>3，setup模块。主要用于获取主机信息，在playbooks里经常会用到的一个参数，gather_facts就与该模块相关。setup模块下经常使用的一个参数是filter参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_*_mb'</span>   //查看主机内存信息</span><br><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_eth[0-2]'</span>   //查看地接口为eth0-2的网卡信息</span><br><span class="line">ansible all -m setup --tree /tmp/facts   //将所有主机的信息输入到/tmp/facts目录下，每台主机的信息输入到主机名文件中（/etc/ansible/hosts里的主机名）</span><br></pre></td></tr></table></figure><p>4，stat模块。获取远程文件状态信息,包括atime、ctime、mtime、MD5、uid、gid等信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.5 -m stat -a "path=/etc/sysctl.conf </span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.5 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": false, </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">stat</span><span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>atime<span class="string">": 1504513902.6297896, </span></span><br><span class="line"><span class="string">        "</span>checksum<span class="string">": "</span>a27c7ce2e6002c37f3cb537ad997c6da7fd76480<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>ctime<span class="string">": 1480926522.4591811, </span></span><br><span class="line"><span class="string">        "</span>dev<span class="string">": 64768, </span></span><br><span class="line"><span class="string">        "</span>executable<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>exists<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>gr_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>inode<span class="string">": 393634, </span></span><br><span class="line"><span class="string">        "</span>isblk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>ischr<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isdir<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isfifo<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isgid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>islnk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isreg<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>issock<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isuid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>md5<span class="string">": "</span>c97839af771c8447b9fc23090b4e8d0f<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mtime<span class="string">": 1361531931.0, </span></span><br><span class="line"><span class="string">        "</span>nlink<span class="string">": 1, </span></span><br><span class="line"><span class="string">        "</span>path<span class="string">": "</span>/etc/sysctl.conf<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>pw_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>readable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rgrp<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>roth<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>size<span class="string">": 1150, </span></span><br><span class="line"><span class="string">        "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>wgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>woth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>writeable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>wusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>xgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xoth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xusr<span class="string">": false</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>5，file模块。file模块主要用于远程主机上的文件操作，file模块包含如下选项： </p><p>force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no </p><ul><li>group：定义文件/目录的属组 </li><li>mode：定义文件/目录的权限</li><li>owner：定义文件/目录的属主</li><li>path：必选项，定义文件/目录的路径</li><li>recurse：递归的设置文件的属性，只对目录有效</li><li>src：要被链接的源文件的路径，只应用于state=link的情况</li><li>dest：被链接到的路径，只应用于state=link的情况 </li><li>state：    </li><li>directory：如果目录不存在，创建目录</li><li>file：即使文件不存在，也不会被创建</li><li>link：创建软链接</li><li>hard：创建硬链接</li><li>touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</li><li>absent：删除目录、文件或者取消链接文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m file -a "src=/etc/fstab dest=/</span></span><br><span class="line">tmp/fstab state=link<span class="string">"                         ########在远程主机180.6上创建远程软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 10, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/etc/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>link<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">touch<span class="string">"                                 ############在远程主机180.6上创建test文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 5, </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">absent<span class="string">"                                #############在远程主机删除文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/fstab state</span><br><span class="line">=absent<span class="string">"                                            #############在远程主机删除fstab软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>6，copy模块。实现复制文件到远程主机，copy模块包含如下选项：</p><ul><li>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no </li><li>content：用于替代”src”,可以直接设定指定文件的值 </li><li>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录 </li><li>directory_mode：递归的设定目录的权限，默认为系统默认权限</li><li>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</li><li>others：所有的file模块里的选项都可以在这里使用</li><li>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用”/“来结尾，则只复制目录里的内容，如果没有使用”/“来结尾，则包含目录在内的整个内容全部复制，类似于rsync。 </li></ul><p>以下的例子试下拷贝/etc/ansible/script.sh文件到主机组web1所有的主机/tmp下并更新文件属主和权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m copy -a "src=/etc/ansible/script.sh des</span></span><br><span class="line">t=/tmp/ owner=appuser group=appuser mode=0755<span class="string">"      ###复制本地脚本到远程主机server6下并定义用户和组以及权限755</span></span><br><span class="line"><span class="string">Server6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum<span class="string">": "</span>18ca258e92141948010f2e0896cf655cdb945a1d<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/script.sh<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 500, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>d5e15b2da056fdd7b7ba30100035de2e<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0755<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 30, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504517543.07-102988847745614/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 500</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>7,service模块。用于远程主机的服务管理。该模块包含如下选项： </p><ul><li>arguments：给命令行提供一些选项 </li><li>enabled：是否开机启动 yes|no</li><li>name：必选项，服务名称 </li><li>pattern：定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行</li><li>runlevel：运行级别</li><li>sleep：如果执行了restarted，在则stop和start之间沉睡几秒钟</li><li>state：对当前服务执行启动，停止、重启、重新加载等操作（started,stopped,restarted,reloaded）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####重启远程主机180.6的网卡服务</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m service -a "name=network state</span></span><br><span class="line">=restarted args=eth0<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>name<span class="string">": "</span>network<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>started<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>8，cron模块。用于远程主机crontab配置，管理计划任务包含如下选项： </p><ul><li>backup：对远程主机上的原任务计划内容修改之前做备份 </li><li>cron_file：如果指定该选项，则用该文件替换远程主机上的cron.d目录下的用户的任务计划 </li><li>day：日（1-31，<em>，</em>/2,……） </li><li>hour：小时（0-23，<em>，</em>/2，……）  </li><li>minute：分钟（0-59，<em>，</em>/2，……） </li><li>month：月（1-12，<em>，</em>/2，……） </li><li>weekday：周（0-7，*，……）</li><li>job：要执行的任务，依赖于state=present </li><li>name：该任务的描述 </li><li>special_time：指定什么时候执行，参数：reboot,yearly,annually,monthly,weekly,daily,hourly </li><li>state：确认该任务计划是创建还是删除 </li><li>user：以哪个用户的身份执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6  -m cron -a 'name="a job for rebo</span></span><br><span class="line">ot<span class="string">" special_time=reboot job="</span>/some/job.sh<span class="string">"'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>envs<span class="string">": [], </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">jobs</span><span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>a job <span class="keyword">for</span> reboot<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">##########客户端</span></span><br><span class="line"><span class="string">-bash-4.1# crontab -l</span></span><br><span class="line"><span class="string">#Ansible: a job for reboot</span></span><br><span class="line"><span class="string">@reboot /some/job.sh</span></span><br></pre></td></tr></table></figure><p>9，yum模块。Linux平台软件包管理操作 常见的有yum apt 管理方式，其选项有： </p><ul><li>config_file：yum的配置文件 </li><li>disable_gpg_check：关闭gpg_check </li><li>disablerepo：不启用某个源 </li><li>enablerepo：启用某个源</li><li>name：要进行操作的软件包的名字，也可以传递一个url或者一个本地的rpm包的路径 </li><li>state：状态（present，absent，latest）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m yum -a "name=curl state=latest</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>rc<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>results<span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>已加载插件：fastestmirror\n设置更新进程\nLoading mirror speeds from cached hostfile\n解决依赖关系\n--&gt; 执行事务检查\n---&gt; Package curl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package curl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 处理依赖关系 libcurl = 7.19.7-53.el6_9，它被软件包 curl-7.19.7-53.el6_9.x86_64 需要\n--&gt; 执行事务检查\n---&gt; Package libcurl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package libcurl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 完成依赖关系计算\n\n依赖关系解决\n\n================================================================================\n 软件包          架构           版本                      仓库             大小\n================================================================================\n正在升级:\n curl            x86_64         7.19.7-53.el6_9           updates         197 k\n为依赖而更新:\n libcurl         x86_64         7.19.7-53.el6_9           updates         169 k\n\n事务概要\n================================================================================\nUpgrade       2 Package(s)\n\n总下载量：367 k\n下载软件包：\n--------------------------------------------------------------------------------\n总计                                            3.1 MB/s | 367 kB     00:00     \n运行 rpm_check_debug \n执行事务测试\n事务测试成功\n执行事务\n\r  正在升级   : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  正在升级   : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  清理       : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  清理       : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\r  Verifying  : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  Verifying  : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  Verifying  : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  Verifying  : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\n更新完毕:\n  curl.x86_64 0:7.19.7-53.el6_9                                                 \n\n作为依赖被升级:\n  libcurl.x86_64 0:7.19.7-53.el6_9                                              \n\n完毕！\n<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之前</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之后</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-53.el6_9.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-53.el6_9.x86_64</span></span><br></pre></td></tr></table></figure><p>10.user模块。实现远程主机系统用户管理。</p><ul><li>home：指定用户的家目录，需要与createhome配合使用</li><li>groups：指定用户的属组</li><li>uid：指定用的uid</li><li>password：指定用户的密码</li><li>name：指定用户名</li><li>createhome：是否创建家目录 yes|no</li><li>system：是否为系统用户</li><li>remove：当state=absent时，remove=yes则表示连同家目录一起删除，等价于userdel -r</li><li>state：是创建还是删除</li><li>shell：指定用户的shell环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m user -a 'name=www1 comment=lqb</span></span><br><span class="line"> uid=1001 group=root <span class="string">'               ###新建www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "comment": "lqb", </span></span><br><span class="line"><span class="string">    "createhome": true, </span></span><br><span class="line"><span class="string">    "group": 0, </span></span><br><span class="line"><span class="string">    "home": "/home/www1", </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "shell": "/bin/bash", </span></span><br><span class="line"><span class="string">    "state": "present", </span></span><br><span class="line"><span class="string">    "system": false, </span></span><br><span class="line"><span class="string">    "uid": 1001</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m user -a '</span>name=www1 state=absen</span><br><span class="line">t remove=yes<span class="string">'                     ########删除www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "force": false, </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "remove": true, </span></span><br><span class="line"><span class="string">    "state": "absent"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>11.rsynchronize模块。使用rsync同步文件，其参数如下：</p><ul><li>archive: 归档，相当于同时开启recursive(递归)、links、perms、times、owner、group、-D选项都为yes ，默认该项为开启</li><li>checksum: 跳过检测sum值，默认关闭</li><li>compress:是否开启压缩</li><li>copy_links：复制链接文件，默认为no ，注意后面还有一个links参数</li><li>delete: 删除不存在的文件，默认no</li><li>dest：目录路径</li><li>dest_port：默认目录主机上的端口 ，默认是22，走的ssh协议</li><li>dirs：传速目录不进行递归，默认为no，即进行目录递归</li><li>rsync_opts：rsync参数部分</li><li>set_remote_user：主要用于/etc/ansible/hosts中定义或默认使用的用户与rsync使用的用户不同的情况</li><li>mode: push或pull 模块，push模的话，一般用于从本机向远程主机上传文件，pull 模式用于从远程主机上取文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############使用rsynchronize模块首先远程客户端要先按照rsync包才可以使用</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -a "yum install rsync -y"</span></span><br><span class="line">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">设置安装进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">解决依赖关系</span><br><span class="line">--&gt; 执行事务检查</span><br><span class="line">---&gt; Package rsync.x86_64 0:3.0.6-12.el6 will be 安装</span><br><span class="line">--&gt; 完成依赖关系计算</span><br><span class="line">依赖关系解决</span><br><span class="line">================================================================================</span><br><span class="line"> 软件包          架构             版本                     仓库            大小</span><br><span class="line">================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> rsync           x86_64           3.0.6-12.el6             base           335 k</span><br><span class="line">事务概要</span><br><span class="line">================================================================================</span><br><span class="line">Install       1 Package(s)</span><br><span class="line">总下载量：335 k</span><br><span class="line">Installed size: 682 k</span><br><span class="line">下载软件包：</span><br><span class="line">运行 rpm_check_debug </span><br><span class="line">执行事务测试</span><br><span class="line">事务测试成功</span><br><span class="line">执行事务</span><br><span class="line">  正在安装   : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">  Verifying  : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">已安装:</span><br><span class="line">  rsync.x86_64 0:3.0.6-12.el6                                                   </span><br><span class="line">完毕！</span><br><span class="line"></span><br><span class="line"><span class="comment">############远程客户端安装好rsync包后就可以在ansible服务端使用rsync进行同步了</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m synchronize -a 'src=/etc/ansib</span></span><br><span class="line">le/conf/hosts dest=/tmp/ <span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "cmd": "/usr/bin/rsync --delay-updates -F --compress --archive --rsh '</span>ssh -i /root/.ssh/id_rsa_web -S none -o StrictHostKeyChecking=no -o Port=22<span class="string">' --out-format='</span>&lt;&lt;CHANGED&gt;&gt;%i %n%L<span class="string">' \"/etc/ansible/conf/hosts\" \"root@192.168.180.6:/tmp/\"", </span></span><br><span class="line"><span class="string">    "msg": "&lt;f+++++++++ hosts\n", </span></span><br><span class="line"><span class="string">    "rc": 0, </span></span><br><span class="line"><span class="string">    "stdout_lines": [</span></span><br><span class="line"><span class="string">        "&lt;f+++++++++ hosts"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>12.mount模块。主要配置挂载点的。主要的参数如下：</p><ul><li>dump</li><li>fstype：必选项，挂载文件的类型 </li><li>name：必选项，挂载点 </li><li>opts：传递给mount命令的参数</li><li>src：必选项，要挂载的文件 </li><li>state：必选项 </li><li>present：只处理fstab中的配置 </li><li>absent：删除挂载点 </li><li>mounted：自动创建挂载点并挂载之 </li><li>umounted：卸载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###############把本地的磁盘挂载到远程主机180.6上</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m mount -a 'name=/tmp/app src=/d</span></span><br><span class="line">ev/sda2 fstype=ext4 state=mounted opts=rw<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "dump": "0", </span></span><br><span class="line"><span class="string">    "fstab": "/etc/fstab", </span></span><br><span class="line"><span class="string">    "fstype": "ext4", </span></span><br><span class="line"><span class="string">    "name": "/tmp/app", </span></span><br><span class="line"><span class="string">    "opts": "rw", </span></span><br><span class="line"><span class="string">    "passno": "0", </span></span><br><span class="line"><span class="string">    "src": "/dev/sda2"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#############下面是查看远程主机是否挂载成功</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>cat /etc/fstab<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># /etc/fstab</span></span><br><span class="line"><span class="string"># Created by anaconda on Wed Jan 18 14:50:09 2017</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Accessible filesystems, by reference, are maintained under '</span>/dev/disk<span class="string">'</span></span><br><span class="line"><span class="string"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">UUID=942820c4-9134-41da-9271-78ad0f8a33b2 /                       ext4    defaults        1 1</span></span><br><span class="line"><span class="string">UUID=e5d84663-09d2-429f-9f90-43a37b1a84a7 /opt                    ext4    defaults        1 2</span></span><br><span class="line"><span class="string">UUID=e9098124-206a-4116-a580-91d1d46fe8a9 swap                    swap    defaults        0 0</span></span><br><span class="line"><span class="string">tmpfs                   /dev/shm                tmpfs   defaults        0 0</span></span><br><span class="line"><span class="string">devpts                  /dev/pts                devpts  gid=5,mode=620  0 0</span></span><br><span class="line"><span class="string">sysfs                   /sys                    sysfs   defaults        0 0</span></span><br><span class="line"><span class="string">proc                    /proc                   proc    defaults        0 0</span></span><br><span class="line"><span class="string">/dev/sda2 /tmp/app ext4 rw 0 0</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>df -h<span class="string">'         </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">Filesystem      Size  Used Avail Use% Mounted on</span></span><br><span class="line"><span class="string">/dev/sda1        87G   12G   71G  14% /</span></span><br><span class="line"><span class="string">tmpfs           935M     0  935M   0% /dev/shm</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /opt</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /tmp/app</span></span><br></pre></td></tr></table></figure><p>13.get_url模块。该模块主要用于从http，ftp ,https等服务器上下载文件类似于wget。主要选项如下：</p><ul><li>sha256sum：下载完成后进行sha256 check；</li><li>timeout：下载超时时间，默认10s</li><li>url：下载的URL</li><li>url_password、url_username：主要用于需要用户名密码进行验证的情况</li><li>use_proxy：是事使用代理，代理需事先在环境变更中定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################从网站下载页面到/tmp/下</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m get_url -a "url=http://www.guo</span></span><br><span class="line">jinbao.com dest=/tmp/guojinbao mode=0440 force=yes<span class="string">"    </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum_dest<span class="string">": null, </span></span><br><span class="line"><span class="string">    "</span>checksum_src<span class="string">": "</span>75fa271ea83d05f2817027cf4009f9e9fda7ef88<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/guojinbao<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>e9ea1af241cf68289f3286b99af24baa<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0440<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span>OK (unknown bytes)<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 38033, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/tmp/tmp47gp_m<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>url<span class="string">": "</span>http://www.guojinbao.com<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########远程查看下载目录下有没有刚才下载的文件</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -lh /tmp/'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 104K</span></span><br><span class="line"><span class="string">drwx------  2 root    root    4.0K 9月   5 16:01 ansible_zwKwyh</span></span><br><span class="line"><span class="string">drwxr-xr-x. 7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x. 3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------. 1 root    root       0 1月  18 2017 yum.log</span></span><br></pre></td></tr></table></figure><p>14.sysctl包管理模块。用于远程主机sysctl的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible-doc -s sysctl        ###########查看sysctl的使用说明</span></span><br><span class="line">- name: Manage entries <span class="keyword">in</span> sysctl.conf.</span><br><span class="line">  action: sysctl</span><br><span class="line">      ignoreerrors           <span class="comment"># Use this option to ignore errors about unknown</span></span><br><span class="line">                               keys.</span><br><span class="line">      name=                  <span class="comment"># The dot-separated path (aka `key') specifying the                               sysctl variable.</span></span><br><span class="line">      reload                 <span class="comment"># If `yes', performs a `/sbin/sysctl -p' if the</span></span><br><span class="line">                               `sysctl_file<span class="string">' is</span></span><br><span class="line"><span class="string">                               updated. If `no'</span>,</span><br><span class="line">                               does not reload</span><br><span class="line">                               `sysctl<span class="string">' even if</span></span><br><span class="line"><span class="string">                               the `sysctl_file'</span></span><br><span class="line">                               is updated.</span><br><span class="line">      state                  <span class="comment"># Whether the entry should be present or absent in</span></span><br><span class="line">                               the sysctl file.</span><br><span class="line">      sysctl_file            <span class="comment"># Specifies the absolute path to `sysctl.conf', if</span></span><br><span class="line">                               not `/etc/sysctl.c</span><br><span class="line">                               onf<span class="string">'.</span></span><br><span class="line"><span class="string">      sysctl_set             # Verify token value with the sysctl command and</span></span><br><span class="line"><span class="string">                               set with -w if</span></span><br><span class="line"><span class="string">                               necessary</span></span><br><span class="line"><span class="string">      value                  # Desired value of the sysctl key.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m sysctl -a "name=kernel.panic v</span></span><br><span class="line">alue=3 sysctl_file=/etc/sysctl.conf<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>15.unarchive模块。功能：解压缩，这个模块有两种用法：</p><p>1、将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes</p><p>2、将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no</p><p>具体吃的参数如下：</p><ul><li>copy：在解压文件之前，是否先将文件复制到远程主机，默认为yes。若为no，则要求目标主机上压缩包必须存在。</li><li>creates：指定一个文件名，当该文件存在时，则解压指令不执行</li><li>dest：远程主机上的一个路径，即文件解压的路径 </li><li>grop：解压后的目录或文件的属组</li><li>list_files：如果为yes，则会列出压缩包里的文件，默认为no，2.0版本新增的选项</li><li>mode：解决后文件的权限</li><li>src：如果copy为yes，则需要指定压缩文件的源路径 </li><li>owner：解压后文件或目录的属主</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m unarchive -a "src=/tmp/install</span></span><br><span class="line">/zabbix-3.0.4.tar.gz dest=/tmp/ mode=0755<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>extract_results<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>cmd<span class="string">": [</span></span><br><span class="line"><span class="string">            "</span>/bin/gtar<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>--extract<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-C<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-z<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-f<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">"</span></span><br><span class="line"><span class="string">        ], </span></span><br><span class="line"><span class="string">        "</span>err<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>out<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>rc<span class="string">": 0</span></span><br><span class="line"><span class="string">    &#125;, </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>handler<span class="string">": "</span>TgzArchive<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>01777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 4096, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>directory<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########下面是查看路径下的zabbix解压包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -alh /tmp'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 120K</span></span><br><span class="line"><span class="string">drwxrwxrwt.  7 root    root    4.0K 9月   5 16:28 .</span></span><br><span class="line"><span class="string">dr-xr-xr-x. 24 root    root    4.0K 9月   1 09:45 ..</span></span><br><span class="line"><span class="string">drwx------   2 root    root    4.0K 9月   5 16:28 ansible_1zOyd2</span></span><br><span class="line"><span class="string">drwxr-xr-x.  7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--   1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">drwxrwxrwt   2 root    root    4.0K 9月   1 09:45 .ICE-unix</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x.  3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------.  1 root    root       0 1月  18 2017 yum.log</span></span><br><span class="line"><span class="string">drwxr-xr-x  13 www        1000 4.0K 7月  22 2016 zabbix-3.0.4</span></span><br></pre></td></tr></table></figure><p><strong>总之，以上就是ansible常用的模块，如果还需要其他的模块的话可以查看下官方文档（**</strong><a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*</a>* <a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html%EF%BC%89%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener"><strong>也可以通过命令来进行查看</strong></a></p><p><strong>1，查看所有的模块命令： ansible-doc  -l</strong></p><p><strong>2，查看具体某个模块用法：ansible-doc -s MODULE_NAME</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（&lt;a href=&quot;http://docs
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>三个技巧将Docker镜像体积压缩90%</title>
    <link href="http://blog.ozairs.com/Docker/%E4%B8%89%E4%B8%AA%E6%8A%80%E5%B7%A7%E5%B0%86Docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A990/"/>
    <id>http://blog.ozairs.com/Docker/三个技巧将Docker镜像体积压缩90/</id>
    <published>2019-03-16T05:44:57.000Z</published>
    <updated>2019-03-16T05:52:11.404Z</updated>
    
    <content type="html"><![CDATA[<p>在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。</p><p>但<code>RUN</code>语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？</p><p>你可能已经注意到了，大多数 Dockerfiles 都使用了一些奇怪的技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install vim</span><br></pre></td></tr></table></figure><p>为什么使用 &amp;&amp;？而不是使用两个 RUN 语句代替呢？比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>从 Docker 1.10 开始，<code>COPY</code>、<code>ADD</code>和<code>RUN</code>语句会向镜像中添加新层。前面的示例创建了两个层而不是一个。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/1.gif" alt=""></p><p>镜像的层就像 Git 的提交（commit）一样。</p><p>Docker 的层用于保存镜像的上一版本和当前版本之间的差异。就像 Git 的提交一样，如果你与其他存储库或镜像共享它们，就会很方便。</p><p>实际上，当你向注册表请求镜像时，只是下载你尚未拥有的层。这是一种非常高效地共享镜像的方式。</p><p>但额外的层并不是没有代价的。</p><p>层仍然会占用空间，你拥有的层越多，最终的镜像就越大。Git 存储库在这方面也是类似的，存储库的大小随着层数的增加而增加，因为 Git 必须保存提交之间的所有变更。</p><p>过去，将多个<code>RUN</code>语句组合在一行命令中或许是一种很好的做法，就像上面的第一个例子那样，但在现在看来，这样做并不妥。</p><p>通过Docker 多阶段构建将多个层压缩为一个</p><p>当 Git 存储库变大时，你可以选择将历史提交记录压缩为单个提交。</p><p>事实证明，在 Docker 中也可以使用多阶段构建达到类似的目的。</p><p>在这个示例中，你将构建一个 Node.js 容器。</p><p>让我们从 index.js 开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;Hello World!&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(`Example app listening on port 3000!`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和 package.json：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;name&quot;: &quot;hello-world&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;express&quot;: &quot;^4.16.2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用下面的 Dockerfile 来打包这个应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MAINTAINER xialeistudio xialeistudio@gmail.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG disturl=https://npm.taobao.org/dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set disturl $disturl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set registry $registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn --frozen-lockfile --production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY . /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [ &quot;yarn&quot;, &quot;start:prod&quot; ]</span><br></pre></td></tr></table></figure><p>然后开始构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-vanilla .</span><br></pre></td></tr></table></figure><p>然后用以下方法验证它是否可以正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</span><br></pre></td></tr></table></figure><p>你应该能访问 <a href="http://localhost:3000，并收到“Hello" target="_blank" rel="noopener">http://localhost:3000，并收到“Hello</a> World!”。</p><p>Dockerfile 中使用了一个 COPY 语句和一个 RUN 语句，所以按照预期，新镜像应该比基础镜像多出至少两个层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-vanilla</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">075d229d3f48   /bin/sh -c #(nop)  CMD [&quot;npm&quot; &quot;start&quot;]          0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bc8c3cc813ae   /bin/sh -c npm install                          2.91MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bac31afb6f42   /bin/sh -c #(nop) COPY multi:3071ddd474429e1…   364B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">500a9fbef90e   /bin/sh -c #(nop) WORKDIR /app                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">78b28027dfbf   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>但实际上，生成的镜像多了五个新层：每一个层对应 Dockerfile 里的一个语句。</p><p>现在，让我们来试试 Docker 的多阶段构建。</p><p>你可以继续使用与上面相同的 Dockerfile，只是现在要调用两次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>Dockerfile 的第一部分创建了三个层，然后这些层被合并并复制到第二个阶段。在第二阶段，镜像顶部又添加了额外的两个层，所以总共是三个层。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/2.gif" alt=""></p><p>现在来验证一下。首先，构建容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-multi-stage .</span><br></pre></td></tr></table></figure><p>查看镜像的历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-multi-stage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">331b81a245b1   /bin/sh -c #(nop)  CMD [&quot;index.js&quot;]             0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bdfc932314af   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f8992f6c62a6   /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77…   1.62MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>文件大小是否已发生改变？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-multi-stage   331b81a245b1   678MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-vanilla       075d229d3f48   679MB</span><br></pre></td></tr></table></figure><p>最后一个镜像（node-multi-stage）更小一些。</p><p>你已经将镜像的体积减小了，即使它已经是一个很小的应用程序。</p><p>但整个镜像仍然很大！</p><p>有什么办法可以让它变得更小吗？</p><p>用 distroless 去除不必要的东西</p><p>这个镜像包含了 Node.js 以及 yarn、npm、bash 和其他的二进制文件。因为它也是基于 Ubuntu 的，所以你等于拥有了一个完整的操作系统，其中包括所有的小型二进制文件和实用程序。</p><p>但在运行容器时是不需要这些东西的，你需要的只是 Node.js。</p><p>Docker 容器应该只包含一个进程以及用于运行这个进程所需的最少的文件，你不需要整个操作系统。</p><p>实际上，你可以删除 Node.js 之外的所有内容。</p><p>但要怎么做？</p><p>所幸的是，<a href="https://www.baidu.com/s?wd=%E8%B0%B7%E6%AD%8C&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">谷歌</a>为我们提供了 distroless（<a href="https://github.com/GoogleCloudPlatform/distroless）。" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/distroless）。</a></p><p>以下是 distroless 存储库的描述：</p><blockquote><p>“distroless”镜像只包含应用程序及其运行时依赖项，不包含程序包管理器、shell 以及在标准 Linux 发行版中可以找到的任何其他程序。</p></blockquote><p>这正是你所需要的！</p><p>你可以对 Dockerfile 进行调整，以利用新的基础镜像，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM gcr.io/distroless/nodejs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>你可以像往常一样编译镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-distroless .</span><br></pre></td></tr></table></figure><p>这个镜像应该能正常运行。要验证它，可以像这样运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-distroless</span><br></pre></td></tr></table></figure><p>s现在可以访问 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 页面。</p><p>不包含其他额外二进制文件的镜像是不是小多了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-distroless</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-distroless   7b4db3b7f1e5   76.7MB</span><br></pre></td></tr></table></figure><p>只有 76.7MB！</p><p>比之前的镜像小了 600MB！</p><p>但在使用 distroless 时有一些事项需要注意。</p><p>当容器在运行时，如果你想要检查它，可以使用以下命令 attach 到正在运行的容器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; bash</span><br></pre></td></tr></table></figure><p>attach 到正在运行的容器并运行 bash 命令就像是建立了一个 SSH 会话一样。</p><p>但 distroless 版本是原始操作系统的精简版，没有了额外的二进制文件，所以容器里没有 shell！</p><p>在没有 shell 的情况下，如何 attach 到正在运行的容器呢？</p><p>答案是，你做不到。这既是个坏消息，也是个好消息。</p><p>之所以说是坏消息，因为你只能在容器中执行二进制文件。你可以运行的唯一的二进制文件是 Node.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; node</span><br></pre></td></tr></table></figure><p>说它是个好消息，是因为如果攻击者利用你的应用程序获得对容器的访问权限将无法像访问 shell 那样造成太多破坏。换句话说，更少的二进制文件意味着更小的体积和更高的安全性，不过这是以痛苦的调试为代价的。</p><blockquote><p>或许你不应在生产环境中 attach 和调试容器，而应该使用日志和监控。</p></blockquote><p>但如果你确实需要调试，又想保持小体积该怎么办？</p><p>小体积的 Alpine 基础镜像</p><p>你可以使用 Alpine 基础镜像替换 distroless 基础镜像。</p><p>Alpine Linux 是：</p><blockquote><p>一个基于 musl libc 和 <a href="https://www.baidu.com/s?wd=busybox&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">busybox</a> 的面向安全的轻量级 Linux 发行版。</p></blockquote><p>换句话说，它是一个体积更小也更安全的 Linux 发行版。</p><p>不过你不应该<a href="https://www.baidu.com/s?wd=%E7%90%86%E6%89%80%E5%BD%93%E7%84%B6&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">理所当然</a>地认为他们声称的就一定是事实，让我们来看看它的镜像是否更小。</p><p>先修改 Dockerfile，让它使用 node:8-alpine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><p>使用下面的命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-alpine .</span><br></pre></td></tr></table></figure><p>现在可以检查一下镜像大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-alpine   aa1f85f8e724   69.7MB</span><br></pre></td></tr></table></figure><p>69.7MB！</p><p>甚至比 distrless 镜像还小！</p><p>现在可以 attach 到正在运行的容器吗？让我们来试试。</p><p>让我们先启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example app listening on port 3000!</span><br></pre></td></tr></table></figure><p>你可以使用以下命令 attach 到运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused &quot;exec: \&quot;bash\&quot;: executable file not found in $PATH&quot;: unknown</span><br></pre></td></tr></table></figure><p>看来不行，但或许可以使用 shell？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 sh / #</span><br></pre></td></tr></table></figure><p>成功了！现在可以 attach 到正在运行的容器中了。</p><p>看起来很有希望，但还有一个问题。</p><p>Alpine 基础镜像是基于 muslc 的——C 语言的一个替代标准库，而大多数 Linux 发行版如 Ubuntu、Debian 和 CentOS 都是基于 glibc 的。这两个库应该实现相同的内核接口。</p><p>但它们的目的是不一样的：</p><ul><li>glibc 更常见，速度也更快；</li><li>muslc 使用较少的空间，并侧重于安全性。</li></ul><p>在编译应用程序时，大部分都是针对特定的 libc 进行编译的。如果你要将它们与另一个 libc 一起使用，则必须重新编译它们。</p><p>换句话说，基于 Alpine 基础镜像构建容器可能会导致非预期的行为，因为标准 C 库是不一样的。</p><p>你可能会注意到差异，特别是当你处理预编译的二进制文件（如 Node.js C++ 扩展）时。</p><p>例如，PhantomJS 的预构建包就不能在 Alpine 上运行。</p><p>你应该选择哪个基础镜像？</p><p>你应该使用 Alpine、distroless 还是原始镜像？</p><p>如果你是在生产环境中运行容器，并且更关心安全性，那么可能 distroless 镜像更合适。</p><p>添加到 Docker 镜像的每个二进制文件都会给整个应用程序增加一定的风险。</p><p>只在容器中安装一个二进制文件可以降低总体风险。</p><p>例如，如果攻击者能够利用运行在 distroless 上的应用程序的漏洞，他们将无法在容器中使用 shell，因为那里根本就没有 shell！</p><blockquote><p>请注意，OWASP 本身就建议尽量减少攻击表面。</p></blockquote><p>如果你只关心更小的镜像体积，那么可以考虑基于 Alpine 的镜像。</p><p>它们的体积非常小，但代价是兼容性较差。Alpine 使用了略微不同的标准 C 库——muslc。你可能会时不时地遇到一些兼容性问题。</p><p>原始基础镜像非常适合用于测试和开发。</p><p>它虽然体积很大，但提供了与 Ubuntu 工作站一样的体验。此外，你还可以访问操作系统的所有二进制文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;RUN&lt;/code&gt;语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何编写最佳的Dockerfile</title>
    <link href="http://blog.ozairs.com/Docker/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%9C%80%E4%BD%B3%E7%9A%84Dockerfile/"/>
    <id>http://blog.ozairs.com/Docker/如何编写最佳的Dockerfile/</id>
    <published>2019-03-16T05:28:24.000Z</published>
    <updated>2019-03-16T05:29:37.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习</strong>。</p><p>我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的Dockerfile。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>更快的构建速度</li><li>更小的Docker镜像大小</li><li>更少的Docker镜像层</li><li>充分利用镜像缓存</li><li>增加Dockerfile可读性</li><li>让Docker容器使用起来更简单</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编写.dockerignore文件</li><li>容器只运行单个应用</li><li>将多个RUN指令合并为一个</li><li>基础镜像的标签不要用latest</li><li>每个RUN指令后删除多余文件</li><li>选择合适的基础镜像(alpine版本最好)</li><li>设置WORKDIR和CMD</li><li>使用ENTRYPOINT (可选)</li><li>在entrypoint脚本中使用exec</li><li>COPY与ADD优先使用前者</li><li>合理调整COPY与RUN的顺序</li><li>设置默认的环境变量，映射端口和数据卷</li><li>使用LABEL设置镜像元数据</li><li>添加HEALTHCHECK</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例Dockerfile犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用Docker运行一个Node.js应用，下面就是它的Dockerfile(CMD指令太复杂了，所以我简化了，它是错误的，仅供参考)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y  </span><br><span class="line">RUN apt-get install -y nodejs ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># this should start three processes, mysql and ssh</span><br><span class="line"># in the background and node app in foreground</span><br><span class="line"># isn&apos;t it beautifully terrible? &lt;3</span><br><span class="line">CMD mysql &amp; sshd &amp; npm start</span><br></pre></td></tr></table></figure><p>构建镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t wtf .</span><br></pre></td></tr></table></figure><h3 id="1-编写-dockerignore文件"><a href="#1-编写-dockerignore文件" class="headerlink" title="1. 编写.dockerignore文件"></a>1. 编写.dockerignore文件</h3><p>构建镜像时，Docker需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含Dockerfile目录中的所有文件，但是实际上，<strong>我们并不需要.git目录，node_modules目录等内容</strong>。 <code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure><h3 id="2-容器只运行单个应用"><a href="#2-容器只运行单个应用" class="headerlink" title="2. 容器只运行单个应用"></a>2. 容器只运行单个应用</h3><p>从技术角度讲，你可以在Docker容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor都运行在同一个Docker容器中。但是，这会让你非常痛苦:</p><ul><li>非常长的构建时间(修改前端之后，整个后端也需要重新构建)</li><li>非常大的镜像大小</li><li>多个应用的日志难以处理(不能直接使用stdout，否则多个应用的日志会混合到一起)</li><li>横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)</li><li>僵尸进程问题 - 你需要选择合适的init进程</li></ul><p>因此，我建议大家为每个应用构建单独的Docker镜像，然后使用 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a> 运行多个Docker容器。</p><p>现在，我从Dockerfile中删除一些不需要的安装包，另外，SSH可以用<a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank" rel="noopener">docker exec</a>替代。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y</span><br><span class="line"></span><br><span class="line"># we should remove ssh and mysql, and use</span><br><span class="line"># separate container for database </span><br><span class="line">RUN apt-get install -y nodejs  # ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="3-将多个RUN指令合并为一个"><a href="#3-将多个RUN指令合并为一个" class="headerlink" title="3. 将多个RUN指令合并为一个"></a>3. 将多个RUN指令合并为一个</h3><p>Docker镜像是分层的，下面这些知识点非常重要:</p><ul><li>Dockerfile中的每个指令都会创建一个新的镜像层。</li><li>镜像层将被缓存和复用</li><li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li><li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li><li>镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)。</li></ul><p>Docker镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。</p><p>现在，我们<strong>将所有的RUN指令合并为一个</strong>。同时把<code>apt-get upgrade</code>删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    &amp;&amp; cd /app \</span><br><span class="line">    &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>记住一点，我们只能将变化频率一样的指令合并在一起。将node.js安装与npm模块安装放在一起的话，则每次修改源代码，都需要重新安装node.js，这显然不合适。因此，正确的写法是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="4-基础镜像的标签不要用latest"><a href="#4-基础镜像的标签不要用latest" class="headerlink" title="4. 基础镜像的标签不要用latest"></a>4. 基础镜像的标签不要用latest</h3><p>当镜像没有指定标签时，将默认使用<code>latest</code> 标签。因此， <code>FROM ubuntu</code> 指令等同于<code>FROM ubuntu:latest</code>。当时，当镜像更新时，latest标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用latest标签，否则的话，最好指定确定的镜像标签。</p><p>示例Dockerfile应该使用<code>16.04</code>作为标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04  # it&apos;s that easy!</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="5-每个RUN指令后删除多余文件"><a href="#5-每个RUN指令后删除多余文件" class="headerlink" title="5. 每个RUN指令后删除多余文件"></a>5. 每个RUN指令后删除多余文件</h3><p>假设我们更新了apt-get源，下载，解压并安装了一些软件包，它们都保存在<code>/var/lib/apt/lists/</code>目录中。但是，运行应用时Docker镜像中并不需要这些文件。我们最好将它们删除，因为它会使Docker镜像变大。</p><p>示例Dockerfile中，我们可以删除<code>/var/lib/apt/lists/</code>目录中的文件(它们是由apt-get update生成的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    # added lines</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="6-选择合适的基础镜像-alpine版本最好"><a href="#6-选择合适的基础镜像-alpine版本最好" class="headerlink" title="6. 选择合适的基础镜像(alpine版本最好)"></a>6. 选择合适的基础镜像(alpine版本最好)</h3><p>在示例中，我们选择了<code>ubuntu</code>作为基础镜像。但是我们只需要运行node程序，有必要使用一个通用的基础镜像吗？<code>node</code>镜像应该是更好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line"># we don&apos;t need to install node </span><br><span class="line"># anymore and use apt-get</span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>更好的选择是alpine版本的<code>node</code>镜像。alpine是一个极小化的Linux发行版，只有4MB，这让它非常适合作为基础镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p><a href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management" target="_blank" rel="noopener">apk</a>是Alpine的包管理工具。它与<code>apt-get</code>有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如<code>no-cache</code>和 <code>--virtual</code>选项，它们都可以帮助我们减少镜像的大小。</p><h3 id="7-设置WORKDIR和-CMD"><a href="#7-设置WORKDIR和-CMD" class="headerlink" title="7. 设置WORKDIR和 CMD"></a>7. 设置WORKDIR和 CMD</h3><p><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="noopener">WORKDIR</a>指令可以设置默认目录，也就是运行<code>RUN</code> / <code>CMD</code> / <code>ENTRYPOINT</code>指令的地方。</p><p><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">CMD</a>指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考<a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="8-使用ENTRYPOINT-可选"><a href="#8-使用ENTRYPOINT-可选" class="headerlink" title="8. 使用ENTRYPOINT (可选)"></a>8. 使用ENTRYPOINT (可选)</h3><p><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">ENTRYPOINT</a>指令并不是必须的，因为它会增加复杂度。<code>ENTRYPOINT</code>是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的Docker镜像。entrypoint.sh如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line"># $0 is a script name, </span><br><span class="line"># $1, $2, $3 etc are passed arguments</span><br><span class="line"># $1 is our command</span><br><span class="line">CMD=$1</span><br><span class="line"></span><br><span class="line">case &quot;$CMD&quot; in  </span><br><span class="line">  &quot;dev&quot; )</span><br><span class="line">    npm install</span><br><span class="line">    export NODE_ENV=development</span><br><span class="line">    exec npm run dev</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  &quot;start&quot; )</span><br><span class="line">    # we can modify files here, using ENV variables passed in </span><br><span class="line">    # &quot;docker create&quot; command. It can&apos;t be done during build process.</span><br><span class="line">    echo &quot;db: $DATABASE_ADDRESS&quot; &gt;&gt; /app/config.yml</span><br><span class="line">    export NODE_ENV=production</span><br><span class="line">    exec npm start</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">   * )</span><br><span class="line">    # Run custom command. Thanks to this line we can still use </span><br><span class="line">    # &quot;docker run our_image /bin/bash&quot; and it will work</span><br><span class="line">    exec $CMD $&#123;@:2&#125;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>示例Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>可以使用如下命令运行该镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 运行开发版本</span><br><span class="line">docker run our-app dev </span><br><span class="line"></span><br><span class="line"># 运行生产版本</span><br><span class="line">docker run our-app start </span><br><span class="line"></span><br><span class="line"># 运行bash</span><br><span class="line">docker run -it our-app /bin/bash</span><br></pre></td></tr></table></figure><h3 id="9-在entrypoint脚本中使用exec"><a href="#9-在entrypoint脚本中使用exec" class="headerlink" title="9. 在entrypoint脚本中使用exec"></a>9. 在entrypoint脚本中使用exec</h3><p>在前文的entrypoint脚本中，我使用了<code>exec</code>命令运行node应用。不使用<code>exec</code>的话，我们则不能顺利地关闭容器，因为SIGTERM信号会被bash脚本进程吞没。<code>exec</code>命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。</p><h3 id="10-COPY与ADD优先使用前者"><a href="#10-COPY与ADD优先使用前者" class="headerlink" title="10. COPY与ADD优先使用前者"></a>10. COPY与ADD优先使用前者</h3><p><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener">COPY</a>指令非常简单，仅用于将文件拷贝到镜像中。<a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener">ADD</a>相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="11-合理调整COPY与RUN的顺序"><a href="#11-合理调整COPY与RUN的顺序" class="headerlink" title="11. 合理调整COPY与RUN的顺序"></a>11. 合理调整COPY与RUN的顺序</h3><p>我们应该<strong>把变化最少的部分放在Dockerfile的前面</strong>，这样可以充分利用镜像缓存。</p><p>示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝<code>package.json</code>，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY package.json /app  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="12-设置默认的环境变量，映射端口和数据卷"><a href="#12-设置默认的环境变量，映射端口和数据卷" class="headerlink" title="12. 设置默认的环境变量，映射端口和数据卷"></a>12. 设置默认的环境变量，映射端口和数据卷</h3><p>运行Docker容器时很可能需要一些环境变量。在Dockerfile设置默认的环境变量是一种很好的方式。另外，我们应该在Dockerfile中设置映射端口和数据卷。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app</span><br><span class="line"></span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">ENV</a>指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARG</a>指令。</p><h3 id="13-使用LABEL设置镜像元数据"><a href="#13-使用LABEL设置镜像元数据" class="headerlink" title="13. 使用LABEL设置镜像元数据"></a>13. 使用LABEL设置镜像元数据</h3><p>使用<a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank" rel="noopener">LABEL</a>指令，可以为镜像设置元数据，例如<strong>镜像创建者</strong>或者<strong>镜像说明</strong>。旧版的Dockerfile语法使用<a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated" target="_blank" rel="noopener">MAINTAINER</a>指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="noopener">nvidia-docker</a>需要用到<code>com.nvidia.volumes.needed</code>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="14-添加HEALTHCHECK"><a href="#14-添加HEALTHCHECK" class="headerlink" title="14. 添加HEALTHCHECK"></a>14. 添加HEALTHCHECK</h3><p>运行容器时，可以指定<code>--restart always</code>选项。这样的话，容器崩溃时，Docker守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener">HEALTHCHECK</a>指令可以让Docker周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回0，否则返回1。对HEALTHCHECK感兴趣的话，可以参考<a href="https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/" target="_blank" rel="noopener">这篇博客</a>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app  </span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT  </span><br><span class="line">HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>当请求失败时，<code>curl --fail</code> 命令返回非0状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的D
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
</feed>
