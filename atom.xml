<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>带你走进美丽的墨尔本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ozairs.com/"/>
  <updated>2019-03-17T03:02:10.745Z</updated>
  <id>http://blog.ozairs.com/</id>
  
  <author>
    <name>Mark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins与Docker的自动化CI/CD实战</title>
    <link href="http://blog.ozairs.com/DevOps/Jenkins%E4%B8%8EDocker%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96CI-CD%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Jenkins与Docker的自动化CI-CD实战/</id>
    <published>2019-03-17T02:48:26.000Z</published>
    <updated>2019-03-17T03:02:10.745Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。</p><h2 id="一、发布流程设计"><a href="#一、发布流程设计" class="headerlink" title="一、发布流程设计"></a>一、发布流程设计</h2><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.1.png" alt=""></p><p>工作流程：**</p><ol><li>开发人员提交代码到Git版本仓库；</li><li>Jenkins人工/定时触发项目构建；</li><li>Jenkins拉取代码、代码编码、打包镜像、推送到镜像仓库；</li><li>Jenkins在Docker主机创建容器并发布。</li></ol><p>环境规划如下：</p><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>Jenkins/Docker</td><td>192.168.0.217</td></tr><tr><td>Docker</td><td>192.168.0.218</td></tr><tr><td>Git/Registry</td><td>192.168.0.219</td></tr></tbody></table><p>操作系统：CentOS7.4</p><h2 id="二、部署Git仓库"><a href="#二、部署Git仓库" class="headerlink" title="二、部署Git仓库"></a>二、部署Git仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install git -y</span><br></pre></td></tr></table></figure><ol><li><p>创建Git用户并设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># useradd git</span><br><span class="line"># passwd git</span><br></pre></td></tr></table></figure></li><li><p>创建仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># su - git</span><br><span class="line"># mkdir solo.git</span><br><span class="line"># cd solo.git</span><br><span class="line"># git --bare init</span><br></pre></td></tr></table></figure></li><li><p>访问创建的这个仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone git@192.168.0.212:/home/git/solo.git</span><br></pre></td></tr></table></figure><h2 id="三、准备Jenkins环境"><a href="#三、准备Jenkins环境" class="headerlink" title="三、准备Jenkins环境"></a>三、准备Jenkins环境</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于代码编译、部署、测试等工作。 Jenkins也是一个跨平台的，大多数主流的平台都支持，而且安装很简单，我们这里以部署war包方式安装它。<br>官网下载地址：<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a> </p><p>在安装前需要具备Java环境，安装方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tar zxf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8 </span><br><span class="line"># vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8 </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar </span><br><span class="line">export JAVA_HOME PATH CLASSPATH</span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>在192.168.0.217主机安装Jenkins，下载Tomcat二进制包将war包到webapps下即可：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war </span><br><span class="line"># wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># tar zxf apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># mv apache-tomcat-8.5.32 /usr/local/tomcat-jenkins </span><br><span class="line"># rm /usr/local/tomcat-jenkins/webapps/* -rf </span><br><span class="line"># unzip jenkins.war -d /usr/local/tomcat-jenkins/webapps/ROOT </span><br><span class="line"># cd /usr/local/tomcat-jenkins/bin/ </span><br><span class="line"># ./startup.sh </span><br><span class="line"># tail ../logs/catalina.out -f </span><br><span class="line">... </span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated. </span><br><span class="line">Please use the following password to proceed to installation: </span><br><span class="line"></span><br><span class="line">a5f1f7c167fd4b8ab62f9497d32d97db </span><br><span class="line"></span><br><span class="line">This may also be found at: /root/.jenkins/secrets/initialAdminPassword ...</span><br></pre></td></tr></table></figure><p>部署成功，访问Jenkins：<a href="http://ip:8080/" target="_blank" rel="noopener">http://ip:8080</a></p><p>第一步：输入上面日志输出的密码：a5f1f7c167fd4b8ab62f9497d32d97db，或者从本机/root/.jenkins/secrets/initialAdminPassword文件获取，点击继续<br>第二步：点击“选择插件来安装”<br>第三步：保持默认，点击继续<br>第四步：创建管理员用户，保存并完成<br>第五步：设置Jenkins访问地址，保持默认，点击保存完成</p><p>安装完成，开始使用Jenkins：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/2.png" alt=""></p><h2 id="四、部署私有镜像仓库"><a href="#四、部署私有镜像仓库" class="headerlink" title="四、部署私有镜像仓库"></a>四、部署私有镜像仓库</h2><p>Docker Hub作为Docker默认官方公共镜像；如果想自己搭建私有镜像仓库，官方也提供registry镜像，使得搭建私有仓库非常简单。<br>在192.168.0.219部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>接下来测试registry可用性。<br>由于Docker CLI默认以HTTPS访问，而部署的registry并未提供HTTPS，因此，需要在pull镜像的Docker主机（192.168.0.217，192.168.0.218）添加HTTP可信任：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> # vi /etc/docker/daemon.json </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.0.219:5000&quot;]&#125;</span><br><span class="line"># service docker restart</span><br></pre></td></tr></table></figure><h2 id="五、安装Docker"><a href="#五、安装Docker" class="headerlink" title="五、安装Docker"></a>五、安装Docker</h2><p>在192.168.0.217/192.168.0.218/192.168.0.219主机安装Docker，如下：</p><ol><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>添加Docker软件包源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install docker-ce -y</span><br></pre></td></tr></table></figure></li><li><p>配置加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://bc437cce.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>启动并开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="六、构建Tomcat基础镜像"><a href="#六、构建Tomcat基础镜像" class="headerlink" title="六、构建Tomcat基础镜像"></a>六、构建Tomcat基础镜像</h2><p>JAVA程序必须有JDK环境才可以运行，为了减少镜像大小及提高性能，这里直接把JDK放到宿主机上，容器以挂载形式使用。<br>在192.168.0.217/192.168.0.218安装JDK：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8</span><br></pre></td></tr></table></figure><p>Tomcat基础镜像Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.aliangedu.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.32</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk</span><br><span class="line"></span><br><span class="line">RUN yum install wget -y</span><br><span class="line"></span><br><span class="line">RUN wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v$&#123;VERSION&#125;/bin/apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    mv apache-tomcat-$&#123;VERSION&#125; /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    rm -rf apache-tomcat-$&#123;VERSION&#125;.tar.gz /usr/local/tomcat/webapps/* &amp;&amp; \</span><br><span class="line">    mkdir /usr/local/tomcat/webapps/ROOT</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure><p>构建镜像并上传到registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t 192.168.0.219:5000/tomcat-85 -f Dockerfile .</span><br><span class="line"># docker push 192.168.0.219:5000/tomcat-85</span><br></pre></td></tr></table></figure><h2 id="七、Jenkins配置全局工具配置"><a href="#七、Jenkins配置全局工具配置" class="headerlink" title="七、Jenkins配置全局工具配置"></a>七、Jenkins配置全局工具配置</h2><p>主页面 -&gt; 系统管理 -&gt; 全局工具配置</p><p>指定JDK、Maven路径，Git保持默认：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/3.png" alt=""><br>如果Jenkins主机没有git命令，需要安装Git：<br><code># yum install git -y</code></p><h2 id="八、Jenkins安装必要插件"><a href="#八、Jenkins安装必要插件" class="headerlink" title="八、Jenkins安装必要插件"></a>八、Jenkins安装必要插件</h2><p><strong>1. Jenkins安装必要插件</strong><br>主页面 -&gt; 系统管理 -&gt;管理插件：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/4.png" alt=""><br>安装SSH与Git Parameter插件。</p><p>插件说明：</p><ul><li>SSH：用于SSH远程Docker主机执行Shell命令</li><li>Git Parameter：动态获取Git仓库Branch、Tag</li></ul><p><strong>2. 配置SSH插件</strong><br><strong>第一步：先创建一个用于连接Docker主机的凭据。</strong><br>主页面 -&gt; 凭据 -&gt; 系统 -&gt; 右击全局凭据 -&gt; 添加凭据：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/5.png" alt="">输入连接Docker主机的用户名和密码：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/6.png" alt=""><br><strong>第二步：添加SSH远程主机</strong><br>主页面 -&gt; 系统管理 -&gt; 系统设置 -&gt; SSH remote hosts：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/7.png" alt=""></p><h2 id="九、上传JAVA项目代码到Git仓库"><a href="#九、上传JAVA项目代码到Git仓库" class="headerlink" title="九、上传JAVA项目代码到Git仓库"></a>九、上传JAVA项目代码到Git仓库</h2><p>从Github拉取开源JAVA博客系统solo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/b3log/solo</span><br><span class="line"># cd solo</span><br><span class="line">移除旧的推送地址，添加新的：</span><br><span class="line"># git remote remove origin </span><br><span class="line"># git remote add origin git@192.168.0.219:/home/git/solo.git</span><br><span class="line">提交代码到Git仓库并创建tag：</span><br><span class="line"># touch src/main/webapp/a.html</span><br><span class="line"># git add .</span><br><span class="line"># git commit -m “a”</span><br><span class="line">创建标签：</span><br><span class="line"># git tag 1.0.0</span><br><span class="line">推送到Git服务器：</span><br><span class="line"># git push origin 1.0.0</span><br></pre></td></tr></table></figure><h2 id="十、Jenkins创建项目并发布测试"><a href="#十、Jenkins创建项目并发布测试" class="headerlink" title="十、Jenkins创建项目并发布测试"></a>十、Jenkins创建项目并发布测试</h2><p>主页面 -&gt; 新建任务 -&gt; 输入任务名称，构建一个Maven项目：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/8.png" alt=""><br>注意：如果没有显示“构建一个Maven项目”选项，需要在管理插件里安装“Maven Integration plugin”插件。<br>配置Git参数化构建：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/9.png" alt=""><br>动态获取Git仓库tag，与用户交互选择Tag发布：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/10.png" alt=""><br>指定项目Git仓库地址：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/11.png" alt=""><br>修改*/master为$Tag，Tag是上面动态获取的变量名，表示根据用户选择打代码版本。</p><p>设置maven构建命令选项：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/12.png" alt=""></p><p>利用pom.xml文件构建项目。<br>在Jenkins本机镜像构建与推送到镜像仓库，并SSH远程连接到Docker主机使用推送的镜像创建容器：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/13.png" alt=""><br>上图中，在Jenkins主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 构建镜像</span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM 192.168.0.219:5000/tomcat-85:latest</span><br><span class="line">RUN rm -rf /usr/local/tomcat/webapps/ROOT</span><br><span class="line">COPY target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">EOF</span><br><span class="line">docker build -t $REPOSITORY .</span><br><span class="line"># 上传镜像</span><br><span class="line">docker push $REPOSITORY</span><br></pre></td></tr></table></figure><p>上图中，SSH远程Docker主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 部署</span><br><span class="line">docker rm -f blog-solo |true</span><br><span class="line">docker image rm $REPOSITORY |true</span><br><span class="line">docker container run -d --name blog-solo -v /usr/local/jdk1.8:/usr/local/jdk -p 88:8080 $REPOSITORY</span><br></pre></td></tr></table></figure><p>注：容器名称blog-solo，暴露宿主机端口88，即使用宿主机IP:88访问blog-solo项目。<br>blog-solo项目已配置完成，开始构建：</p><p>选择tag，开始构建：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/14.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/15.png" alt=""></p><p>点击左下角构建历史里，右击第一个查看控制台输出：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/16.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/17.png" alt=""></p><p>浏览器访问solo项目：<a href="http://192.168.0.218:88/" target="_blank" rel="noopener">http://192.168.0.218:88</a><br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/18.png" alt=""><br>如果输出上述页面说明是正常的，页面没有加载成功样式，需要修改下项目里访问地址。</p><p>至此，自动化CI环境搭建完成，你可以模拟提交代码并打tag测试自动化发布流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。&lt;/p&gt;
&lt;h2 id=&quot;一、发布流程设计&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>把一个Node.js web应用程序给Docker化</title>
    <link href="http://blog.ozairs.com/DevOps/%E6%8A%8A%E4%B8%80%E4%B8%AANode-js-web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%99Docker%E5%8C%96/"/>
    <id>http://blog.ozairs.com/DevOps/把一个Node-js-web应用程序给Docker化/</id>
    <published>2019-03-17T02:26:13.000Z</published>
    <updated>2019-03-17T02:27:00.275Z</updated>
    
    <content type="html"><![CDATA[<p>本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 <em>非</em> 产品发布人员。此教程同样假定你有一个可以正常工作的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装</a>，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。</p><p>在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。</p><p>Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。</p><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"First Last &lt;first.last@example.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><p>然后，创建一个 <code>server.js</code> 文件，使用 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a> 框架定义一个 Web 应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello world\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。</p><h2 id="创建一个名称为-Dockerfile-的文件"><a href="#创建一个名称为-Dockerfile-的文件" class="headerlink" title="创建一个名称为 Dockerfile 的文件"></a>创建一个名称为 <code>Dockerfile</code> 的文件</h2><p>创建一个空文件，命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>用你最喜欢的文本编辑器打开这个 <code>Dockerfile</code>。</p><p>我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），<code>Node</code> 的版本号为 <code>8</code>。你可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker 站点</a> 获取相关镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure><p>此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 <code>npm</code> 安装你的应用程序的所有依赖。请注意，如果你的 <code>npm</code> 的版本是 4 或者更早的版本，<code>package-lock.json</code> 文件将不会自动生成。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install app dependencies</span></span><br><span class="line"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span><br><span class="line"><span class="comment"># where available (npm@5+)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br></pre></td></tr></table></figure><p>请注意，我们只是拷贝了 <code>package.json</code> 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">见此</a>。 进一步说，对于生产环境而言，注释中提及的 <code>npm ci</code> 命令协助提供了一个更快、可靠、可再生的构建环境。欲知详情，可以参考<a href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" target="_blank" rel="noopener">此处</a>。</p><p>在 Docker 镜像中使用 <code>COPY</code> 命令绑定你的应用程序：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure><p>你的应用程序绑定的端口为 <code>8080</code>，所以你可以使用 <code>EXPOSE</code> 命令使它与 <code>docker</code> 的镜像做映射：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>最后但同样重要的事是，使用定义运行时的 <code>CMD</code> 定义命令来运行应用程序。这里我们使用最简单的 <code>npm start</code> 命令，它将运行 <code>node server.js</code> 启动你的服务器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>你的 <code>Dockerfile</code> 现在看上去是这个样子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>在 <code>Dockerfile</code> 的同一个文件夹中创建一个 <code>.dockerignore</code> 文件，带有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。</p><h2 id="构建你的镜像"><a href="#构建你的镜像" class="headerlink" title="构建你的镜像"></a>构建你的镜像</h2><p>进入到 <code>Dockerfile</code> 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 <code>-t</code> 让你标记你的镜像，以至于让你以后很容易地用 <code>docker images</code> 找到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;your username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><p>Docker 现在将给出你的镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">REPOSITORY                      TAG        ID              CREATED</span><br><span class="line">node                            8          1934b0b038d1    5 days ago</span><br><span class="line">&lt;your username&gt;/node-web-app    latest     d64d3505b0d2    1 minute ago</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用 <code>-d</code> 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 <code>-p</code> 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app</span><br></pre></td></tr></table></figure><p>把你应用程序的输出打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get container ID</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print app output</span></span><br><span class="line">$ docker logs &lt;container id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">Running on http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果你需要进入容器中，请运行 <code>exec</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter the container</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container id&gt; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为测试你的应用程序，给出与 Docker 映射过的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">ID            IMAGE                                COMMAND    ...   PORTS</span><br><span class="line">ecce33b30ebf  &lt;your username&gt;/node-web-app:latest  npm start  ...   49160-&gt;8080</span><br></pre></td></tr></table></figure><p>在上面的例子中，在容器中 Docker 把端口号 <code>8080</code> 映射到你机器上的 <code>49160</code> 。</p><p>现在你可以使用 <code>curl</code>（如果需要的话请通过 <code>sudo apt-get install curl</code> 安装）调用你的程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:49160</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 12</span><br><span class="line">ETag: W/<span class="string">"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"</span></span><br><span class="line">Date: Mon, 13 Nov 2017 20:53:59 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。</p><p>你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容：</p><ul><li><a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener">官方 Node.js 的 Docker 镜像</a></li><li><a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">Node.js 基于 Docker 使用的最佳经验</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方 Docker 文档</a></li><li><a href="https://stackoverflow.com/questions/tagged/docker" target="_blank" rel="noopener">在 StackOverFlow 上有关 Docker 标记内容</a></li><li><a href="https://reddit.com/r/docker" target="_blank" rel="noopener">Docker Subreddit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 &lt;em&gt;非&lt;/em&gt; 产品发布人员。此教程同样假定你有一个可以正常工作的 &lt;a href=&quot;https://docs.docker.com/engine/in
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="NodeJs" scheme="http://blog.ozairs.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation CLI命令</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation-CLI%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation-CLI命令/</id>
    <published>2019-03-16T11:47:59.000Z</published>
    <updated>2019-03-16T11:52:06.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Creating-a-Stack"><a href="#Creating-a-Stack" class="headerlink" title="Creating a Stack"></a>Creating a Stack</h2><p>You must provide the stack name, the location of a valid template, and any input parameters. If you specify a local template file, AWS CloudFormation uploads it to an Amazon S3 bucket in your AWS account.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation create-stack --stack-name myteststack --template-body file:///home/testuser/mytemplate.json --parameters ParameterKey=Parm1,ParameterValue=test1 ParameterKey=Parm2,ParameterValue=test2</span><br></pre></td></tr></table></figure><h2 id="Listing-Your-Stacks"><a href="#Listing-Your-Stacks" class="headerlink" title="Listing Your Stacks"></a>Listing Your Stacks</h2><p>Note The aws cloudformation list-stacks command returns information on deleted stacks for 90 days after they have been deleted.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE</span><br></pre></td></tr></table></figure><h2 id="Describing-Your-Stacks"><a href="#Describing-Your-Stacks" class="headerlink" title="Describing Your Stacks"></a>Describing Your Stacks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stacks --stack-name myteststack</span><br></pre></td></tr></table></figure><p>By default, aws cloudformation describe-stacks returns parameter values. To prevent sensitive parameter values such as passwords from being returned, include a NoEcho property set to TRUE in your AWS CloudFormation template.</p><h2 id="Viewing-Stack-Event-History"><a href="#Viewing-Stack-Event-History" class="headerlink" title="Viewing Stack Event History"></a>Viewing Stack Event History</h2><p>You can track the status of the resources AWS CloudFormation is creating and deleting with the aws cloudformation describe-stack-events command. The amount of time to create or delete a stack depends on the complexity of your stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stack-events --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Listing-Stack-Resources"><a href="#Listing-Stack-Resources" class="headerlink" title="Listing Stack Resources"></a>Listing Stack Resources</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stack-resources --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Retrieving-a-Template"><a href="#Retrieving-a-Template" class="headerlink" title="Retrieving a Template"></a>Retrieving a Template</h2><p>AWS CloudFormation stores the template you use to create your stack as part of the stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation get-template --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Validating-a-Template"><a href="#Validating-a-Template" class="headerlink" title="Validating a Template"></a>Validating a Template</h2><p>You can validate templates locally by using the –template-body parameter, or remotely with the –template-url parameter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation validate-template --template-url https://s3.amazonaws.com/cloudformation-templates-us-east-1/S3_Bucket.template</span><br><span class="line">$ aws cloudformation validate-template --template-body file:///home/local/test/sampletemplate.json</span><br></pre></td></tr></table></figure><h2 id="Deleting-a-Stack"><a href="#Deleting-a-Stack" class="headerlink" title="Deleting a Stack"></a>Deleting a Stack</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation delete-stack --stack-name myteststack</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Creating-a-Stack&quot;&gt;&lt;a href=&quot;#Creating-a-Stack&quot; class=&quot;headerlink&quot; title=&quot;Creating a Stack&quot;&gt;&lt;/a&gt;Creating a Stack&lt;/h2&gt;&lt;p&gt;You must provi
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>Ansible常用模块</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible常用模块/</id>
    <published>2019-03-16T11:25:04.000Z</published>
    <updated>2019-03-16T11:26:18.285Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（<a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。</a></p><p>1，ping模块。测试主机是否是通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m ping</span></span><br><span class="line">Server5 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br><span class="line">Server6 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，远程命令模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webserver -m <span class="built_in">command</span> -a <span class="string">"free -m"</span>  <span class="comment">#远程命令。</span></span><br><span class="line">ansible webserver -m script -a <span class="string">"/home/test.sh"</span> <span class="comment">#远程主机执行主控服务器ansible上的脚本</span></span><br><span class="line">ansible webserver -m shell -a <span class="string">"/home/test.sh"</span>   <span class="comment">#执行远程主机上的脚本命令</span></span><br></pre></td></tr></table></figure><p>3，setup模块。主要用于获取主机信息，在playbooks里经常会用到的一个参数，gather_facts就与该模块相关。setup模块下经常使用的一个参数是filter参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_*_mb'</span>   //查看主机内存信息</span><br><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_eth[0-2]'</span>   //查看地接口为eth0-2的网卡信息</span><br><span class="line">ansible all -m setup --tree /tmp/facts   //将所有主机的信息输入到/tmp/facts目录下，每台主机的信息输入到主机名文件中（/etc/ansible/hosts里的主机名）</span><br></pre></td></tr></table></figure><p>4，stat模块。获取远程文件状态信息,包括atime、ctime、mtime、MD5、uid、gid等信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.5 -m stat -a "path=/etc/sysctl.conf </span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.5 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": false, </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">stat</span><span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>atime<span class="string">": 1504513902.6297896, </span></span><br><span class="line"><span class="string">        "</span>checksum<span class="string">": "</span>a27c7ce2e6002c37f3cb537ad997c6da7fd76480<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>ctime<span class="string">": 1480926522.4591811, </span></span><br><span class="line"><span class="string">        "</span>dev<span class="string">": 64768, </span></span><br><span class="line"><span class="string">        "</span>executable<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>exists<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>gr_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>inode<span class="string">": 393634, </span></span><br><span class="line"><span class="string">        "</span>isblk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>ischr<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isdir<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isfifo<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isgid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>islnk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isreg<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>issock<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isuid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>md5<span class="string">": "</span>c97839af771c8447b9fc23090b4e8d0f<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mtime<span class="string">": 1361531931.0, </span></span><br><span class="line"><span class="string">        "</span>nlink<span class="string">": 1, </span></span><br><span class="line"><span class="string">        "</span>path<span class="string">": "</span>/etc/sysctl.conf<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>pw_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>readable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rgrp<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>roth<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>size<span class="string">": 1150, </span></span><br><span class="line"><span class="string">        "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>wgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>woth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>writeable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>wusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>xgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xoth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xusr<span class="string">": false</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>5，file模块。file模块主要用于远程主机上的文件操作，file模块包含如下选项： </p><p>force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no </p><ul><li>group：定义文件/目录的属组 </li><li>mode：定义文件/目录的权限</li><li>owner：定义文件/目录的属主</li><li>path：必选项，定义文件/目录的路径</li><li>recurse：递归的设置文件的属性，只对目录有效</li><li>src：要被链接的源文件的路径，只应用于state=link的情况</li><li>dest：被链接到的路径，只应用于state=link的情况 </li><li>state：    </li><li>directory：如果目录不存在，创建目录</li><li>file：即使文件不存在，也不会被创建</li><li>link：创建软链接</li><li>hard：创建硬链接</li><li>touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</li><li>absent：删除目录、文件或者取消链接文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m file -a "src=/etc/fstab dest=/</span></span><br><span class="line">tmp/fstab state=link<span class="string">"                         ########在远程主机180.6上创建远程软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 10, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/etc/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>link<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">touch<span class="string">"                                 ############在远程主机180.6上创建test文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 5, </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">absent<span class="string">"                                #############在远程主机删除文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/fstab state</span><br><span class="line">=absent<span class="string">"                                            #############在远程主机删除fstab软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>6，copy模块。实现复制文件到远程主机，copy模块包含如下选项：</p><ul><li>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no </li><li>content：用于替代”src”,可以直接设定指定文件的值 </li><li>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录 </li><li>directory_mode：递归的设定目录的权限，默认为系统默认权限</li><li>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</li><li>others：所有的file模块里的选项都可以在这里使用</li><li>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用”/“来结尾，则只复制目录里的内容，如果没有使用”/“来结尾，则包含目录在内的整个内容全部复制，类似于rsync。 </li></ul><p>以下的例子试下拷贝/etc/ansible/script.sh文件到主机组web1所有的主机/tmp下并更新文件属主和权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m copy -a "src=/etc/ansible/script.sh des</span></span><br><span class="line">t=/tmp/ owner=appuser group=appuser mode=0755<span class="string">"      ###复制本地脚本到远程主机server6下并定义用户和组以及权限755</span></span><br><span class="line"><span class="string">Server6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum<span class="string">": "</span>18ca258e92141948010f2e0896cf655cdb945a1d<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/script.sh<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 500, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>d5e15b2da056fdd7b7ba30100035de2e<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0755<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 30, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504517543.07-102988847745614/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 500</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>7,service模块。用于远程主机的服务管理。该模块包含如下选项： </p><ul><li>arguments：给命令行提供一些选项 </li><li>enabled：是否开机启动 yes|no</li><li>name：必选项，服务名称 </li><li>pattern：定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行</li><li>runlevel：运行级别</li><li>sleep：如果执行了restarted，在则stop和start之间沉睡几秒钟</li><li>state：对当前服务执行启动，停止、重启、重新加载等操作（started,stopped,restarted,reloaded）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####重启远程主机180.6的网卡服务</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m service -a "name=network state</span></span><br><span class="line">=restarted args=eth0<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>name<span class="string">": "</span>network<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>started<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>8，cron模块。用于远程主机crontab配置，管理计划任务包含如下选项： </p><ul><li>backup：对远程主机上的原任务计划内容修改之前做备份 </li><li>cron_file：如果指定该选项，则用该文件替换远程主机上的cron.d目录下的用户的任务计划 </li><li>day：日（1-31，<em>，</em>/2,……） </li><li>hour：小时（0-23，<em>，</em>/2，……）  </li><li>minute：分钟（0-59，<em>，</em>/2，……） </li><li>month：月（1-12，<em>，</em>/2，……） </li><li>weekday：周（0-7，*，……）</li><li>job：要执行的任务，依赖于state=present </li><li>name：该任务的描述 </li><li>special_time：指定什么时候执行，参数：reboot,yearly,annually,monthly,weekly,daily,hourly </li><li>state：确认该任务计划是创建还是删除 </li><li>user：以哪个用户的身份执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6  -m cron -a 'name="a job for rebo</span></span><br><span class="line">ot<span class="string">" special_time=reboot job="</span>/some/job.sh<span class="string">"'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>envs<span class="string">": [], </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">jobs</span><span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>a job <span class="keyword">for</span> reboot<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">##########客户端</span></span><br><span class="line"><span class="string">-bash-4.1# crontab -l</span></span><br><span class="line"><span class="string">#Ansible: a job for reboot</span></span><br><span class="line"><span class="string">@reboot /some/job.sh</span></span><br></pre></td></tr></table></figure><p>9，yum模块。Linux平台软件包管理操作 常见的有yum apt 管理方式，其选项有： </p><ul><li>config_file：yum的配置文件 </li><li>disable_gpg_check：关闭gpg_check </li><li>disablerepo：不启用某个源 </li><li>enablerepo：启用某个源</li><li>name：要进行操作的软件包的名字，也可以传递一个url或者一个本地的rpm包的路径 </li><li>state：状态（present，absent，latest）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m yum -a "name=curl state=latest</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>rc<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>results<span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>已加载插件：fastestmirror\n设置更新进程\nLoading mirror speeds from cached hostfile\n解决依赖关系\n--&gt; 执行事务检查\n---&gt; Package curl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package curl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 处理依赖关系 libcurl = 7.19.7-53.el6_9，它被软件包 curl-7.19.7-53.el6_9.x86_64 需要\n--&gt; 执行事务检查\n---&gt; Package libcurl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package libcurl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 完成依赖关系计算\n\n依赖关系解决\n\n================================================================================\n 软件包          架构           版本                      仓库             大小\n================================================================================\n正在升级:\n curl            x86_64         7.19.7-53.el6_9           updates         197 k\n为依赖而更新:\n libcurl         x86_64         7.19.7-53.el6_9           updates         169 k\n\n事务概要\n================================================================================\nUpgrade       2 Package(s)\n\n总下载量：367 k\n下载软件包：\n--------------------------------------------------------------------------------\n总计                                            3.1 MB/s | 367 kB     00:00     \n运行 rpm_check_debug \n执行事务测试\n事务测试成功\n执行事务\n\r  正在升级   : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  正在升级   : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  清理       : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  清理       : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\r  Verifying  : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  Verifying  : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  Verifying  : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  Verifying  : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\n更新完毕:\n  curl.x86_64 0:7.19.7-53.el6_9                                                 \n\n作为依赖被升级:\n  libcurl.x86_64 0:7.19.7-53.el6_9                                              \n\n完毕！\n<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之前</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之后</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-53.el6_9.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-53.el6_9.x86_64</span></span><br></pre></td></tr></table></figure><p>10.user模块。实现远程主机系统用户管理。</p><ul><li>home：指定用户的家目录，需要与createhome配合使用</li><li>groups：指定用户的属组</li><li>uid：指定用的uid</li><li>password：指定用户的密码</li><li>name：指定用户名</li><li>createhome：是否创建家目录 yes|no</li><li>system：是否为系统用户</li><li>remove：当state=absent时，remove=yes则表示连同家目录一起删除，等价于userdel -r</li><li>state：是创建还是删除</li><li>shell：指定用户的shell环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m user -a 'name=www1 comment=lqb</span></span><br><span class="line"> uid=1001 group=root <span class="string">'               ###新建www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "comment": "lqb", </span></span><br><span class="line"><span class="string">    "createhome": true, </span></span><br><span class="line"><span class="string">    "group": 0, </span></span><br><span class="line"><span class="string">    "home": "/home/www1", </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "shell": "/bin/bash", </span></span><br><span class="line"><span class="string">    "state": "present", </span></span><br><span class="line"><span class="string">    "system": false, </span></span><br><span class="line"><span class="string">    "uid": 1001</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m user -a '</span>name=www1 state=absen</span><br><span class="line">t remove=yes<span class="string">'                     ########删除www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "force": false, </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "remove": true, </span></span><br><span class="line"><span class="string">    "state": "absent"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>11.rsynchronize模块。使用rsync同步文件，其参数如下：</p><ul><li>archive: 归档，相当于同时开启recursive(递归)、links、perms、times、owner、group、-D选项都为yes ，默认该项为开启</li><li>checksum: 跳过检测sum值，默认关闭</li><li>compress:是否开启压缩</li><li>copy_links：复制链接文件，默认为no ，注意后面还有一个links参数</li><li>delete: 删除不存在的文件，默认no</li><li>dest：目录路径</li><li>dest_port：默认目录主机上的端口 ，默认是22，走的ssh协议</li><li>dirs：传速目录不进行递归，默认为no，即进行目录递归</li><li>rsync_opts：rsync参数部分</li><li>set_remote_user：主要用于/etc/ansible/hosts中定义或默认使用的用户与rsync使用的用户不同的情况</li><li>mode: push或pull 模块，push模的话，一般用于从本机向远程主机上传文件，pull 模式用于从远程主机上取文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############使用rsynchronize模块首先远程客户端要先按照rsync包才可以使用</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -a "yum install rsync -y"</span></span><br><span class="line">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">设置安装进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">解决依赖关系</span><br><span class="line">--&gt; 执行事务检查</span><br><span class="line">---&gt; Package rsync.x86_64 0:3.0.6-12.el6 will be 安装</span><br><span class="line">--&gt; 完成依赖关系计算</span><br><span class="line">依赖关系解决</span><br><span class="line">================================================================================</span><br><span class="line"> 软件包          架构             版本                     仓库            大小</span><br><span class="line">================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> rsync           x86_64           3.0.6-12.el6             base           335 k</span><br><span class="line">事务概要</span><br><span class="line">================================================================================</span><br><span class="line">Install       1 Package(s)</span><br><span class="line">总下载量：335 k</span><br><span class="line">Installed size: 682 k</span><br><span class="line">下载软件包：</span><br><span class="line">运行 rpm_check_debug </span><br><span class="line">执行事务测试</span><br><span class="line">事务测试成功</span><br><span class="line">执行事务</span><br><span class="line">  正在安装   : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">  Verifying  : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">已安装:</span><br><span class="line">  rsync.x86_64 0:3.0.6-12.el6                                                   </span><br><span class="line">完毕！</span><br><span class="line"></span><br><span class="line"><span class="comment">############远程客户端安装好rsync包后就可以在ansible服务端使用rsync进行同步了</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m synchronize -a 'src=/etc/ansib</span></span><br><span class="line">le/conf/hosts dest=/tmp/ <span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "cmd": "/usr/bin/rsync --delay-updates -F --compress --archive --rsh '</span>ssh -i /root/.ssh/id_rsa_web -S none -o StrictHostKeyChecking=no -o Port=22<span class="string">' --out-format='</span>&lt;&lt;CHANGED&gt;&gt;%i %n%L<span class="string">' \"/etc/ansible/conf/hosts\" \"root@192.168.180.6:/tmp/\"", </span></span><br><span class="line"><span class="string">    "msg": "&lt;f+++++++++ hosts\n", </span></span><br><span class="line"><span class="string">    "rc": 0, </span></span><br><span class="line"><span class="string">    "stdout_lines": [</span></span><br><span class="line"><span class="string">        "&lt;f+++++++++ hosts"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>12.mount模块。主要配置挂载点的。主要的参数如下：</p><ul><li>dump</li><li>fstype：必选项，挂载文件的类型 </li><li>name：必选项，挂载点 </li><li>opts：传递给mount命令的参数</li><li>src：必选项，要挂载的文件 </li><li>state：必选项 </li><li>present：只处理fstab中的配置 </li><li>absent：删除挂载点 </li><li>mounted：自动创建挂载点并挂载之 </li><li>umounted：卸载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###############把本地的磁盘挂载到远程主机180.6上</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m mount -a 'name=/tmp/app src=/d</span></span><br><span class="line">ev/sda2 fstype=ext4 state=mounted opts=rw<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "dump": "0", </span></span><br><span class="line"><span class="string">    "fstab": "/etc/fstab", </span></span><br><span class="line"><span class="string">    "fstype": "ext4", </span></span><br><span class="line"><span class="string">    "name": "/tmp/app", </span></span><br><span class="line"><span class="string">    "opts": "rw", </span></span><br><span class="line"><span class="string">    "passno": "0", </span></span><br><span class="line"><span class="string">    "src": "/dev/sda2"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#############下面是查看远程主机是否挂载成功</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>cat /etc/fstab<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># /etc/fstab</span></span><br><span class="line"><span class="string"># Created by anaconda on Wed Jan 18 14:50:09 2017</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Accessible filesystems, by reference, are maintained under '</span>/dev/disk<span class="string">'</span></span><br><span class="line"><span class="string"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">UUID=942820c4-9134-41da-9271-78ad0f8a33b2 /                       ext4    defaults        1 1</span></span><br><span class="line"><span class="string">UUID=e5d84663-09d2-429f-9f90-43a37b1a84a7 /opt                    ext4    defaults        1 2</span></span><br><span class="line"><span class="string">UUID=e9098124-206a-4116-a580-91d1d46fe8a9 swap                    swap    defaults        0 0</span></span><br><span class="line"><span class="string">tmpfs                   /dev/shm                tmpfs   defaults        0 0</span></span><br><span class="line"><span class="string">devpts                  /dev/pts                devpts  gid=5,mode=620  0 0</span></span><br><span class="line"><span class="string">sysfs                   /sys                    sysfs   defaults        0 0</span></span><br><span class="line"><span class="string">proc                    /proc                   proc    defaults        0 0</span></span><br><span class="line"><span class="string">/dev/sda2 /tmp/app ext4 rw 0 0</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>df -h<span class="string">'         </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">Filesystem      Size  Used Avail Use% Mounted on</span></span><br><span class="line"><span class="string">/dev/sda1        87G   12G   71G  14% /</span></span><br><span class="line"><span class="string">tmpfs           935M     0  935M   0% /dev/shm</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /opt</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /tmp/app</span></span><br></pre></td></tr></table></figure><p>13.get_url模块。该模块主要用于从http，ftp ,https等服务器上下载文件类似于wget。主要选项如下：</p><ul><li>sha256sum：下载完成后进行sha256 check；</li><li>timeout：下载超时时间，默认10s</li><li>url：下载的URL</li><li>url_password、url_username：主要用于需要用户名密码进行验证的情况</li><li>use_proxy：是事使用代理，代理需事先在环境变更中定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################从网站下载页面到/tmp/下</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m get_url -a "url=http://www.guo</span></span><br><span class="line">jinbao.com dest=/tmp/guojinbao mode=0440 force=yes<span class="string">"    </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum_dest<span class="string">": null, </span></span><br><span class="line"><span class="string">    "</span>checksum_src<span class="string">": "</span>75fa271ea83d05f2817027cf4009f9e9fda7ef88<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/guojinbao<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>e9ea1af241cf68289f3286b99af24baa<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0440<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span>OK (unknown bytes)<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 38033, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/tmp/tmp47gp_m<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>url<span class="string">": "</span>http://www.guojinbao.com<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########远程查看下载目录下有没有刚才下载的文件</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -lh /tmp/'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 104K</span></span><br><span class="line"><span class="string">drwx------  2 root    root    4.0K 9月   5 16:01 ansible_zwKwyh</span></span><br><span class="line"><span class="string">drwxr-xr-x. 7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x. 3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------. 1 root    root       0 1月  18 2017 yum.log</span></span><br></pre></td></tr></table></figure><p>14.sysctl包管理模块。用于远程主机sysctl的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible-doc -s sysctl        ###########查看sysctl的使用说明</span></span><br><span class="line">- name: Manage entries <span class="keyword">in</span> sysctl.conf.</span><br><span class="line">  action: sysctl</span><br><span class="line">      ignoreerrors           <span class="comment"># Use this option to ignore errors about unknown</span></span><br><span class="line">                               keys.</span><br><span class="line">      name=                  <span class="comment"># The dot-separated path (aka `key') specifying the                               sysctl variable.</span></span><br><span class="line">      reload                 <span class="comment"># If `yes', performs a `/sbin/sysctl -p' if the</span></span><br><span class="line">                               `sysctl_file<span class="string">' is</span></span><br><span class="line"><span class="string">                               updated. If `no'</span>,</span><br><span class="line">                               does not reload</span><br><span class="line">                               `sysctl<span class="string">' even if</span></span><br><span class="line"><span class="string">                               the `sysctl_file'</span></span><br><span class="line">                               is updated.</span><br><span class="line">      state                  <span class="comment"># Whether the entry should be present or absent in</span></span><br><span class="line">                               the sysctl file.</span><br><span class="line">      sysctl_file            <span class="comment"># Specifies the absolute path to `sysctl.conf', if</span></span><br><span class="line">                               not `/etc/sysctl.c</span><br><span class="line">                               onf<span class="string">'.</span></span><br><span class="line"><span class="string">      sysctl_set             # Verify token value with the sysctl command and</span></span><br><span class="line"><span class="string">                               set with -w if</span></span><br><span class="line"><span class="string">                               necessary</span></span><br><span class="line"><span class="string">      value                  # Desired value of the sysctl key.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m sysctl -a "name=kernel.panic v</span></span><br><span class="line">alue=3 sysctl_file=/etc/sysctl.conf<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>15.unarchive模块。功能：解压缩，这个模块有两种用法：</p><p>1、将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes</p><p>2、将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no</p><p>具体吃的参数如下：</p><ul><li>copy：在解压文件之前，是否先将文件复制到远程主机，默认为yes。若为no，则要求目标主机上压缩包必须存在。</li><li>creates：指定一个文件名，当该文件存在时，则解压指令不执行</li><li>dest：远程主机上的一个路径，即文件解压的路径 </li><li>grop：解压后的目录或文件的属组</li><li>list_files：如果为yes，则会列出压缩包里的文件，默认为no，2.0版本新增的选项</li><li>mode：解决后文件的权限</li><li>src：如果copy为yes，则需要指定压缩文件的源路径 </li><li>owner：解压后文件或目录的属主</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m unarchive -a "src=/tmp/install</span></span><br><span class="line">/zabbix-3.0.4.tar.gz dest=/tmp/ mode=0755<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>extract_results<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>cmd<span class="string">": [</span></span><br><span class="line"><span class="string">            "</span>/bin/gtar<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>--extract<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-C<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-z<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-f<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">"</span></span><br><span class="line"><span class="string">        ], </span></span><br><span class="line"><span class="string">        "</span>err<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>out<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>rc<span class="string">": 0</span></span><br><span class="line"><span class="string">    &#125;, </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>handler<span class="string">": "</span>TgzArchive<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>01777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 4096, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>directory<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########下面是查看路径下的zabbix解压包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -alh /tmp'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 120K</span></span><br><span class="line"><span class="string">drwxrwxrwt.  7 root    root    4.0K 9月   5 16:28 .</span></span><br><span class="line"><span class="string">dr-xr-xr-x. 24 root    root    4.0K 9月   1 09:45 ..</span></span><br><span class="line"><span class="string">drwx------   2 root    root    4.0K 9月   5 16:28 ansible_1zOyd2</span></span><br><span class="line"><span class="string">drwxr-xr-x.  7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--   1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">drwxrwxrwt   2 root    root    4.0K 9月   1 09:45 .ICE-unix</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x.  3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------.  1 root    root       0 1月  18 2017 yum.log</span></span><br><span class="line"><span class="string">drwxr-xr-x  13 www        1000 4.0K 7月  22 2016 zabbix-3.0.4</span></span><br></pre></td></tr></table></figure><p><strong>总之，以上就是ansible常用的模块，如果还需要其他的模块的话可以查看下官方文档（**</strong><a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*</a>* <a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html%EF%BC%89%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener"><strong>也可以通过命令来进行查看</strong></a></p><p><strong>1，查看所有的模块命令： ansible-doc  -l</strong></p><p><strong>2，查看具体某个模块用法：ansible-doc -s MODULE_NAME</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（&lt;a href=&quot;http://docs
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>三个技巧将Docker镜像体积压缩90%</title>
    <link href="http://blog.ozairs.com/Docker/%E4%B8%89%E4%B8%AA%E6%8A%80%E5%B7%A7%E5%B0%86Docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A990/"/>
    <id>http://blog.ozairs.com/Docker/三个技巧将Docker镜像体积压缩90/</id>
    <published>2019-03-16T05:44:57.000Z</published>
    <updated>2019-03-16T05:52:11.404Z</updated>
    
    <content type="html"><![CDATA[<p>在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。</p><p>但<code>RUN</code>语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？</p><p>你可能已经注意到了，大多数 Dockerfiles 都使用了一些奇怪的技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install vim</span><br></pre></td></tr></table></figure><p>为什么使用 &amp;&amp;？而不是使用两个 RUN 语句代替呢？比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>从 Docker 1.10 开始，<code>COPY</code>、<code>ADD</code>和<code>RUN</code>语句会向镜像中添加新层。前面的示例创建了两个层而不是一个。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/1.gif" alt=""></p><p>镜像的层就像 Git 的提交（commit）一样。</p><p>Docker 的层用于保存镜像的上一版本和当前版本之间的差异。就像 Git 的提交一样，如果你与其他存储库或镜像共享它们，就会很方便。</p><p>实际上，当你向注册表请求镜像时，只是下载你尚未拥有的层。这是一种非常高效地共享镜像的方式。</p><p>但额外的层并不是没有代价的。</p><p>层仍然会占用空间，你拥有的层越多，最终的镜像就越大。Git 存储库在这方面也是类似的，存储库的大小随着层数的增加而增加，因为 Git 必须保存提交之间的所有变更。</p><p>过去，将多个<code>RUN</code>语句组合在一行命令中或许是一种很好的做法，就像上面的第一个例子那样，但在现在看来，这样做并不妥。</p><p>通过Docker 多阶段构建将多个层压缩为一个</p><p>当 Git 存储库变大时，你可以选择将历史提交记录压缩为单个提交。</p><p>事实证明，在 Docker 中也可以使用多阶段构建达到类似的目的。</p><p>在这个示例中，你将构建一个 Node.js 容器。</p><p>让我们从 index.js 开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;Hello World!&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(`Example app listening on port 3000!`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和 package.json：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;name&quot;: &quot;hello-world&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;express&quot;: &quot;^4.16.2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用下面的 Dockerfile 来打包这个应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MAINTAINER xialeistudio xialeistudio@gmail.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG disturl=https://npm.taobao.org/dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set disturl $disturl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set registry $registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn --frozen-lockfile --production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY . /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [ &quot;yarn&quot;, &quot;start:prod&quot; ]</span><br></pre></td></tr></table></figure><p>然后开始构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-vanilla .</span><br></pre></td></tr></table></figure><p>然后用以下方法验证它是否可以正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</span><br></pre></td></tr></table></figure><p>你应该能访问 <a href="http://localhost:3000，并收到“Hello" target="_blank" rel="noopener">http://localhost:3000，并收到“Hello</a> World!”。</p><p>Dockerfile 中使用了一个 COPY 语句和一个 RUN 语句，所以按照预期，新镜像应该比基础镜像多出至少两个层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-vanilla</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">075d229d3f48   /bin/sh -c #(nop)  CMD [&quot;npm&quot; &quot;start&quot;]          0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bc8c3cc813ae   /bin/sh -c npm install                          2.91MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bac31afb6f42   /bin/sh -c #(nop) COPY multi:3071ddd474429e1…   364B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">500a9fbef90e   /bin/sh -c #(nop) WORKDIR /app                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">78b28027dfbf   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>但实际上，生成的镜像多了五个新层：每一个层对应 Dockerfile 里的一个语句。</p><p>现在，让我们来试试 Docker 的多阶段构建。</p><p>你可以继续使用与上面相同的 Dockerfile，只是现在要调用两次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>Dockerfile 的第一部分创建了三个层，然后这些层被合并并复制到第二个阶段。在第二阶段，镜像顶部又添加了额外的两个层，所以总共是三个层。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/2.gif" alt=""></p><p>现在来验证一下。首先，构建容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-multi-stage .</span><br></pre></td></tr></table></figure><p>查看镜像的历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-multi-stage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">331b81a245b1   /bin/sh -c #(nop)  CMD [&quot;index.js&quot;]             0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bdfc932314af   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f8992f6c62a6   /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77…   1.62MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>文件大小是否已发生改变？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-multi-stage   331b81a245b1   678MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-vanilla       075d229d3f48   679MB</span><br></pre></td></tr></table></figure><p>最后一个镜像（node-multi-stage）更小一些。</p><p>你已经将镜像的体积减小了，即使它已经是一个很小的应用程序。</p><p>但整个镜像仍然很大！</p><p>有什么办法可以让它变得更小吗？</p><p>用 distroless 去除不必要的东西</p><p>这个镜像包含了 Node.js 以及 yarn、npm、bash 和其他的二进制文件。因为它也是基于 Ubuntu 的，所以你等于拥有了一个完整的操作系统，其中包括所有的小型二进制文件和实用程序。</p><p>但在运行容器时是不需要这些东西的，你需要的只是 Node.js。</p><p>Docker 容器应该只包含一个进程以及用于运行这个进程所需的最少的文件，你不需要整个操作系统。</p><p>实际上，你可以删除 Node.js 之外的所有内容。</p><p>但要怎么做？</p><p>所幸的是，<a href="https://www.baidu.com/s?wd=%E8%B0%B7%E6%AD%8C&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">谷歌</a>为我们提供了 distroless（<a href="https://github.com/GoogleCloudPlatform/distroless）。" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/distroless）。</a></p><p>以下是 distroless 存储库的描述：</p><blockquote><p>“distroless”镜像只包含应用程序及其运行时依赖项，不包含程序包管理器、shell 以及在标准 Linux 发行版中可以找到的任何其他程序。</p></blockquote><p>这正是你所需要的！</p><p>你可以对 Dockerfile 进行调整，以利用新的基础镜像，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM gcr.io/distroless/nodejs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>你可以像往常一样编译镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-distroless .</span><br></pre></td></tr></table></figure><p>这个镜像应该能正常运行。要验证它，可以像这样运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-distroless</span><br></pre></td></tr></table></figure><p>s现在可以访问 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 页面。</p><p>不包含其他额外二进制文件的镜像是不是小多了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-distroless</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-distroless   7b4db3b7f1e5   76.7MB</span><br></pre></td></tr></table></figure><p>只有 76.7MB！</p><p>比之前的镜像小了 600MB！</p><p>但在使用 distroless 时有一些事项需要注意。</p><p>当容器在运行时，如果你想要检查它，可以使用以下命令 attach 到正在运行的容器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; bash</span><br></pre></td></tr></table></figure><p>attach 到正在运行的容器并运行 bash 命令就像是建立了一个 SSH 会话一样。</p><p>但 distroless 版本是原始操作系统的精简版，没有了额外的二进制文件，所以容器里没有 shell！</p><p>在没有 shell 的情况下，如何 attach 到正在运行的容器呢？</p><p>答案是，你做不到。这既是个坏消息，也是个好消息。</p><p>之所以说是坏消息，因为你只能在容器中执行二进制文件。你可以运行的唯一的二进制文件是 Node.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; node</span><br></pre></td></tr></table></figure><p>说它是个好消息，是因为如果攻击者利用你的应用程序获得对容器的访问权限将无法像访问 shell 那样造成太多破坏。换句话说，更少的二进制文件意味着更小的体积和更高的安全性，不过这是以痛苦的调试为代价的。</p><blockquote><p>或许你不应在生产环境中 attach 和调试容器，而应该使用日志和监控。</p></blockquote><p>但如果你确实需要调试，又想保持小体积该怎么办？</p><p>小体积的 Alpine 基础镜像</p><p>你可以使用 Alpine 基础镜像替换 distroless 基础镜像。</p><p>Alpine Linux 是：</p><blockquote><p>一个基于 musl libc 和 <a href="https://www.baidu.com/s?wd=busybox&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">busybox</a> 的面向安全的轻量级 Linux 发行版。</p></blockquote><p>换句话说，它是一个体积更小也更安全的 Linux 发行版。</p><p>不过你不应该<a href="https://www.baidu.com/s?wd=%E7%90%86%E6%89%80%E5%BD%93%E7%84%B6&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">理所当然</a>地认为他们声称的就一定是事实，让我们来看看它的镜像是否更小。</p><p>先修改 Dockerfile，让它使用 node:8-alpine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><p>使用下面的命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-alpine .</span><br></pre></td></tr></table></figure><p>现在可以检查一下镜像大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-alpine   aa1f85f8e724   69.7MB</span><br></pre></td></tr></table></figure><p>69.7MB！</p><p>甚至比 distrless 镜像还小！</p><p>现在可以 attach 到正在运行的容器吗？让我们来试试。</p><p>让我们先启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example app listening on port 3000!</span><br></pre></td></tr></table></figure><p>你可以使用以下命令 attach 到运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused &quot;exec: \&quot;bash\&quot;: executable file not found in $PATH&quot;: unknown</span><br></pre></td></tr></table></figure><p>看来不行，但或许可以使用 shell？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 sh / #</span><br></pre></td></tr></table></figure><p>成功了！现在可以 attach 到正在运行的容器中了。</p><p>看起来很有希望，但还有一个问题。</p><p>Alpine 基础镜像是基于 muslc 的——C 语言的一个替代标准库，而大多数 Linux 发行版如 Ubuntu、Debian 和 CentOS 都是基于 glibc 的。这两个库应该实现相同的内核接口。</p><p>但它们的目的是不一样的：</p><ul><li>glibc 更常见，速度也更快；</li><li>muslc 使用较少的空间，并侧重于安全性。</li></ul><p>在编译应用程序时，大部分都是针对特定的 libc 进行编译的。如果你要将它们与另一个 libc 一起使用，则必须重新编译它们。</p><p>换句话说，基于 Alpine 基础镜像构建容器可能会导致非预期的行为，因为标准 C 库是不一样的。</p><p>你可能会注意到差异，特别是当你处理预编译的二进制文件（如 Node.js C++ 扩展）时。</p><p>例如，PhantomJS 的预构建包就不能在 Alpine 上运行。</p><p>你应该选择哪个基础镜像？</p><p>你应该使用 Alpine、distroless 还是原始镜像？</p><p>如果你是在生产环境中运行容器，并且更关心安全性，那么可能 distroless 镜像更合适。</p><p>添加到 Docker 镜像的每个二进制文件都会给整个应用程序增加一定的风险。</p><p>只在容器中安装一个二进制文件可以降低总体风险。</p><p>例如，如果攻击者能够利用运行在 distroless 上的应用程序的漏洞，他们将无法在容器中使用 shell，因为那里根本就没有 shell！</p><blockquote><p>请注意，OWASP 本身就建议尽量减少攻击表面。</p></blockquote><p>如果你只关心更小的镜像体积，那么可以考虑基于 Alpine 的镜像。</p><p>它们的体积非常小，但代价是兼容性较差。Alpine 使用了略微不同的标准 C 库——muslc。你可能会时不时地遇到一些兼容性问题。</p><p>原始基础镜像非常适合用于测试和开发。</p><p>它虽然体积很大，但提供了与 Ubuntu 工作站一样的体验。此外，你还可以访问操作系统的所有二进制文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;RUN&lt;/code&gt;语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何编写最佳的Dockerfile</title>
    <link href="http://blog.ozairs.com/Docker/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%9C%80%E4%BD%B3%E7%9A%84Dockerfile/"/>
    <id>http://blog.ozairs.com/Docker/如何编写最佳的Dockerfile/</id>
    <published>2019-03-16T05:28:24.000Z</published>
    <updated>2019-03-16T05:29:37.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习</strong>。</p><p>我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的Dockerfile。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>更快的构建速度</li><li>更小的Docker镜像大小</li><li>更少的Docker镜像层</li><li>充分利用镜像缓存</li><li>增加Dockerfile可读性</li><li>让Docker容器使用起来更简单</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编写.dockerignore文件</li><li>容器只运行单个应用</li><li>将多个RUN指令合并为一个</li><li>基础镜像的标签不要用latest</li><li>每个RUN指令后删除多余文件</li><li>选择合适的基础镜像(alpine版本最好)</li><li>设置WORKDIR和CMD</li><li>使用ENTRYPOINT (可选)</li><li>在entrypoint脚本中使用exec</li><li>COPY与ADD优先使用前者</li><li>合理调整COPY与RUN的顺序</li><li>设置默认的环境变量，映射端口和数据卷</li><li>使用LABEL设置镜像元数据</li><li>添加HEALTHCHECK</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例Dockerfile犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用Docker运行一个Node.js应用，下面就是它的Dockerfile(CMD指令太复杂了，所以我简化了，它是错误的，仅供参考)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y  </span><br><span class="line">RUN apt-get install -y nodejs ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># this should start three processes, mysql and ssh</span><br><span class="line"># in the background and node app in foreground</span><br><span class="line"># isn&apos;t it beautifully terrible? &lt;3</span><br><span class="line">CMD mysql &amp; sshd &amp; npm start</span><br></pre></td></tr></table></figure><p>构建镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t wtf .</span><br></pre></td></tr></table></figure><h3 id="1-编写-dockerignore文件"><a href="#1-编写-dockerignore文件" class="headerlink" title="1. 编写.dockerignore文件"></a>1. 编写.dockerignore文件</h3><p>构建镜像时，Docker需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含Dockerfile目录中的所有文件，但是实际上，<strong>我们并不需要.git目录，node_modules目录等内容</strong>。 <code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure><h3 id="2-容器只运行单个应用"><a href="#2-容器只运行单个应用" class="headerlink" title="2. 容器只运行单个应用"></a>2. 容器只运行单个应用</h3><p>从技术角度讲，你可以在Docker容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor都运行在同一个Docker容器中。但是，这会让你非常痛苦:</p><ul><li>非常长的构建时间(修改前端之后，整个后端也需要重新构建)</li><li>非常大的镜像大小</li><li>多个应用的日志难以处理(不能直接使用stdout，否则多个应用的日志会混合到一起)</li><li>横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)</li><li>僵尸进程问题 - 你需要选择合适的init进程</li></ul><p>因此，我建议大家为每个应用构建单独的Docker镜像，然后使用 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a> 运行多个Docker容器。</p><p>现在，我从Dockerfile中删除一些不需要的安装包，另外，SSH可以用<a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank" rel="noopener">docker exec</a>替代。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y</span><br><span class="line"></span><br><span class="line"># we should remove ssh and mysql, and use</span><br><span class="line"># separate container for database </span><br><span class="line">RUN apt-get install -y nodejs  # ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="3-将多个RUN指令合并为一个"><a href="#3-将多个RUN指令合并为一个" class="headerlink" title="3. 将多个RUN指令合并为一个"></a>3. 将多个RUN指令合并为一个</h3><p>Docker镜像是分层的，下面这些知识点非常重要:</p><ul><li>Dockerfile中的每个指令都会创建一个新的镜像层。</li><li>镜像层将被缓存和复用</li><li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li><li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li><li>镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)。</li></ul><p>Docker镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。</p><p>现在，我们<strong>将所有的RUN指令合并为一个</strong>。同时把<code>apt-get upgrade</code>删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    &amp;&amp; cd /app \</span><br><span class="line">    &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>记住一点，我们只能将变化频率一样的指令合并在一起。将node.js安装与npm模块安装放在一起的话，则每次修改源代码，都需要重新安装node.js，这显然不合适。因此，正确的写法是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="4-基础镜像的标签不要用latest"><a href="#4-基础镜像的标签不要用latest" class="headerlink" title="4. 基础镜像的标签不要用latest"></a>4. 基础镜像的标签不要用latest</h3><p>当镜像没有指定标签时，将默认使用<code>latest</code> 标签。因此， <code>FROM ubuntu</code> 指令等同于<code>FROM ubuntu:latest</code>。当时，当镜像更新时，latest标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用latest标签，否则的话，最好指定确定的镜像标签。</p><p>示例Dockerfile应该使用<code>16.04</code>作为标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04  # it&apos;s that easy!</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="5-每个RUN指令后删除多余文件"><a href="#5-每个RUN指令后删除多余文件" class="headerlink" title="5. 每个RUN指令后删除多余文件"></a>5. 每个RUN指令后删除多余文件</h3><p>假设我们更新了apt-get源，下载，解压并安装了一些软件包，它们都保存在<code>/var/lib/apt/lists/</code>目录中。但是，运行应用时Docker镜像中并不需要这些文件。我们最好将它们删除，因为它会使Docker镜像变大。</p><p>示例Dockerfile中，我们可以删除<code>/var/lib/apt/lists/</code>目录中的文件(它们是由apt-get update生成的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    # added lines</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="6-选择合适的基础镜像-alpine版本最好"><a href="#6-选择合适的基础镜像-alpine版本最好" class="headerlink" title="6. 选择合适的基础镜像(alpine版本最好)"></a>6. 选择合适的基础镜像(alpine版本最好)</h3><p>在示例中，我们选择了<code>ubuntu</code>作为基础镜像。但是我们只需要运行node程序，有必要使用一个通用的基础镜像吗？<code>node</code>镜像应该是更好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line"># we don&apos;t need to install node </span><br><span class="line"># anymore and use apt-get</span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>更好的选择是alpine版本的<code>node</code>镜像。alpine是一个极小化的Linux发行版，只有4MB，这让它非常适合作为基础镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p><a href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management" target="_blank" rel="noopener">apk</a>是Alpine的包管理工具。它与<code>apt-get</code>有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如<code>no-cache</code>和 <code>--virtual</code>选项，它们都可以帮助我们减少镜像的大小。</p><h3 id="7-设置WORKDIR和-CMD"><a href="#7-设置WORKDIR和-CMD" class="headerlink" title="7. 设置WORKDIR和 CMD"></a>7. 设置WORKDIR和 CMD</h3><p><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="noopener">WORKDIR</a>指令可以设置默认目录，也就是运行<code>RUN</code> / <code>CMD</code> / <code>ENTRYPOINT</code>指令的地方。</p><p><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">CMD</a>指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考<a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="8-使用ENTRYPOINT-可选"><a href="#8-使用ENTRYPOINT-可选" class="headerlink" title="8. 使用ENTRYPOINT (可选)"></a>8. 使用ENTRYPOINT (可选)</h3><p><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">ENTRYPOINT</a>指令并不是必须的，因为它会增加复杂度。<code>ENTRYPOINT</code>是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的Docker镜像。entrypoint.sh如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line"># $0 is a script name, </span><br><span class="line"># $1, $2, $3 etc are passed arguments</span><br><span class="line"># $1 is our command</span><br><span class="line">CMD=$1</span><br><span class="line"></span><br><span class="line">case &quot;$CMD&quot; in  </span><br><span class="line">  &quot;dev&quot; )</span><br><span class="line">    npm install</span><br><span class="line">    export NODE_ENV=development</span><br><span class="line">    exec npm run dev</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  &quot;start&quot; )</span><br><span class="line">    # we can modify files here, using ENV variables passed in </span><br><span class="line">    # &quot;docker create&quot; command. It can&apos;t be done during build process.</span><br><span class="line">    echo &quot;db: $DATABASE_ADDRESS&quot; &gt;&gt; /app/config.yml</span><br><span class="line">    export NODE_ENV=production</span><br><span class="line">    exec npm start</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">   * )</span><br><span class="line">    # Run custom command. Thanks to this line we can still use </span><br><span class="line">    # &quot;docker run our_image /bin/bash&quot; and it will work</span><br><span class="line">    exec $CMD $&#123;@:2&#125;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>示例Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>可以使用如下命令运行该镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 运行开发版本</span><br><span class="line">docker run our-app dev </span><br><span class="line"></span><br><span class="line"># 运行生产版本</span><br><span class="line">docker run our-app start </span><br><span class="line"></span><br><span class="line"># 运行bash</span><br><span class="line">docker run -it our-app /bin/bash</span><br></pre></td></tr></table></figure><h3 id="9-在entrypoint脚本中使用exec"><a href="#9-在entrypoint脚本中使用exec" class="headerlink" title="9. 在entrypoint脚本中使用exec"></a>9. 在entrypoint脚本中使用exec</h3><p>在前文的entrypoint脚本中，我使用了<code>exec</code>命令运行node应用。不使用<code>exec</code>的话，我们则不能顺利地关闭容器，因为SIGTERM信号会被bash脚本进程吞没。<code>exec</code>命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。</p><h3 id="10-COPY与ADD优先使用前者"><a href="#10-COPY与ADD优先使用前者" class="headerlink" title="10. COPY与ADD优先使用前者"></a>10. COPY与ADD优先使用前者</h3><p><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener">COPY</a>指令非常简单，仅用于将文件拷贝到镜像中。<a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener">ADD</a>相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="11-合理调整COPY与RUN的顺序"><a href="#11-合理调整COPY与RUN的顺序" class="headerlink" title="11. 合理调整COPY与RUN的顺序"></a>11. 合理调整COPY与RUN的顺序</h3><p>我们应该<strong>把变化最少的部分放在Dockerfile的前面</strong>，这样可以充分利用镜像缓存。</p><p>示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝<code>package.json</code>，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY package.json /app  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="12-设置默认的环境变量，映射端口和数据卷"><a href="#12-设置默认的环境变量，映射端口和数据卷" class="headerlink" title="12. 设置默认的环境变量，映射端口和数据卷"></a>12. 设置默认的环境变量，映射端口和数据卷</h3><p>运行Docker容器时很可能需要一些环境变量。在Dockerfile设置默认的环境变量是一种很好的方式。另外，我们应该在Dockerfile中设置映射端口和数据卷。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app</span><br><span class="line"></span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">ENV</a>指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARG</a>指令。</p><h3 id="13-使用LABEL设置镜像元数据"><a href="#13-使用LABEL设置镜像元数据" class="headerlink" title="13. 使用LABEL设置镜像元数据"></a>13. 使用LABEL设置镜像元数据</h3><p>使用<a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank" rel="noopener">LABEL</a>指令，可以为镜像设置元数据，例如<strong>镜像创建者</strong>或者<strong>镜像说明</strong>。旧版的Dockerfile语法使用<a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated" target="_blank" rel="noopener">MAINTAINER</a>指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="noopener">nvidia-docker</a>需要用到<code>com.nvidia.volumes.needed</code>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="14-添加HEALTHCHECK"><a href="#14-添加HEALTHCHECK" class="headerlink" title="14. 添加HEALTHCHECK"></a>14. 添加HEALTHCHECK</h3><p>运行容器时，可以指定<code>--restart always</code>选项。这样的话，容器崩溃时，Docker守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener">HEALTHCHECK</a>指令可以让Docker周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回0，否则返回1。对HEALTHCHECK感兴趣的话，可以参考<a href="https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/" target="_blank" rel="noopener">这篇博客</a>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app  </span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT  </span><br><span class="line">HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>当请求失败时，<code>curl --fail</code> 命令返回非0状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的D
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之Docker Swarm</title>
    <link href="http://blog.ozairs.com/Docker/Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Swarm/"/>
    <id>http://blog.ozairs.com/Docker/Docker三剑客之Docker-Swarm/</id>
    <published>2019-03-16T04:03:40.000Z</published>
    <updated>2019-03-16T04:18:41.275Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Docker Machine 创建 Docker 主机</strong></li><li><strong>Docker Swarm 配置集群节点</strong></li><li><strong>Docker Service 部署单个集群服务</strong></li><li><strong>Docker Stack 部署多个集群服务，以及 GUI 管理页面</strong></li><li><strong>docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令</strong></li></ul><p><a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Docker Swarm</a> 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（<code>docker swarm</code>），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-consul-docker-swarm/index.html" target="_blank" rel="noopener">Consul</a> 来进行服务发现配置了。</p><h2 id="1-Docker-Machine-创建-Docker-主机"><a href="#1-Docker-Machine-创建-Docker-主机" class="headerlink" title="1. Docker Machine 创建 Docker 主机"></a>1. Docker Machine 创建 Docker 主机</h2><p>在进行 Docker Swarm 配置之前，我们还需要说下 Docker 另外一个官方工具 Docker Machine（也是 Docker 三剑客之一），其作用就是快速帮助我们搭建 Docker 主机环境，比如我们要使用 Docker Swarm，就必须有很多的 Docker 主机来进行操作，Docker Machine 就是最理想的工具。</p><p>因为我是在 Mac OS 上进行操作的，并且 Docker for Mac 已经包含了 Docker Machine（<code>docker machine</code>），所以我不需要再额外进行安装了，如果使用 Linux 系统的话，安装也非常简单，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-machine</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><p>好了，我们先使用 Docker Machine 创建四个 Docker 主机，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox manager2 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker2</span><br><span class="line"></span><br><span class="line">Running pre-create checks...</span><br><span class="line">(worker1) No default Boot2Docker ISO found locally, downloading the latest release...</span><br><span class="line">(worker1) Latest release for github.com/boot2docker/boot2docker is v17.11.0-ce</span><br><span class="line">(worker1) Downloading /Users/xishuai/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v17.11.0-ce/boot2docker.iso...</span><br></pre></td></tr></table></figure><p>执行上面命令，你会发现速度巨慢（如上），原因是从 GitHub 上下载一个<code>boot2docker.iso</code>文件（国内网络没办法），怎么解决呢？很简单，我们使用翻X的浏览器手动下载<code>boot2docker.iso</code>文件，然后拷贝到对应目录下（我电脑的目录<code>/Users/xishuai/.docker/machine/cache/</code>），然后再执行上面的命令，发现速度快的一批。</p><p>我们可以查看下创建的 Docker 主机信息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">manager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.11.0-ce   </span><br><span class="line">manager2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.11.0-ce   </span><br><span class="line">worker1    -        virtualbox   Running   tcp://192.168.99.102:2376           v17.11.0-ce   </span><br><span class="line">worker2    -        virtualbox   Running   tcp://192.168.99.103:2376           v17.11.0-ce</span><br></pre></td></tr></table></figure><p>可以看到，我们创建了四个 Docker 主机（两个 Manager 和两个 Worker），我们还可以连接到任何一台服务器进行操作，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1</span><br><span class="line">                        ##         .</span><br><span class="line">                  ## ## ##        ==</span><br><span class="line">               ## ## ## ## ##    ===</span><br><span class="line">           /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===</span><br><span class="line">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~</span><br><span class="line">           \______ o           __/</span><br><span class="line">             \    \         __/</span><br><span class="line">              \____\_______/</span><br><span class="line"> _                 _   ____     _            _</span><br><span class="line">| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __</span><br><span class="line">| &apos;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &apos;__|</span><br><span class="line">| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |</span><br><span class="line">|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|</span><br><span class="line">Boot2Docker version 17.11.0-ce, build HEAD : e620608 - Tue Nov 21 18:11:40 UTC 2017</span><br><span class="line">Docker version 17.11.0-ce, build 1caf76c</span><br></pre></td></tr></table></figure><h2 id="2-Docker-Swarm-配置集群节点"><a href="#2-Docker-Swarm-配置集群节点" class="headerlink" title="2. Docker Swarm 配置集群节点"></a>2. Docker Swarm 配置集群节点</h2><p>我们执行下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 &quot;docker swarm init --advertise-addr 192.168.99.100&quot;</span><br><span class="line">Swarm initialized: current node (n0ub7dpn90rxjq97dr0g8we0w) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>上面是在<code>manager1</code>主机上，创建一个 Docker Swarm 管理节点（初始化集群的时候，会自动把当前节点设置为管理节点）。</p><p>接着，我们在<code>worker1</code>和<code>worker2</code>主机上，创建两个工作节点，并加入到集群中，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker1 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh worker2 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>还有另外一个<code>manager2</code>主机，需要配置为管理节点，我们需要先在<code>manager1</code>主机上，获取管理节点对应的<code>token</code>，然后再配置为管理节点，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 &quot;docker swarm join-token manager&quot;</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-0koz1b98sco8r5cn3g61eahnu 192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh manager2 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-0koz1b98sco8r5cn3g61eahnu 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>配置好之后，我们进入<code>manager1</code>主机内（上面的命令也可以在主机内执行），然后查看集群节点的信息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">n0ub7dpn90rxjq97dr0g8we0w *   manager1            Ready               Active              Leader</span><br><span class="line">t4cy67qp0bf2spgabsutwxnzt     manager2            Ready               Active              Reachable</span><br><span class="line">if0kmzp4ww3oy57y7cha7v36t     worker1             Ready               Active              </span><br><span class="line">jgg61cujzaeb3du5796fm0x2g     worker2             Ready               Active</span><br></pre></td></tr></table></figure><p><code>Leader</code>表示当然集群的头，<code>Reachable</code>可以理解为头的候选人，头一挂掉它就顶上去了。</p><hr><p>需要注意的是，我当天配置好之后，把所有的 Docker 主机都<code>stop</code>了，然后隔天重新<code>start</code>之后，出现了下面问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br><span class="line">Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It&apos;s possible that too few managers are online. Make sure more than half of the managers are online.</span><br></pre></td></tr></table></figure><p>好像是集群节点丢失了头，相关问题：<a href="https://q.cnblogs.com/q/96996/" target="_blank" rel="noopener">如何处理 docker swarm 集群”The swarm does not have a leader”问题</a>，按照文章进行解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --force-new-cluster</span><br><span class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.102 on eth1) - specify one with --advertise-addr</span><br><span class="line">$ docker swarm init --force-new-cluster --advertise-addr 192.168.99.102</span><br><span class="line">Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.</span><br><span class="line">$ docker node ls</span><br><span class="line">卡死</span><br><span class="line">$ docker-machine restart manager1 </span><br><span class="line">重启不了，一直转圈</span><br></pre></td></tr></table></figure><p>没办法，后来我只能删掉四个 Docker 主机，重新进行创建了。</p><h2 id="3-Docker-Service-部署单个集群服务"><a href="#3-Docker-Service-部署单个集群服务" class="headerlink" title="3. Docker Service 部署单个集群服务"></a>3. Docker Service 部署单个集群服务</h2><p>在部署集群服务之前，我们需要做些准备工作，因为 Docker 主机中没有配置 Docker 镜像加速地址，所以在拉取官方镜像的时候，肯定会非常慢，除了配置 Docker 镜像加速地址之外，我们还可以使用 Docker 私有镜像仓库，来解决这个问题。</p><p>参考文章：<a href="http://www.cnblogs.com/xishuai/p/ubuntu-docker-registry.html" target="_blank" rel="noopener">Ubuntu Docker Registry 搭建私有仓库</a></p><p>这边，我再简单说明下配置步骤，首先，在 Mac OS 上执行下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /Users/xishuai/Documents/Docker:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br><span class="line"></span><br><span class="line">$ docker tag nginx 192.168.99.1:5000/nginx:latest &amp;&amp; </span><br><span class="line">docker push 192.168.99.1:5000/nginx:latest &amp;&amp; </span><br><span class="line">docker pull 192.168.99.1:5000/nginx:latest</span><br><span class="line"></span><br><span class="line">$ curl http://192.168.99.1:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;nginx&quot;]&#125;</span><br></pre></td></tr></table></figure><p>我们在 Mac OS 上创建了一个私有仓库容器，并把<code>nginx</code>镜像放到私有仓库中，因为没有使用 Https，所以在拉取和推送镜像的时候，会报如下错误（Mac OS 和 Docker 主机都会报错）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull 192.168.99.1:5000/nginx:latest</span><br><span class="line">The push refers to a repository [192.168.99.1:5000/nginx]</span><br><span class="line">Get https://192.168.99.1:5000/v1/_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>解决方式，我们需要分别在四个 Docker 主机中添加配置（Docker for Mac 在管理界面配置即可），命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo touch /etc/docker/daemon.json &amp;&amp; </span><br><span class="line">sudo chmod 777 /etc/docker/daemon.json &amp;&amp; </span><br><span class="line">sudo echo &apos;&#123; &quot;insecure-registries&quot;:    [&quot;192.168.99.1:5000&quot;] &#125;&apos; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>然后重启四个 Docker 主机（Docker for Mac 也需要重启），命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine restart manager1 &amp;&amp; </span><br><span class="line">docker-machine restart manager2 &amp;&amp; </span><br><span class="line">docker-machine restart worker1 &amp;&amp; </span><br><span class="line">docker-machine restart worker2</span><br></pre></td></tr></table></figure><hr><p>上面比较啰嗦，我们接下来正式部署集群服务，还是拿<code>nginx</code>镜像做为示例，命令（<code>docker service create</code>命令<a href="http://www.yiibai.com/docker/service_create.html" target="_blank" rel="noopener">详细说明</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 4 -p 8088:80 --name nginx 192.168.99.1:5000/nginx:latest</span><br><span class="line">ap8h8srb8yh3mni0h2nz61njz</span><br><span class="line">overall progress: 4 out of 4 tasks </span><br><span class="line">1/4: running   [==================================================&gt;] </span><br><span class="line">2/4: running   [==================================================&gt;] </span><br><span class="line">3/4: running   [==================================================&gt;] </span><br><span class="line">4/4: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>--replicas 4</code>表示创建服务的实例个数（默认是一个），啥意思？比如4，就是在四个 Docker 主机上，分别创建一个<code>nginx</code>服务，如果是3，那就是三个 Docker 主机，或者你可以理解为 Docker 主机的个数，另外，<code>REPLICAS</code>会有进度显示，并且执行是异步的。</p><p>我们也可以手动设置实例个数，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale nginx=4</span><br></pre></td></tr></table></figure><p>部署好服务后，我们就可以进行查看了，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                            PORTS</span><br><span class="line">ap8h8srb8yh3        nginx               replicated          4/4                 192.168.99.1:5000/nginx:latest   *:8080-&gt;8080/tcp</span><br><span class="line"></span><br><span class="line">$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                            NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">l2rdrwzs5zog        nginx.1             192.168.99.1:5000/nginx:latest   manager1            Running             Running about a minute ago                       </span><br><span class="line">vsfczzbwanx3        nginx.2             192.168.99.1:5000/nginx:latest   manager2            Running             Running about a minute ago                           </span><br><span class="line">qtbgw5h6dsi9        nginx.3             192.168.99.1:5000/nginx:latest   worker              Running             Running about a minute ago                           </span><br><span class="line">za2ejnvb3n6z        nginx.4             192.168.99.1:5000/nginx:latest   worker2             Running             Running about a minute ago</span><br></pre></td></tr></table></figure><p>我们任意使用四个 Docker 主机中的一个 IP 地址，浏览器打开：<a href="http://192.168.99.100:8088/" target="_blank" rel="noopener">http://192.168.99.100:8088/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/1.png" alt=""></p><h2 id="4-Docker-Stack-部署多个集群服务，以及-GUI-管理页面"><a href="#4-Docker-Stack-部署多个集群服务，以及-GUI-管理页面" class="headerlink" title="4. Docker Stack 部署多个集群服务，以及 GUI 管理页面"></a>4. Docker Stack 部署多个集群服务，以及 GUI 管理页面</h2><p><code>docker service</code>部署的是单个服务，我们可以使用<code>docker stack</code>进行多服务编排部署，使用的同样是<code>docker-compose.yml</code>配置文件，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: 192.168.99.1:5000/nginx:latest</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 4</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: 192.168.99.1:5000/dockersamples/visualizer:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  portainer:</span><br><span class="line">    image: 192.168.99.1:5000/portainer/portainer:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><p>如上所示，我们总共需要部署三个服务，出了<code>nginx</code>服务作为示例之外，<code>visualizer</code>（<a href="https://github.com/dockersamples/docker-swarm-visualizer" target="_blank" rel="noopener">官方地址</a>）和<code>portainer</code>（<a href="https://portainer.io/" target="_blank" rel="noopener">官方地址</a>）都是集群 GUI 管理服务。</p><p>部署命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml deploy-demo</span><br><span class="line">Creating service deploy-demo_nginx</span><br><span class="line">Creating service deploy-demo_visualizer</span><br><span class="line">Creating service deploy-demo_portainer</span><br></pre></td></tr></table></figure><p>部署成功之后，我们可以查看具体详情，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ls</span><br><span class="line">NAME                SERVICES</span><br><span class="line">deploy-demo         3</span><br></pre></td></tr></table></figure><p>查看<code>visualizer</code>GUI 集群管理，浏览器打开：<a href="http://192.168.99.100:8080/" target="_blank" rel="noopener">http://192.168.99.100:8080/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/2.png" alt=""></p><p>查看<code>portainer</code>GUI 集群管理，需要先配置账号信息，浏览器打开：<a href="http://192.168.99.100:9000/" target="_blank" rel="noopener">http://192.168.99.100:9000/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/3.gif" alt=""></p><p>可以看到，<code>portainer</code>比<code>visualizer</code>强大太多了，甚至我们所有的操作都可以在<code>portainer</code>上完成。</p><h2 id="5-docker-machine、docker-swarm、docker-node、docker-service-和-docker-stack-常用命令"><a href="#5-docker-machine、docker-swarm、docker-node、docker-service-和-docker-stack-常用命令" class="headerlink" title="5. docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令"></a>5. docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令</h2><h3 id="docker-machine-常用命令"><a href="#docker-machine-常用命令" class="headerlink" title="docker-machine 常用命令"></a>docker-machine 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker-machine create</td><td>创建一个 Docker 主机（常用<code>-d virtualbox</code>）</td></tr><tr><td>docker-machine ls</td><td>查看所有的 Docker 主机</td></tr><tr><td>docker-machine ssh</td><td>SSH 到主机上执行命令</td></tr><tr><td>docker-machine env</td><td>显示连接到某个主机需要的环境变量</td></tr><tr><td>docker-machine inspect</td><td>输出主机更多信息</td></tr><tr><td>docker-machine kill</td><td>停止某个主机</td></tr><tr><td>docker-machine restart</td><td>重启某台主机</td></tr><tr><td>docker-machine rm</td><td>删除某台主机</td></tr><tr><td>docker-machine scp</td><td>在主机之间复制文件</td></tr><tr><td>docker-machine start</td><td>启动一个主机</td></tr><tr><td>docker-machine status</td><td>查看主机状态</td></tr><tr><td>docker-machine stop</td><td>停止一个主机</td></tr></tbody></table><h3 id="docker-swarm-常用命令"><a href="#docker-swarm-常用命令" class="headerlink" title="docker swarm 常用命令"></a>docker swarm 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker swarm init</td><td>初始化集群</td></tr><tr><td>docker swarm join-token worker</td><td>查看工作节点的 token</td></tr><tr><td>docker swarm join-token manager</td><td>查看管理节点的 token</td></tr><tr><td>docker swarm join</td><td>加入集群中</td></tr></tbody></table><h3 id="docker-node-常用命令"><a href="#docker-node-常用命令" class="headerlink" title="docker node 常用命令"></a>docker node 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker node ls</td><td>查看所有集群节点</td></tr><tr><td>docker node rm</td><td>删除某个节点（<code>-f</code>强制删除）</td></tr><tr><td>docker node inspect</td><td>查看节点详情</td></tr><tr><td>docker node demote</td><td>节点降级，由管理节点降级为工作节点</td></tr><tr><td>docker node promote</td><td>节点升级，由工作节点升级为管理节点</td></tr><tr><td>docker node update</td><td>更新节点</td></tr><tr><td>docker node ps</td><td>查看节点中的 Task 任务</td></tr></tbody></table><h3 id="docker-service-常用命令"><a href="#docker-service-常用命令" class="headerlink" title="docker service 常用命令"></a>docker service 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker service create</td><td>部署服务</td></tr><tr><td>docker service inspect</td><td>查看服务详情</td></tr><tr><td>docker service logs</td><td>产看某个服务日志</td></tr><tr><td>docker service ls</td><td>查看所有服务详情</td></tr><tr><td>docker service rm</td><td>删除某个服务（<code>-f</code>强制删除）</td></tr><tr><td>docker service scale</td><td>设置某个服务个数</td></tr><tr><td>docker service update</td><td>更新某个服务</td></tr></tbody></table><h3 id="docker-stack-常用命令"><a href="#docker-stack-常用命令" class="headerlink" title="docker stack 常用命令"></a>docker stack 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker stack deploy</td><td>部署新的堆栈或更新现有堆栈</td></tr><tr><td>docker stack ls</td><td>列出现有堆栈</td></tr><tr><td>docker stack ps</td><td>列出堆栈中的任务</td></tr><tr><td>docker stack rm</td><td>删除堆栈</td></tr><tr><td>docker stack services</td><td>列出堆栈中的服务</td></tr><tr><td>docker stack down</td><td>移除某个堆栈（不会删除数据）</td></tr></tbody></table><p>参考资料：</p><ul><li><a href="https://docs.docker.com/get-started/part4/" target="_blank" rel="noopener">Get Started, Part 4: Swarms</a></li><li><a href="https://github.com/yeasy/docker_practice/tree/master/swarm" target="_blank" rel="noopener">Docker 三剑客之 Docker Swarm</a></li><li><a href="http://www.jianshu.com/p/9eb9995884a5" target="_blank" rel="noopener">Docker Swarm 入门一篇文章就够了</a></li><li><a href="http://www.huangxiaobai.com/archives/2135" target="_blank" rel="noopener">Docker 的命令之集群节点管理 Swarm node</a></li><li><a href="http://www.yiibai.com/docker/service.html" target="_blank" rel="noopener">docker service 命令</a></li><li><a href="https://www.centos.bz/2017/01/docker-service-create/" target="_blank" rel="noopener">Docker 命令行参考(37) – docker service create 创建一个服务</a></li><li><a href="http://www.cnblogs.com/sparkdev/p/7044950.html" target="_blank" rel="noopener">Docker Machine 是什么？</a></li><li><a href="http://blog.csdn.net/wanglei_storage/article/details/77508620" target="_blank" rel="noopener">docker swarm 学习命令整理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Docker Machine 创建 Docker 主机&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Swarm 配置集群节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Service 部署单个集群服务
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm入门一篇文章就够了</title>
    <link href="http://blog.ozairs.com/Docker/Docker-Swarm%E5%85%A5%E9%97%A8%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://blog.ozairs.com/Docker/Docker-Swarm入门一篇文章就够了/</id>
    <published>2019-03-16T04:01:02.000Z</published>
    <updated>2019-03-16T04:18:27.583Z</updated>
    
    <content type="html"><![CDATA[<p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><h2 id="1-Swarm-认识"><a href="#1-Swarm-认识" class="headerlink" title="1. Swarm 认识"></a>1. Swarm 认识</h2><p>Swarm 是目前 Docker 官方唯一指定（绑定）的集群管理工具。Docker 1.12  内嵌了 swarm mode 集群管理模式。</p><p>为了方便演示跨主机网络，我们需要用到一个工具——Docker Machine，这个工具与 Docker Compose、Docker Swarm 并称 Docker 三剑客，下面我们来看看如何安装 Docker Machine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.9.0-rc2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">    chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">    sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><p>安装过程和 Docker Compose 非常类似。现在 Docker 三剑客已经全部到齐了。<br> 在开始之前，我们需要了解一些基本概念，有关集群的 Docker 命令如下：</p><ul><li>docker swarm：集群管理，子命令有 init, join,join-token, leave, update</li><li>docker node：节点管理，子命令有 demote, inspect,ls, promote, rm, ps, update</li><li>docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update</li><li>docker stack/deploy：试验特性，用于多应用部署，等正式版加进来再说。</li></ul><hr><h2 id="2-创建集群"><a href="#2-创建集群" class="headerlink" title="2. 创建集群"></a>2. 创建集群</h2><p>首先使用 Docker Machine 创建一个虚拟机作为 manger 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox manager1                                    </span><br><span class="line">Running pre-create checks...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">Creating machine...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">(manager1) Copying /home/zuolan/.docker/machine/cache/boot2docker.iso to /home/zuolan/.docker/machine/machines/manager1/boot2docker.iso...</span><br><span class="line">(manager1) Creating VirtualBox VM...</span><br><span class="line">(manager1) Creating SSH key...</span><br><span class="line">(manager1) Starting the VM...</span><br><span class="line">(manager1) Check network to re-create if needed...</span><br><span class="line">(manager1) Found a new host-only adapter: &quot;vboxnet0&quot;</span><br><span class="line">(manager1) Waiting for an IP...</span><br><span class="line">Waiting for machine to be running, this may take a few minutes...</span><br><span class="line">Detecting operating system of created instance...</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Provisioning with boot2docker...</span><br><span class="line">Copying certs to the local machine directory...</span><br><span class="line">Copying certs to the remote machine...</span><br><span class="line">Setting Docker configuration on the remote daemon...</span><br><span class="line">Checking connection to Docker...</span><br><span class="line">Docker is up and running!</span><br><span class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</span><br></pre></td></tr></table></figure><p>查看虚拟机的环境变量等信息，包括虚拟机的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  docker-machine env manager1</span><br><span class="line">export DOCKER_TLS_VERIFY=&quot;1&quot;</span><br><span class="line">export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH=&quot;/home/zuolan/.docker/machine/machines/manager1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME=&quot;manager1&quot;</span><br><span class="line"># Run this command to configure your shell: </span><br><span class="line"># eval $(docker-machine env manager1)</span><br></pre></td></tr></table></figure><p>然后再创建一个节点作为 work 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox worker1</span><br></pre></td></tr></table></figure><p>现在我们有了两个虚拟主机，使用 Machine 的命令可以查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls                             </span><br><span class="line">NAME     ACTIVE   DRIVER       STATE    URL                        SWARM  DOCKER   ERRORS</span><br><span class="line">manager1   -      virtualbox   Running  tcp://192.168.99.100:2376         v1.12.3   </span><br><span class="line">worker1    -      virtualbox   Running  tcp://192.168.99.101:2376         v1.12.3</span><br></pre></td></tr></table></figure><p>但是目前这两台虚拟主机并没有什么联系，为了把它们联系起来，我们需要 Swarm 登场了。<br> 因为我们使用的是 Docker Machine 创建的虚拟机，因此可以使用 docker-machine ssh 命令来操作虚拟机，在实际生产环境中，并不需要像下面那样操作，只需要执行 docker swarm 即可。</p><p>把 manager1 加入集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100</span><br><span class="line">Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>用 –listen-addr 指定监听的 ip 与端口，实际的 Swarm 命令格式如下，本例使用 Docker Machine 来连接虚拟机而已：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --listen-addr &lt;MANAGER-IP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>接下来，再把 work1 加入集群中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker1 docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>上面 join 命令中可以添加 –listen-addr $WORKER1_IP:2377 作为监听准备，因为有时候可能会遇到把一个 work 节点提升为 manger 节点的可能，当然本例子没有这个打算就不添加这个参数了。</p><blockquote><p>注意：如果你在新建集群时遇到双网卡情况，可以指定使用哪个 IP，例如上面的例子会有可能遇到下面的错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr $MANAGER1_IP:2377</span><br><span class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.100 on eth1) - specify one with --advertise-addr</span><br><span class="line">exit status 1</span><br></pre></td></tr></table></figure><p>发生错误的原因是因为有两个 IP 地址，而 Swarm 不知道用户想使用哪个，因此要指定 IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --advertise-addr 192.168.99.100 --listen-addr 192.168.99.100:2377 </span><br><span class="line">Swarm initialized: current node (ahvwxicunjd0z8g0eeosjztjx) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>集群初始化成功。</p><p>现在我们新建了一个有两个节点的“集群”，现在进入其中一个管理节点使用 docker node 命令来查看节点信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker node ls</span><br><span class="line">ID                       HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">23lkbq7uovqsg550qfzup59t6 *  manager1    Ready      Active         Leader</span><br><span class="line">dqb3fim8zvcob8sycri3hy98a    worker1     Ready      Active</span><br></pre></td></tr></table></figure><p>现在每个节点都归属于 Swarm，并都处在了待机状态。Manager1 是领导者，work1 是工人。</p><p>现在，我们继续新建虚拟机 manger2、worker2、worker3，现在已经有五个虚拟机了，使用 docker-machine ls 来查看虚拟机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME     ACTIVE    DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS</span><br><span class="line">manager1   -       virtualbox   Running   tcp://192.168.99.100:2376           v1.12.3   </span><br><span class="line">manager2   -       virtualbox   Running   tcp://192.168.99.105:2376           v1.12.3   </span><br><span class="line">worker1    -       virtualbox   Running   tcp://192.168.99.102:2376           v1.12.3   </span><br><span class="line">worker2    -       virtualbox   Running   tcp://192.168.99.103:2376           v1.12.3   </span><br><span class="line">worker3    -       virtualbox   Running   tcp://192.168.99.104:2376           v1.12.3</span><br></pre></td></tr></table></figure><p>然后我们把剩余的虚拟机也加到集群中。</p><ul><li>添加 worker2 到集群中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>添加 worker3 到集群中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker3 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>添加 manager2 到集群中：<br> 先从 manager1 中获取 manager 的 token：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm join-token manager</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>然后添加 manager2 到集群中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>现在再来查看集群信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS   AVAILABILITY   MANAGER STATUS</span><br><span class="line">16w80jnqy2k30yez4wbbaz1l8     worker1     Ready     Active        </span><br><span class="line">2gkwhzakejj72n5xoxruet71z     worker2     Ready     Active        </span><br><span class="line">35kutfyn1ratch55fn7j3fs4x     worker3     Ready     Active        </span><br><span class="line">a9r21g5iq1u6h31myprfwl8ln *   manager2    Ready     Active        Reachable</span><br><span class="line">dpo7snxbz2a0dxvx6mf19p35z     manager1    Ready     Active        Leader</span><br></pre></td></tr></table></figure><h2 id="3-建立跨主机网络"><a href="#3-建立跨主机网络" class="headerlink" title="3. 建立跨主机网络"></a>3. 建立跨主机网络</h2><p>为了演示更清晰，下面我们把宿主机也加入到集群之中，这样我们使用 Docker 命令操作会清晰很多。<br> 直接在本地执行加入集群命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join \           </span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>现在我们有三台 manager，三台 worker。其中一台是宿主机，五台虚拟机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                          HOSTNAME    STATUS    AVAILABILITY  MANAGER STATUS</span><br><span class="line">6z2rpk1t4xucffzlr2rpqb8u3    worker3     Ready     Active        </span><br><span class="line">7qbr0xd747qena4awx8bx101s *  user-pc     Ready     Active         Reachable</span><br><span class="line">9v93sav79jqrg0c7051rcxxev    manager2    Ready     Active         Reachable</span><br><span class="line">a1ner3zxj3ubsiw4l3p28wrkj    worker1     Ready     Active        </span><br><span class="line">a5w7h8j83i11qqi4vlu948mad    worker2     Ready     Active        </span><br><span class="line">d4h7vuekklpd6189fcudpfy18    manager1    Ready     Active          Leader</span><br></pre></td></tr></table></figure><p>查看网络状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME            DRIVER          SCOPE</span><br><span class="line">764ff31881e5        bridge          bridge          local                  </span><br><span class="line">fbd9a977aa03        host            host            local               </span><br><span class="line">6p6xlousvsy2        ingress         overlay         swarm            </span><br><span class="line">e81af24d643d        none            null            local</span><br></pre></td></tr></table></figure><p>可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create --driver overlay swarm_test</span><br><span class="line">4dm8cy9y5delvs5vd0ghdd89s</span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME                DRIVER              SCOPE</span><br><span class="line">764ff31881e5        bridge              bridge              local</span><br><span class="line">fbd9a977aa03        host                host                local</span><br><span class="line">6p6xlousvsy2        ingress             overlay             swarm</span><br><span class="line">e81af24d643d        none                null                local</span><br><span class="line">4dm8cy9y5del        swarm_test          overlay             swarm</span><br></pre></td></tr></table></figure><p>这样一个跨主机网络就搭建好了，但是现在这个网络只是处于待机状态，下一小节我们会在这个网络上部署应用。</p><h2 id="4-在跨主机网络上部署应用"><a href="#4-在跨主机网络上部署应用" class="headerlink" title="4. 在跨主机网络上部署应用"></a>4. 在跨主机网络上部署应用</h2><p>首先我们上面创建的节点都是没有镜像的，因此我们要逐一 pull 镜像到节点中，这里我们使用前面搭建的私有仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker pull reg.example.com/library/nginx:alpine     </span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh manager2 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker1 docker pull reg.example.com/library/nginx:alpine </span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker2 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker3 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><p>上面使用 docker pull 分别在五个虚拟机节点拉取 nginx:alpine 镜像。接下来我们要在五个节点部署一组 Nginx 服务。</p><p>部署的服务使用 swarm_test 跨主机网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld --network=swarm_test nginx:alpine</span><br><span class="line">5gz0h2s5agh2d2libvzq6bhgs</span><br></pre></td></tr></table></figure><p>查看服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">5gz0h2s5agh2  helloworld  0/2       nginx:alpine</span><br></pre></td></tr></table></figure><p>查看 helloworld 服务详情（为了方便阅读，已调整输出内容）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME          IMAGE         NODE      DESIRED STATE   CURRENT STATE              ERROR</span><br><span class="line">ay081uome3   helloworld.1  nginx:alpine  manager1  Running         Preparing 2 seconds ago  </span><br><span class="line">16cvore0c96  helloworld.2  nginx:alpine  worker2   Running         Preparing 2 seconds ago</span><br></pre></td></tr></table></figure><p>可以看到两个实例分别运行在两个节点上。</p><p>进入两个节点，查看服务状态（为了方便阅读，已调整输出内容）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED        STATUS         PORTS            NAMES</span><br><span class="line">119f787622c2   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago  Up 4 minutes   80/tcp, 443/tcp  hello ...</span><br><span class="line">$ docker-machine ssh worker2 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED         STATUS        PORTS             NAMES</span><br><span class="line">5db707401a06   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago   Up 4 minutes  80/tcp, 443/tcp   hello ...</span><br></pre></td></tr></table></figure><p>上面输出做了调整，实际的 NAMES 值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br></pre></td></tr></table></figure><p>记住上面这两个实例的名称。现在我们来看这两个跨主机的容器是否能互通：<br> 首先使用 Machine 进入 manager1 节点，然后使用 docker exec -i 命令进入 helloworld.1 容器中 ping 运行在 worker2 节点的 helloworld.2 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker exec -i helloworld.1.ay081uome3eejeg4mspa8pdlx \</span><br><span class="line">    ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (10.0.0.4): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.4: seq=0 ttl=64 time=0.591 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=1 ttl=64 time=0.594 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=2 ttl=64 time=0.624 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=3 ttl=64 time=0.612 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>然后使用 Machine 进入 worker2 节点，然后使用 docker exec -i 命令进入 helloworld.2 容器中 ping 运行在 manager1 节点的 helloworld.1 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker exec -i helloworld.2.16cvore0c96rby1vp0sny3mvt \</span><br><span class="line">    ping helloworld.1.ay081uome3eejeg4mspa8pdlx </span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (10.0.0.3): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.466 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=1 ttl=64 time=0.465 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=2 ttl=64 time=0.548 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=3 ttl=64 time=0.689 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>可以看到这两个跨主机的服务集群里面各个容器是可以互相连接的。</p><p>为了体现 Swarm 集群的优势，我们可以使用虚拟机的 ping 命令来测试对方虚拟机内的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 ping helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (221.179.46.190): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.190: seq=0 ttl=63 time=48.651 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=1 ttl=63 time=63.239 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=2 ttl=63 time=47.686 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=3 ttl=63 time=61.232 ms</span><br><span class="line">^C</span><br><span class="line">$ docker-machine ssh manager1 ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (221.179.46.194): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.194: seq=0 ttl=63 time=30.150 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=1 ttl=63 time=54.455 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=2 ttl=63 time=73.862 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=3 ttl=63 time=53.171 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>上面我们使用了虚拟机内部的 ping 去测试容器的延迟，可以看到延迟明显比集群内部的 ping 值要高。</p><h2 id="5-Swarm-集群负载"><a href="#5-Swarm-集群负载" class="headerlink" title="5. Swarm 集群负载"></a>5. Swarm 集群负载</h2><p>现在我们已经学会了 Swarm 集群的部署方法，现在来搭建一个可访问的 Nginx 集群吧。体验最新版的 Swarm 所提供的自动服务发现与集群负载功能。<br> 首先删掉上一节我们启动的 helloworld 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service rm helloworld                                 </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>然后在新建一个服务，提供端口映射参数，使得外界可以访问这些 Nginx 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld -p 7080:80 --network=swarm_test nginx:alpine</span><br><span class="line">9gfziifbii7a6zdqt56kocyun</span><br></pre></td></tr></table></figure><p>查看服务运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls                                                                                </span><br><span class="line">ID           NAME         REPLICAS     IMAGE           COMMAND</span><br><span class="line">9gfziifbii7a  helloworld     2/2        nginx:alpine</span><br></pre></td></tr></table></figure><p>不知你有没有发现，虽然我们使用 –replicas 参数的值都是一样的，但是上一节中获取服务状态时，REPLICAS 返回的是 0/2，现在的 REPLICAS 返回的是 2/2。<br> 同样使用 docker service ps 查看服务详细状态时（下面输出已经手动调整为更易读的格式），可以看到实例的 CURRENT STATE 中是 Running 状态的，而上一节中的 CURRENT STATE 中全部是处于 Preparing 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME      IMAGE     NODE    DESIRED STATE   CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...   helloworld.1  nginx:alpine  user-pc    Running         Running 13 seconds ago  </span><br><span class="line">7acmhj0u...   helloworld.2  nginx:alpine  worker2    Running         Running 6 seconds ago</span><br></pre></td></tr></table></figure><p>这就涉及到 Swarm 内置的发现机制了，目前 Docker 1.12 中 Swarm 已经内置了服务发现工具，我们不再需要像以前使用 Etcd 或者 Consul 这些工具来配置服务发现。对于一个容器来说如果没有外部通信但又是运行中的状态会被服务发现工具认为是 Preparing 状态，本小节例子中因为映射了端口，因此有了 Running 状态。<br> 现在我们来看 Swarm 另一个有趣的功能，当我们杀死其中一个节点时，会发生什么。<br> 首先 kill 掉 worker2 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker kill helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br><span class="line">helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br></pre></td></tr></table></figure><p>稍等几秒，再来看服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME          IMAGE     NODE   DESIRED STATE  CURRENT STATE   ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1     nginx:alpine  zuolan-pc  Running       Running 19 minutes ago  </span><br><span class="line">8f866igpl...  helloworld.2     nginx:alpine  manager1  Running       Running 4 seconds ago   </span><br><span class="line">7acmhj0u...   \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 seconds ago  ...exit...</span><br><span class="line">$ docker service ls           </span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">9gfziifbii7a  helloworld  2/2       nginx:alpine</span><br></pre></td></tr></table></figure><p>可以看到即使我们 kill 掉其中一个实例，Swarm 也会迅速把停止的容器撤下来，同时在节点中启动一个新的实例顶上来。这样服务依旧还是两个实例在运行。<br> 此时如果你想添加更多实例可以使用 scale 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale helloworld=3</span><br><span class="line">helloworld scaled to 3</span><br></pre></td></tr></table></figure><p>查看服务详情，可以看到有三个实例启动了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME        IMAGE      NODE   DESIRED STATE  CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1    nginx:alpine  user-pc   Running        Running 30 minutes ago  8f866igpl...  helloworld.2    nginx:alpine  manager1  Running        Running 11 minutes ago  7acmhj0u...  \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 minutes ago   exit137</span><br><span class="line">1vexr1jm...  helloworld.3    nginx:alpine   worker2   Running       Running 4 seconds ago</span><br></pre></td></tr></table></figure><p>现在如果想减少实例数量，一样可以使用 scale 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale helloworld=2</span><br><span class="line">helloworld scaled to 2</span><br></pre></td></tr></table></figure><hr><p>至此，Swarm的主要用法都已经介绍完了，主要讲述了 Swarm 集群网络的创建与部署。介绍了 Swarm 的常规应用，包括 Swarm 的服务发现、负载均衡等，然后使用 Swarm 来配置跨主机容器网络，并在上面部署应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Compose入门</title>
    <link href="http://blog.ozairs.com/Docker/Docker-Compose%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.ozairs.com/Docker/Docker-Compose入门/</id>
    <published>2019-03-16T03:32:37.000Z</published>
    <updated>2019-03-16T04:18:55.022Z</updated>
    
    <content type="html"><![CDATA[<p>Compose 是一个用户定义和运行多个容器的 Docker 应用程序。在 Compose 中你可以使用 YAML 文件来配置你的应用服务。然后，只需要一个简单的命令，就可以创建并启动你配置的所有服务。</p><p>使用 Compose 基本会有如下三步流程：</p><ol><li>在 Dockfile 中定义你的应用环境，使其可以在任何地方复制。</li><li>在 docker-compose.yml 中定义组成应用程序的服务，以便它们可以在隔离的环境中一起运行。</li><li>最后，运行<code>dcoker-compose up</code>，Compose 将启动并运行整个应用程序。</li></ol><h2 id="开始使用-Docker-Compose"><a href="#开始使用-Docker-Compose" class="headerlink" title="开始使用 Docker Compose"></a>开始使用 Docker Compose</h2><p>这里面将会在 Docker Compose 中构建一个简单的 Python 程序。应用程序将使用 Flask 框架，并在 Redis 中维护一个计数器。</p><p><strong>先决条件</strong></p><p>确认你已经安装了 Docker Engine 与 Docker Compose。你不需要安装 Python 或者 Redis，这两个都会在 Docker <a href="https://www.baidu.com/s?wd=%E9%95%9C%E5%83%8F&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">镜像</a>中提供。</p><h3 id="第一步：定义应用依赖"><a href="#第一步：定义应用依赖" class="headerlink" title="第一步：定义应用依赖"></a>第一步：定义应用依赖</h3><ol><li><p>为项目创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir composetest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> composetest12</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个名为 app.py 的文件，并将如下内容粘贴进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">   retries = <span class="number">5</span></span><br><span class="line">   <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">       <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">           <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">               <span class="keyword">raise</span> exc</span><br><span class="line">           retries -= <span class="number">1</span></span><br><span class="line">           time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">   count = get_hit_count()</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)<span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><p>在这个例子中，redis 就是应用网络中 redis 容器的主机名。我们使用 Redis 的默认端口 6379。</p></li><li><p>在你的项目路径下创建另外一个叫做 requirements.txt 的文件，并将如下内容粘贴进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis12</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二步：创建-Dockerfile"><a href="#第二步：创建-Dockerfile" class="headerlink" title="第二步：创建 Dockerfile"></a>第二步：创建 Dockerfile</h3><p>在这一步中，你需要编写一个 Dockerfile 来构建一个 Docker 镜像。这个镜像包含 Python 应用的所有依赖，也包含 Python 其本身。</p><p>在你的项目路径下创建一个 Dockerfile 文件，并将如下内容粘贴进去：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.4</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="bash">WORKDIR /code</span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]12345</span></span><br></pre></td></tr></table></figure><p>这会告诉容器：</p><ul><li>构建一个基于 Python 3.4 的镜像</li><li>把当前目录添加到镜像中的 /code 路径下</li><li>把工作路径设置成 /code</li><li>安装 Python 依赖</li><li>设置容器的默认命令为 <code>python app.py</code></li></ul><p>有关如何编写 Dockerfiles 的更多信息，请参考 <a href="https://docs.docker.com/engine/tutorials/dockerimages/#building-an-image-from-a-dockerfile" target="_blank" rel="noopener">Docker user guide</a> 与 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a>。</p><h3 id="第三步：在-Compose-文件中定义一个服务"><a href="#第三步：在-Compose-文件中定义一个服务" class="headerlink" title="第三步：在 Compose 文件中定义一个服务"></a>第三步：在 Compose 文件中定义一个服务</h3><p>在工作路径下创建一个叫做 docker-compose.yml 并粘贴如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>这个 Compose 文件中定义了两个服务 web 与 redis。此 Web 服务：</p><ul><li>使用当前目录 Dockerfile 构建出来的镜像</li><li>将容器上暴露的5000端口转发到主机的5000端口。我们使用 Flask Web 服务器的默认端口 5000。</li></ul><p>而 Redis 服务使用从 Docker Hub 注册表中拉取的公有镜像。</p><h3 id="第四步：在-Compose-中构建并运行你的应用"><a href="#第四步：在-Compose-中构建并运行你的应用" class="headerlink" title="第四步：在 Compose 中构建并运行你的应用"></a>第四步：在 Compose 中构建并运行你的应用</h3><ol><li><p>在你的项目路径下通过 <code>docker-compose up</code> 命令启动你的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network "composetest_default" with the default driver</span><br><span class="line">Creating composetest_web_1 ...</span><br><span class="line">Creating composetest_redis_1 ...</span><br><span class="line">Creating composetest_web_1</span><br><span class="line">Creating composetest_redis_1 ... done</span><br><span class="line">Attaching to composetest_web_1, composetest_redis_1</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">web_1    |  * Restarting with stat</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">web_1    |  * Debugger is active!</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # Server initialized</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">web_1    |  * Debugger PIN: 330-787-903</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections12345678910111213141516171819</span><br></pre></td></tr></table></figure></li></ol><p>Compose 拉取一个 Redis 镜像，以你自己的代码构建一个镜像，并启动你定义的服务。在这种情况下，代码在构建时静态拷贝到镜像中。</p><ol><li><p>在浏览器中输入 <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000</a> 查看应用的运行情况。</p><p>你将在你的浏览器中看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I have been seen 1 times.1</span><br></pre></td></tr></table></figure></li><li><p>刷新一下浏览器，数值将会增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I have been seen 2 times.1</span><br></pre></td></tr></table></figure></li><li><p>切换到另外一个容器，输入 <code>docker image ls</code> 列举所有本地镜像。</p><p>镜像列表中将返回 reidis 与 web。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">composetest_web         latest              e2c21aa48cc1        4 minutes ago       93.8MB</span><br><span class="line">python                  3.4-alpine          84e6077c7ab6        7 days ago          82.5MB</span><br><span class="line">redis                   alpine              9d8fa9aa0e5b        3 weeks ago         27.5MB12345</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>docker inspect &lt;tag or id&gt;</code> 来检查镜像。</p></li><li><p>停止镜像，即可以在你的项目路径下使用 <code>docker-compose down</code> ，也可以在原始的终端上使用 CTRL+C 停止当前启动着的应用。</p></li></ol><h3 id="第五步：编辑-Compose-文件添加一个绑定挂载"><a href="#第五步：编辑-Compose-文件添加一个绑定挂载" class="headerlink" title="第五步：编辑 Compose 文件添加一个绑定挂载"></a>第五步：编辑 Compose 文件添加一个绑定挂载</h3><p>在你的项目路径下编辑 docker-compose.yml 为 web 服务添加一个绑定挂载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">.:/code</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>这个新的 volumes 键将当前路径（项目路径）与容器中的 /code 路径挂载到一起，允许你及时修改代码而不用重新构建镜像。</p><h3 id="第六步：重新构建并在-Compose-中运行应用"><a href="#第六步：重新构建并在-Compose-中运行应用" class="headerlink" title="第六步：重新构建并在 Compose 中运行应用"></a>第六步：重新构建并在 Compose 中运行应用</h3><p>在你的项目路径下，输入 <code>docker-compose up</code> 命令使用更新后的 Compose 文件构建应用并启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network "composetest_default" with the default driver</span><br><span class="line">Creating composetest_web_1 ...</span><br><span class="line">Creating composetest_redis_1 ...</span><br><span class="line">Creating composetest_web_1</span><br><span class="line">Creating composetest_redis_1 ... done</span><br><span class="line">Attaching to composetest_web_1, composetest_redis_1</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">...123456789</span><br></pre></td></tr></table></figure><p>再次检查 Web 浏览器中的 Hello World 消息，然后刷新以查看计数增量。</p><h3 id="第七步：更新应用程序"><a href="#第七步：更新应用程序" class="headerlink" title="第七步：更新应用程序"></a>第七步：更新应用程序</h3><p>因为应用程序的代码通过 volume 挂载到容器中，你可以更改其代码并立即查看更改，而不必重新生成镜像。</p><ol><li><p>修改 app.py 中的欢迎语并保存。例如，将 Hello World！ 改成 Hello from Docker!:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">'Hello from Docker! I have been seen &#123;&#125; times.\n'</span>.format(count)<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>刷新你的浏览器。欢迎语已经更新，而计数器仍然在增长。</p></li></ol><h3 id="第八步：尝试一些其它命令"><a href="#第八步：尝试一些其它命令" class="headerlink" title="第八步：尝试一些其它命令"></a>第八步：尝试一些其它命令</h3><p>如果你希望你的应用程序在后台运行，你可以将 <code>-d</code> 标记传递给 <code>docker-compose up</code> 并使用 <code>docker-compose ps</code> 来查看当前运行的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></span><br><span class="line">Starting composetest_redis_1...</span><br><span class="line">Starting composetest_web_1...</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br><span class="line">Name                 Command            State       Ports</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">composetest_redis_1   /usr/local/bin/run         Up</span><br><span class="line">composetest_web_1     /bin/sh -c python app.py   Up      5000-&gt;5000/tcp123456789</span><br></pre></td></tr></table></figure><p><code>docker-compose run</code> 命令允许你为你的应用程序运行一次性命令。例如，查看哪些环境变量可以用于 web 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose run web env1</span></span><br></pre></td></tr></table></figure><p>通过 <code>docker-compose --help</code> 查看所有可用的命令。</p><p>如果你使用 <code>docker-compose up -d</code> 启动了 Compose，你可能希望在它们运行完成后停止服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose stop1</span></span><br></pre></td></tr></table></figure><p>你可以停掉所有一切，使用 down 命令完全移除容器。传递 —volumes 还可以删除 Redis 容器中所使用的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose down --volumes</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Compose 是一个用户定义和运行多个容器的 Docker 应用程序。在 Compose 中你可以使用 YAML 文件来配置你的应用服务。然后，只需要一个简单的命令，就可以创建并启动你配置的所有服务。&lt;/p&gt;
&lt;p&gt;使用 Compose 基本会有如下三步流程：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在Amazon ECS上部署Docker容器</title>
    <link href="http://blog.ozairs.com/AWS/%E5%9C%A8Amazon-ECS%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E5%AE%B9%E5%99%A8/"/>
    <id>http://blog.ozairs.com/AWS/在Amazon-ECS上部署Docker容器/</id>
    <published>2019-03-16T02:17:06.000Z</published>
    <updated>2019-03-16T02:53:00.117Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Elastic Container Service (Amazon ECS) 是用于在可扩展群集上运行 Docker 应用程序的 Amazon Web Service。在本教程中，您将了解如何在负载均衡器后面的 Amazon ECS 集群上运行支持 Docker 的示例应用程序，对该示例应用程序进行测试，然后删除您的资源以免产生费用。</p><p>在本教程中完成的所有操作均符合<a href="https://aws.amazon.com/cn/free/" target="_blank" rel="noopener">免费套餐</a>条件。</p><h4 id="管理-AWS-资源"><a href="#管理-AWS-资源" class="headerlink" title="管理 AWS 资源"></a>管理 AWS 资源</h4><p>登录控制台</p><h2 id="步骤-1：设置-Amazon-ECS-的首次运行"><a href="#步骤-1：设置-Amazon-ECS-的首次运行" class="headerlink" title="步骤 1：设置 Amazon ECS 的首次运行"></a>步骤 1：设置 Amazon ECS 的首次运行</h2><p>Amazon ECS 首次运行向导将引导您创建集群并启动示例 Web 应用程序。在此步骤中，您将进入 Amazon ECS 控制台并启动该向导。</p><hr><p>a. <a href="https://console.aws.amazon.com/ecs/home#/firstRun" target="_blank" rel="noopener">单击此处以打开 Amazon ECS 控制台首次运行向导</a>。</p><hr><p>b. 使用 Amazon ECS，您可以选择使用 Amazon Elastic Container Registry (Amazon ECR) 创建映像存储库，并向其推送一个映像作为首次运行向导的一部分（参见右侧的屏幕截图）。该功能目前在部分区域可用。 </p><ul><li>如果没有 Amazon ECR 选项，请跳至步骤 2。</li><li>如果有 Amazon ECR 选项，则取消选中 <em>Deploy a sample application onto an Amazon ECS Cluster</em> 旁边的复选框，然后选择 <strong>Continue</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/1.png" alt="deploy-docker-container-1"></p><h2 id="步骤-2：创建任务定义"><a href="#步骤-2：创建任务定义" class="headerlink" title="步骤 2：创建任务定义"></a>步骤 2：创建任务定义</h2><p><em>任务定义</em>类似于应用程序的蓝图。在此步骤中，您将指定一个任务定义，以便 Amazon ECS 分辨出将哪个 Docker 映像用于容器、该任务将使用多少个容器以及每个容器的资源分配情况。</p><hr><p>任务定义预加载了默认的配置值。</p><ul><li>查看默认值并选择 <strong>Next Step</strong>。</li></ul><p>如果您希望修改配置或想要了解更多内容，请参阅<a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html" target="_blank" rel="noopener">任务定义参数</a>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/2.png" alt="deploy-docker-container-2"></p><h2 id="步骤-3：配置服务"><a href="#步骤-3：配置服务" class="headerlink" title="步骤 3：配置服务"></a>步骤 3：配置服务</h2><p>您现已创建了任务定义，接下来是配置 Amazon ECS <em>服务</em>。服务可启动并维护集群中任务定义的副本。例如，通过将某个应用程序作为服务来运行，Amazon ECS 将自动恢复任何已停止的任务并维持您所指定的副本数。</p><hr><p>a. 配置服务选项：</p><ul><li><strong>Service Name</strong>：默认的 <em>sample-webapp</em> 是一款由 AWS 提供的基于 Web 的“Hello World”应用程序。这意味着它可无限期运行，因此，通过将其作为服务来运行，如果任务的运行状况不佳或意外终止，该应用程序将重新启动。</li><li><strong>Desired number of tasks</strong>：若不超出 <a href="https://aws.amazon.com/cn/free/" target="_blank" rel="noopener">AWS 免费套餐</a>的范围，请保留默认值 <em>1</em>。此操作将为您的任务创建一个副本。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/3.png" alt="deploy-docker-container-3"></p><hr><p>b. Elastic Load Balancing：您可以选择将负载均衡器与您的服务配合使用。Amazon ECS 可以创建 Elastic Load Balancing (ELB) 负载均衡器，以在启动任务的各个容器实例间分配流量。</p><ul><li><strong>Container name: host port</strong>：选择 <em>Simple-app:80</em>。</li><li>为示例应用程序设置 <em>ELB listener protocol、ELB listener port 和 ELB health check</em> 的默认值。有关负载均衡配置的更多信息，请参阅 <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html" target="_blank" rel="noopener">Service Load Balancing</a>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/4.png" alt="deploy-docker-container-3b"></p><hr><p>c. 将负载均衡器挂载到 Amazon ECS 服务之前，必须先创建服务要使用的 Identity and Access Management (IAM) 角色。此操作将允许 Amazon ECS 调用 Amazon EC2 和 Elastic Load Balancing API，以在负载均衡器中注册和取消注册实例。</p><ul><li>如果您还没有服务 IAM 角色，Amazon ECS 将创建一个名为 <em>ecsServiceRole</em> 的角色。</li><li>如果您有现有的 Amazon ECS 服务角色，请从下拉菜单中选择该角色。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/5.png" alt="deploy-docker-container-3c"></p><hr><p>d. 检查设置并选择 <strong>Next Step</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/6.png" alt="deploy-docker-container-3d"></p><h2 id="步骤-4：配置集群"><a href="#步骤-4：配置集群" class="headerlink" title="步骤 4：配置集群"></a>步骤 4：配置集群</h2><p>在<em>集群</em>上运行 Amazon ECS 任务，该集群是运行 Amazon ECS 容器代理的容器实例集合。在此步骤中，您将配置集群、检查安全设置并设置 IAM 角色。</p><hr><p>a. 按照以下配置设置执行操作：</p><ul><li><strong>Cluster name</strong>：输入 <em>sample-cluster</em>。</li><li><strong>EC2 instance type</strong>：默认的 <em>t2.micro</em> 实例类型可确保您不超出免费套餐的范围。CPU 和内存资源越多的实例类型可以处理的任务就越多。有关不同实例类型的更多信息，请参阅 <a href="https://aws.amazon.com/cn/ec2/instance-types/" target="_blank" rel="noopener">Amazon EC2 实例类型</a>。</li><li><strong>Number of instances</strong>：保留默认值 <em>1</em> 以启动一个要放置任务的集群中启动的 Amazon EC2 实例。集群中的实例越多，可在其上放置的任务就越多。</li><li><strong>Key pair</strong>：稍后通过 SSH 连接到实例时需要密钥对。您可通过选择 <em>None – unable to SSH</em>、选择现有密钥对或在 Amazon EC2 控制台中创建一个密钥对以继续操作。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/7.png" alt="deploy-docker-container-5a"></p><hr><p>b.（可选）安全组：默认值 <em>(Anywhere)</em> 可允许从整个 Internet 进行访问。您还可以选择 CIDR 块以限制对实例的访问。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/8.png" alt="deploy-docker-container-5b"></p><hr><p>c. 容器实例 IAM 角色：</p><ul><li>如果您没有 IAM 角色，Amazon ECS 向导将会为您创建一个。</li><li>如果您有现有的容器实例 IAM 角色，请从下拉菜单中选择该角色。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/10.png" alt="deploy-docker-container-5c"></p><hr><p>d. 选择 <strong>Review and Launch</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/11.png" alt="deploy-docker-container-5d"></p><h2 id="步骤-5：启动和查看资源"><a href="#步骤-5：启动和查看资源" class="headerlink" title="步骤 5：启动和查看资源"></a>步骤 5：启动和查看资源</h2><p>在上述步骤中，您配置了任务定义（类似于应用程序蓝图）、Amazon ECS 服务（可启动并维护任务定义的副本）和集群（是运行容器代理的容器实例集合）。在此步骤中，您将检查、启动和查看您所创建的资源。</p><hr><p>a. 在启动之前，您有最后一次机会来检查任务定义、任务配置和集群配置。</p><ul><li>选择 <strong>Launch instance &amp; run service</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/12.png" alt="deploy-docker-container-6"></p><hr><p>b. 您此时位于 <em>Launch Status</em> 页面上，该页面将显示启动状态并描述了过程的每一步。</p><ul><li>启动完成后，选择 <strong>View service</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/13.png" alt="deploy-docker-container-7"></p><h2 id="步骤-6：打开示例应用程序"><a href="#步骤-6：打开示例应用程序" class="headerlink" title="步骤 6：打开示例应用程序"></a>步骤 6：打开示例应用程序</h2><p>在此步骤中，您可通过将您的浏览器指向负载均衡器 DNS 名称来验证示例应用程序是否已启动并处于运行状态。</p><hr><p>a. 在“sample-webapp”页面上，单击您的负载均衡器名称。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/14.png" alt="deploy-docker-container-10"></p><hr><p>b. 现在将测试该示例应用程序：</p><ul><li>复制 ELB DNS 名称。</li><li>将其粘贴到新的浏览器窗口中。</li><li>按键盘上的 Enter 键以查看示例应用程序（在本示例中为静态网页）。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/15.png" alt="deploy-docker-container-12a"></p><h2 id="步骤-7：删除资源"><a href="#步骤-7：删除资源" class="headerlink" title="步骤 7：删除资源"></a>步骤 7：删除资源</h2><p>在本教程中，您启动了三种资源：一个 Amazon ECS 集群、一个 Amazon EC2 实例和一个负载均衡器。在此步骤中，您将清除所有资源以免产生不必要的费用。</p><hr><p>a. 重新导航至 Amazon ECS 控制台页面</p><ul><li>单击集群名称 (<strong>sample-cluster</strong>)。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/16.png" alt="deploy-docker-container-13"></p><hr><p>b. 选中 <em>sample-webapp</em> 旁边的复选框，然后单击 <strong>Update</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/17.png" alt="deploy-docker-container-15"></p><hr><p>c. 为确保您不会意外删除带有活动任务的服务，您需要在 Amazon ECS 删除某个服务之前终止所有任务。 </p><ul><li>将任务数设置为 <em>0</em>，然后选择 <strong>Update Service</strong>。</li><li>更新服务之后，选择 <strong>Delete</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/18.png" alt="deploy-docker-container-14"></p><hr><p>d. 删除通过集群启动的 Amazon EC2 实例：</p><ul><li><a href="https://console.aws.amazon.com/ec2/v2/home" target="_blank" rel="noopener">进入 Amazon EC2 控制台</a></li><li>在左侧窗格中，选择 <strong>Instances</strong>。</li><li>选中名为 <em>ECS Instance – EC2ContainerService-default</em> 的实例旁边的复选框。</li><li>依次选择 <strong>Actions &gt;</strong> <strong>Instance State</strong> &gt; <strong>Terminate</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/19.png" alt="deploy-docker-container-17"></p><hr><p>e. 删除负载均衡器：</p><ul><li>在左侧窗格中，选择 <strong>Load Balancers</strong>。</li><li>选中您为服务创建的负载均衡器旁边的复选框（应以 <em>EC2Contai-EcsElast</em> 开头）。</li><li>右键单击并选择 <strong>Delete</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/20.png" alt="deploy-docker-container-19a"></p><h1 id="恭喜您！"><a href="#恭喜您！" class="headerlink" title="恭喜您！"></a>恭喜您！</h1><p>恭喜您！您已了解如何在 Amazon Elastic Container Service (Amazon ECS) 中配置、部署和删除支持 Docker 的应用程序。Amazon ECS 是一个可高度扩展的高性能容器管理服务，它支持 Docker 容器，并允许您在 Amazon EC2 实例的托管集群上轻松地运行应用程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Amazon Elastic Container Service (Amazon ECS) 是用于在可扩展群集上运行 Docker 应用程序的 Amazon Web Service。在本教程中，您将了解如何在负载均衡器后面的 Amazon ECS 集群上运行支持 Docke
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ssh-key git多账户配置</title>
    <link href="http://blog.ozairs.com/DevOps/ssh-key-git%E5%A4%9A%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.ozairs.com/DevOps/ssh-key-git多账户配置/</id>
    <published>2019-03-15T06:03:34.000Z</published>
    <updated>2019-03-15T06:05:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>在使用git的时候，一般我们使用的远程Git服务器是github，这时只需简单的生成ssh-key密钥对并将公钥添加到github中就可以使用ssh了。</p><p>但在公司开发使用内部的git时，一般在gitlab,使用的邮箱一般是公司的邮箱，那么就需要配置多个ssh-key账户了。</p><p>假设user使用github的邮箱为<a href="https://link.jianshu.com?t=mailto:user1@163.com" target="_blank" rel="noopener">user1@163.com</a>;user2使用gitlab的邮箱为<a href="https://link.jianshu.com?t=mailto:user2@163.com" target="_blank" rel="noopener">user2@163.com</a>,下面是配置过程：</p><ol><li>首先进入用户主目录下的.ssh文件夹，我们生成的密钥对放在这儿</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br></pre></td></tr></table></figure><ol><li>分别为user1和user2生成密钥对：<br> 默认三次回车生成key的名字为id_rsa，注意在生成第二个的时候不要使用默认名，否则会覆盖第一个，在以下位置为第二个输入名字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#新建SSH key</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user1@163.com&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user2@163.com&quot;</span><br><span class="line">#设置user2的命名为id_rsa_work </span><br><span class="line">Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_work</span><br></pre></td></tr></table></figure><p>此时在.ssh目录下就有两个密钥对文件id_rsa和id_rsa_work,我们将公钥分别拷至对应的Git服务器</p><ol><li>添加key到SSH agent中:<br> 此时还无法使用第二个服务器，因为Git会默认只读取到id_rsa,为了让SSH识别新的私钥，需将其添加到SSH agent中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa_work</span><br></pre></td></tr></table></figure><p>如果出现Could not open a connection to your authentication agent的错误，就试着用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa_work</span><br></pre></td></tr></table></figure><p>成功会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Identity added: /c/Users/Windows用户名/.ssh/key名 (/c/Users/Windows用户名/.ssh/key名)</span><br></pre></td></tr></table></figure><p>注意：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了。</p><ol><li>创建并配置config文件使配置永久生效：<br> 在.ssh目录下新建一个文本文件，命令为config，不需要后缀，bash下可直接使用touch config,编辑以下内容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># gitlab</span><br><span class="line">Host gitlab的IP</span><br><span class="line">    HostName gitlab的Host     //这里填你们公司的git网址即可</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_work</span><br><span class="line">    User user2</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User user1</span><br></pre></td></tr></table></figure><p>其规则就是：从上至下读取config的内容，在每个Host下寻找对应的私钥。按照你的情况修改就可以。</p><ol><li>使用：如果之前有设置全局用户名和邮箱的话，需要unset一下，可通过<code>$ git config --list</code>来查看全局配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset user.name</span><br><span class="line">$ git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>可以在不同的仓库下设置局部的用户名和邮箱用不同的账号登录，比如在公司的repository下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &quot;user2&quot;  </span><br><span class="line">$ git config user.email &quot;user2@163.com&quot;</span><br></pre></td></tr></table></figure><ol><li>测试：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">#输出：Hi user1! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">$ ssh -T git@gitlab的IP</span><br><span class="line">#输出：Hi user2@163.com**, this is git@.....</span><br></pre></td></tr></table></figure><p>测试成功。<br> 如果出什么问题，可以通过<code>ssh -vT git@github.com</code>来输出编译信息，然后根据编译信息去解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用git的时候，一般我们使用的远程Git服务器是github，这时只需简单的生成ssh-key密钥对并将公钥添加到github中就可以使用ssh了。&lt;/p&gt;
&lt;p&gt;但在公司开发使用内部的git时，一般在gitlab,使用的邮箱一般是公司的邮箱，那么就需要配置多个ssh-
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="ssh" scheme="http://blog.ozairs.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>使用Ansible进行自动化：构建VPC</title>
    <link href="http://blog.ozairs.com/Ansible/%E4%BD%BF%E7%94%A8Ansible%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9A%E6%9E%84%E5%BB%BAVPC/"/>
    <id>http://blog.ozairs.com/Ansible/使用Ansible进行自动化：构建VPC/</id>
    <published>2019-03-14T11:19:52.000Z</published>
    <updated>2019-03-14T11:27:47.200Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们将讨论如何使用Ansible在AWS VPC中自动配置云网络。如果你不确定你在这里做什么，也许可以偷看介绍。我们将构建的自动化范围将轻松配置以下所有内容：</p><ul><li><strong>VPC和子网</strong>：创建VPC本身，以及跨三个可用区域的公共和私有子网：a，b和c</li><li><strong>Internet Gateway</strong>：为我们的公共资源配置网关以访问Internet</li><li><strong>NAT网关</strong>：配置NAT网关以允许我们的私有资源访问公共互联网</li><li><strong>VPC路由表</strong>：定义路由以使我们的子网成为公共或私有（使用公共或NAT网关路由公共流量）</li><li><strong>安全组</strong>：定义一些有用的安全组，用于限制仅在VPC内的通信，和/或允许来自公共互联网的SSH或HTTP / S流量</li><li><strong>私有DNS</strong>：创建一个专用的Route53托管区域，用于解决VPC内的资源</li></ul><p><img src="/Ansible/使用Ansible进行自动化：构建VPC/1.png" alt="img"></p><p>请注意，本文不是为了解释这些AWS资源如何工作，甚至是如何配置它们，而是具体说明如何使用Ansible <em>自动化</em>它们的配置。让我们开始吧！</p><hr><h3 id="VPC和子网"><a href="#VPC和子网" class="headerlink" title="VPC和子网"></a>VPC和子网</h3><h4 id="配置主机和组变量"><a href="#配置主机和组变量" class="headerlink" title="配置主机和组变量"></a>配置主机和组变量</h4><p>我们将首先为我们的VPC定义一个Ansible主机。该主机将充当“逻辑主机”（因为它不是我们可以连接以运行命令的实际主机），它将代表所有VPC配置。因此，在我们的清单中，我们定义一个<code>vpc</code>具有单个<code>vpc.ansibled</code>（名称只是名称，没有特殊）主机的组，然后将该<code>vpc</code>组放入一个名为的高级“项目”组中<code>project.ansibled</code>。</p><p>现在让我们定义配置VPC和子网时需要的变量。在全球范围内，<code>group_vars/all.yml</code>我们只想定义默认情况下我们不想尝试与主机建立SSH连接，只需在本地运行Ansible任务（几乎所有的自动化都是AWS云和无服务器）：</p><p>我们的通用“所有”组的一般全局变量</p><p>我们的<code>project.ansibled</code>团队将进行一些繁重的工作并提供高级定义，例如VPC名称和我们的AWS凭证。我们将在此组中放置所有主机，以便在Ansible执行时可以使用此配置。所以在<code>group_vars/project.ansibled.yml</code>：</p><p>接下来，我们定义VPC本身的一些细节：VPC的IP地址块，安全组和子网配置。这些我们将定义为主机的主机变量<code>vpc.ansibled</code>，因为我们希望它们特定于此主机，而其他主机（当我们绕过它们时）将不需要自己引用这些定义。</p><p>我们的“vpc.ansibled”逻辑主机的特定配置</p><h4 id="使用Ansible-Vault保护敏感信息"><a href="#使用Ansible-Vault保护敏感信息" class="headerlink" title="使用Ansible Vault保护敏感信息"></a>使用Ansible Vault保护敏感信息</h4><p>您可能想知道为什么存储我们的IAM凭证的vars <code>aws_access_key</code>和<code>aws_secret_key</code>vars看起来像那样。鉴于我们要将自动化提交到存储库，我们需要确保此敏感信息不会以纯文本形式显示 - 输入<a href="http://docs.ansible.com/ansible/2.4/vault.html" target="_blank" rel="noopener">Ansible Vault</a>，<a href="http://docs.ansible.com/ansible/2.4/vault.html" target="_blank" rel="noopener">Ansible的</a>一项功能，允许我们加密文件和字符串，使它们成为可能安全的版本控制。</p><p>要生成我们可以在运行时解密的这些加密字符串，首先我们将加密密码写入（git-ignored，或者最好不在repo目录中）文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo“my_vault_pass”&gt;〜/ ansibled.vault</span><br></pre></td></tr></table></figure><p>其次，将我们的纯文本值提供给<code>ansible-vault</code>程序，指定我们的密码文件，然后弹出一个加密的字符串，我们可以安全地存储在我们的Ansible vars中！</p><p><img src="/Ansible/使用Ansible进行自动化：构建VPC/2.png" alt="img"></p><p>您得到一个图像，因为Vault字符串在代码块中<strong>可怕</strong>地呈现</p><p>稍后，当我们想要执行自动化时，我们只需指定我们的保管库密码文件，或指定Ansible应该提示我们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃提示用户输入Vault密码</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml --ask-vault-pass</span><br><span class="line">＃从文件</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml中读取Vault密码--vault-password-file~ / ansibled.vault</span><br></pre></td></tr></table></figure><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>我们的Ansible任务（“代码”）将全部存放在一个<code>tasks/</code>目录下，并存放在<code>tasks/vpc/</code>与创建VPC相关的所有任务的子目录下。然后，我们的playbook将在运行时动态地包含这些任务列表，允许我们组织我们的任务来创建模块化的“代码”块。</p><p>我们的VPC自动化的第一阶段将涉及以下步骤：</p><ul><li>创建VPC</li><li>创建VPC子网</li><li>创建VPC安全组</li><li>为VPC创建Route53专用区域</li></ul><p>有了我们的主要VPC组件，我们现在可以为我们的VPC配置路由和网关：</p><ul><li>创建互联网网关</li><li>创建NAT网关（并更新VPC DNS）</li><li>为私有子网创建路由表</li><li>为公共子网创建路由表</li></ul><h4 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h4><p>现在我们已经编写了一些构建我们的VPC的任务，我们只需要将它与一个剧本联系在一起。我们只是针对该<code>vpc</code>组，使用我们的AWS凭证详细信息填充我们的环境，并使用该<code>include_tasks</code>指令来提取我们的VPC任务。简单！</p><h4 id="直截了当地了解事实"><a href="#直截了当地了解事实" class="headerlink" title="直截了当地了解事实"></a>直截了当地了解事实</h4><p>最后一个难题是为我们自动化的其他部分提供一种简单的方法来访问和利用我们刚刚提出的VPC基础设施的细节。例如，我们会希望能够容易地通过我们赋予他们的人类可读的名字（查找我们的VPC子网的ID <code>private-a</code>，<code>public-b</code>等等），就像我们建立我们的路由表上面的什么时候。因此，我们在以下位置创建“事实”任务列表<code>tasks/vpc/facts.yml</code>：</p><p>我们的VPC的这个“事实”任务列表现在可以包含在其他手册中以窥视AWS并发现有关我们VPC的一些重要信息！</p><p>而且……行动！</p><p>现在要自动构建我们的VPC，只需执行Ansible：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃提示用户输入Vault密码</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml --ask-vault-pass</span><br><span class="line">＃从文件</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml中读取Vault密码--vault-password-file ansibled.vault</span><br></pre></td></tr></table></figure><p>最后，在运行时拿一杯咖啡:)快乐的自动化！</p><hr><p><em>我喜欢自动化。这一系列的文章，自动化与Ansible，是一些Ansible bit’n bobs的记录，使我在管理软件基础设施时更轻松。</em></p><p><em>在</em><a href="https://github.com/tomwwright/ansibled" target="_blank" rel="noopener"><em>GitHub</em></a><em>或系列中的其他条目中<strong>全部检查</strong>：</em></p><ul><li><a href="https://medium.com/@tomwwright/automation-with-ansible-introduction-ccfa1baf8f5c" target="_blank" rel="noopener">Ansible自动化：简介</a></li><li>Ansible自动化：构建VPC（本文）</li><li><a href="https://medium.com/@tomwwright/automation-with-ansible-aws-elasticsearch-service-8d862cdb4a68" target="_blank" rel="noopener">Ansible自动化：AWS Elasticsearch</a></li><li><a href="https://medium.com/@tomwwright/automating-with-ansible-aurora-clusters-7272364777dd" target="_blank" rel="noopener">Ansible自动化：Aurora RDS集群</a></li><li><a href="https://medium.com/@tomwwright/automation-with-ansible-logentries-53cf595c2002" target="_blank" rel="noopener">Ansible自动化：Logentries</a></li></ul><p>【原文链接】：<a href="https://medium.com/@tomwwright/automating-with-ansible-building-a-vpc-c252944d3d2e" target="_blank" rel="noopener">https://medium.com/@tomwwright/automating-with-ansible-building-a-vpc-c252944d3d2e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本文中，我们将讨论如何使用Ansible在AWS VPC中自动配置云网络。如果你不确定你在这里做什么，也许可以偷看介绍。我们将构建的自动化范围将轻松配置以下所有内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VPC和子网&lt;/strong&gt;：创建VPC本身，以及跨三个可用
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="AWS" scheme="http://blog.ozairs.com/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Ansible进阶手册</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E8%BF%9B%E9%98%B6%E6%89%8B%E5%86%8C/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible进阶手册/</id>
    <published>2019-03-14T09:07:52.000Z</published>
    <updated>2019-03-14T10:11:37.245Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Playbook-contain-plays-plays-contain-tasks-tasks-call-modules"><a href="#1-Playbook-contain-plays-plays-contain-tasks-tasks-call-modules" class="headerlink" title="1. Playbook contain plays, plays contain tasks, tasks call modules"></a>1. Playbook contain plays, plays contain tasks, tasks call modules</h3><h3 id="2-Tasks-run-sequentially"><a href="#2-Tasks-run-sequentially" class="headerlink" title="2. Tasks run sequentially"></a>2. Tasks run sequentially</h3><h3 id="3-Handlers-are-triggered-by-tasks-and-are-run-once-at-the-end-of-the-plays"><a href="#3-Handlers-are-triggered-by-tasks-and-are-run-once-at-the-end-of-the-plays" class="headerlink" title="3. Handlers are triggered by tasks, and are run once, at the end of the plays."></a>3. Handlers are triggered by tasks, and are run once, at the end of the plays.</h3><ol start="4"><li>Ansible has many different ways to alter how playbooks run by using with_items, failed_when, changed_when, until,  ignore_errors</li><li>Ansible roles are a special kind of playbook that are fully self-contained with tasks, variables, configurations templates and other supporting files.</li></ol><h5 id="一、Ansible与AWS配合"><a href="#一、Ansible与AWS配合" class="headerlink" title="一、Ansible与AWS配合"></a>一、Ansible与AWS配合</h5><p>1、通过boto函数查询EC2实例</p><p>>&gt;&gt; import boto.ec2</p><p>>&gt;&gt; conn = boto.ec2.connect_to_region(“ap-southeast-2”)</p><p>>&gt;&gt; statuses = conn.get_all_instance_status()</p><p>>&gt;&gt; statuses</p><p>[InstanceStatus:i-040f7235964b7d201]</p><h5 id="二-、关于Module的调用"><a href="#二-、关于Module的调用" class="headerlink" title="二 、关于Module的调用"></a>二 、关于Module的调用</h5><ol><li><p>通过命令行方式调用Module: </p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webservers -m service -a &quot;name=httpd state=started&quot;</span><br><span class="line">ansible webservers -m ping</span><br><span class="line">ansible webservers -m command -a &quot;/sbin/reboot -t now&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过Playbook调用Module:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: reboot the servers</span><br><span class="line">  action: command /sbin/reboot -t now</span><br></pre></td></tr></table></figure><p>可以缩写为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: reboot the servers</span><br><span class="line">  command: /sbin/reboot -t now</span><br></pre></td></tr></table></figure><p>另外一种传参方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- name: restart webserver</span><br><span class="line">  service:</span><br><span class="line">    name: httpd</span><br><span class="line">    state: restarted</span><br></pre></td></tr></table></figure></li><li><p>Ansible Tower方式</p></li><li><p>Ansible帮助命令</p><p>ansible help | less</p><p>ansible-doc command</p></li></ol><p>三 、Ansible的三种使用方式</p><ol><li>命令行方式：</li><li>Playbook调用方式： </li><li>Ansible Tower：</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Playbook-contain-plays-plays-contain-tasks-tasks-call-modules&quot;&gt;&lt;a href=&quot;#1-Playbook-contain-plays-plays-contain-tasks-tasks-call-m
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>AWS云上的Puppet:快速入门参考部署</title>
    <link href="http://blog.ozairs.com/AWS/AWS%E4%BA%91%E4%B8%8A%E7%9A%84Puppet-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E5%8F%82%E8%80%83%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/AWS/AWS云上的Puppet-快速入门参考部署/</id>
    <published>2019-03-14T05:26:27.000Z</published>
    <updated>2019-03-14T05:43:21.823Z</updated>
    
    <content type="html"><![CDATA[<p>本快速入门参考部署指南讨论在 Amazon Web Services (AWS) 云中部署和测试 Puppet Master 和 Puppet 代理所需的步骤。它还提供了用于查看和启动 <a href="https://aws.amazon.com/cloudformation/" target="_blank" rel="noopener">AWS CloudFormation</a> 模板（可自动进行部署）的链接，以及有关如何配置充当 Puppet 代理的 Amazon Elastic Compute Cloud (Amazon EC2) 实例的演练。</p><p>本指南面向计划在 AWS 云上实施或扩展 Puppet 工作负载的 IT 基础设施架构师、管理员和 DevOps 专家。</p><ul><li>如果您拥有 AWS 账户且已熟悉 AWS 和 Puppet，可以<a href="https://fwd.aws/YBD5Y" target="_blank" rel="noopener">启动快速入门</a>以构建<a href="https://docs.aws.amazon.com/zh_cn/quickstart/latest/puppet/architecture.html#fig1" target="_blank" rel="noopener">图 1</a> 所示的架构。完成部署需要约 20 分钟。如果您是刚刚接触 AWS 或 Puppet，请查看实施详情，然后按照本指南后面部分提供的<a href="https://docs.aws.amazon.com/zh_cn/quickstart/latest/puppet/deployment.html" target="_blank" rel="noopener">分步说明</a>来启动快速入门。</li></ul><p>  <a href="https://fwd.aws/YBD5Y" target="_blank" rel="noopener">https://fwd.aws/YBD5Y</a></p><ul><li>如果您想更深一步地了解相关信息，则可以<a href="https://fwd.aws/pkzpq" target="_blank" rel="noopener">查看模板</a>以了解自动执行此部署的 AWS CloudFormation 脚本。默认情况下，默认配置将部署三个使用 t2.medium 实例类型的服务器，但您也可以按需自定义模板。</li></ul><p>  <a href="https://fwd.aws/pkzpq" target="_blank" rel="noopener">https://fwd.aws/pkzpq</a></p><p>注意</p><p>运行本快速入门参考部署时，您需要支付所用的所有 AWS 服务的相关费用。价格可能会发生变化。有关完整详细信息，请参阅<a href="https://docs.aws.amazon.com/zh_cn/quickstart/latest/puppet/overview.html#cost" target="_blank" rel="noopener">成本和许可证</a>部分以及您所使用 AWS 服务的定价页面。</p><h1 id="步骤-1-准备-AWS-账户"><a href="#步骤-1-准备-AWS-账户" class="headerlink" title="步骤 1.准备 AWS 账户"></a>步骤 1.准备 AWS 账户</h1><ol><li><p>如果您还没有 AWS 账户，请按照屏幕说明在 <a href="https://aws.amazon.com/" target="_blank" rel="noopener">https://aws.amazon.com</a> 上创建一个。 作为注册流程的一部分，您会接到一个电话，并且需要通过手机键盘输入 PIN 码。</p></li><li><p>使用导航栏中的区域选择器选择要在 AWS 上将 Puppet 部署到的 AWS 区域。</p><p>Amazon EC2 位置由<em>区域</em> 和<em>可用区</em> 构成。区域分散存在，位于独立的地理区域。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/1.png" alt="">          </p><p><strong>图 2：选择 AWS 区域</strong></p><p>提示</p><p>考虑选择最接近数据中心或企业网络的区域，以减少运行于 AWS 的系统与企业网络上的系统和用户之间的网络延迟。</p></li><li><p>在首选区域中创建一个<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" target="_blank" rel="noopener">密钥对</a>。为此，在 Amazon EC2 控制台的导航窗格中，依次选择 <strong>Key Pairs (密钥对)</strong>、<strong>Create Key Pair (创建密钥对)</strong>，键入名称，然后选择 <strong>Create (创建)</strong>。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/2.png" alt=""></p><p><strong>图 3：创建密钥对</strong></p><p>Amazon EC2 使用公有密钥密码术来加密和解密登录信息。要登录实例，必须创建密钥对。对于 Windows 实例，我们使用密钥对通过 Amazon EC2 控制台获取管理员密码，然后使用远程桌面协议 (RDP) 登录，如 <em>Amazon Elastic Compute Cloud 用户指南</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html#having-ec2-create-your-key-pair" target="_blank" rel="noopener">分步说明</a>所述。在 Linux 上，我们使用密钥对来对 SSH 登录进行身份验证。</p></li><li><p>如有必要，可针对 <strong>t2.medium</strong> 实例类型<a href="https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase%26;limitType=service-code-" target="_blank" rel="noopener">请求提高服务限制</a>。为此，在 AWS Support Center 中，选择 <strong>Create Case</strong>，<strong>Service Limit Increase</strong>，<strong>EC2 instances</strong>，然后填写限制提高表中的字段。此实例类型的当前默认限制为 20 个实例。</p><p>如果您已有使用此实例类型的现有部署，并且可能会超过此参考部署的默认限制，则可能需要请求提高限制。新服务限制可能需要几天才能生效。有关更多信息，请参阅 AWS 文档中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-resource-limits.html" target="_blank" rel="noopener">Amazon EC2 服务限制</a>。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/3.png" alt=""></p><p><strong>图 4：请求提高服务限制</strong></p></li></ol><h1 id="步驟-2-启动-Puppet-堆栈"><a href="#步驟-2-启动-Puppet-堆栈" class="headerlink" title="步驟 2.启动 Puppet 堆栈"></a>步驟 2.启动 Puppet 堆栈</h1><p>此快速入门附带的自动化 AWS CloudFormation 模板将 Puppet 部署到 VPC 中。在启动堆栈之前，请确保您已完成前面的步骤。</p><ol><li><p>在您的 AWS 账户中启动 AWS CloudFormation 模板。<a href="https://fwd.aws/YBD5Y" target="_blank" rel="noopener">https://fwd.aws/YBD5Y</a></p><p>默认情况下，模板在 美国西部（俄勒冈） 区域中启动。您可以使用导航栏中的区域选择器来更改区域。</p><p>创建此堆栈需要大约 20 分钟时间。</p><p>注意</p><p>运行本快速入门参考部署时，您需要支付所用的 AWS 服务的费用。使用本快速入门不收取任何额外费用。有关完整详细信息，请参阅您将使用的每项 AWS 服务的定价页。</p></li><li><p>在 <strong>Select Template (选择模板)</strong> 页面上，保留 AWS CloudFormation 模板的默认 URL，然后选择 <strong>Next (下一步)</strong>。</p></li><li><p>在 <strong>Specify Details</strong> 页面上，查看模板的参数。下表描述了这些选项。</p><p>为 <em>KeyPairName</em> 参数提供值。此参数需要您进行输入。对于所有其他参数，模板提供可以自定义的默认设置。</p><p><em>安全配置：</em></p></li></ol><table><thead><tr><th>参数标签</th><th>参数名称</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><strong>选择一个密钥对</strong></td><td><strong>KeyPairName</strong></td><td><em>需要输入</em></td><td>公有/私有密钥对，使您能够在实例启动后安全地与它连接。创建 AWS 账户时，这是您在首选区域中创建的密钥对。</td></tr><tr><td><strong>用于远程访问的源 IP</strong></td><td><strong>RemoteAdminCIDR</strong></td><td><em>需要输入</em></td><td>用于 SSH 和 RDP 访问的 CIDR 块或 IP 地址 (例如，1.1.1.1/32)。</td></tr></tbody></table><p>   <em>AWS 快速入门配置：</em></p><table><thead><tr><th>参数标签</th><th>参数名称</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><strong>快速入门 S3 存储桶名称</strong></td><td>QSS3BucketName</td><td>aws-quickstart</td><td>安装快速入门模板和脚本的 S3 存储桶。如果您决定自定义或扩展快速入门以供您自己使用，请使用此参数来指定您为快速入门资产的副本创建的 S3 存储桶名称。存储桶名称可以包含数字、小写字母、大写字母和连字符，但不得以连字符开头或结尾。</td></tr><tr><td><strong>快速入门 S3 键前缀</strong></td><td>QSS3KeyPrefix</td><td>quickstart-puppet/</td><td><a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html" target="_blank" rel="noopener">S3 键名称前缀</a>，用于模拟快速入门资产的副本的文件夹（如果您决定自定义或扩展快速入门以供您自己使用）。此前缀可以包含数字、小写字母、大写字母、连字符和正斜杠。</td></tr></tbody></table><p>   <em>网络配置:</em></p><table><thead><tr><th>参数标签</th><th>参数名称</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><strong>VPC 的 CIDR 范围</strong></td><td><strong>VPCCIDR</strong></td><td>10.0.0.0/16</td><td>Amazon VPC 的 CIDR 块。</td></tr><tr><td><strong>VPC 中的子网的 CIDR 范围</strong></td><td><strong>SubnetCIDR</strong></td><td>10.0.0.0/19</td><td>子网的 CIDR 块。</td></tr><tr><td><strong>Puppet Master 的 IP 地址</strong></td><td><strong>PuppetMasterIP</strong></td><td>10.0.0.10</td><td>Puppet Master 部署到的实例的 IP 地址。</td></tr><tr><td><strong>Linux Puppet 代理的 IP 地址</strong></td><td><strong>PuppetAgentLinuxIP</strong></td><td>10.0.0.11</td><td>Linux Puppet 代理部署到的实例的 IP 地址。</td></tr><tr><td><strong>Windows Puppet 代理的 IP 地址</strong></td><td><strong>PuppetAgentWindowsIP</strong></td><td>10.0.0.12</td><td>Windows Puppet 代理部署到的实例的 IP 地址。</td></tr></tbody></table><ol start="4"><li><p>在 <strong>Options (选项)</strong> 页面上，您可以为堆栈中的资源<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html" target="_blank" rel="noopener">指定标签</a>（键-值对）并<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-console-add-tags.html" target="_blank" rel="noopener">设置其他选项</a>。在完成此操作后，选择 <strong>Next (下一步)</strong>。</p></li><li><p>在 <strong>Review</strong> 页面上，查看并确认模板设置。选择 <strong>Capabilities</strong> 下的复选框，以确认模板将创建 IAM 资源。</p></li><li><p>选择 <strong>Create</strong> 以部署堆栈。</p></li><li><p>监控堆栈的状态。当状态显示 <strong>CREATE_COMPLETE</strong> 时，表示 Puppet 集群已准备就绪。</p></li></ol><h1 id="步驟-3-配置-Puppet-代理"><a href="#步驟-3-配置-Puppet-代理" class="headerlink" title="步驟 3.配置 Puppet 代理"></a>步驟 3.配置 Puppet 代理</h1><p>您可以按照本部分中的说明进行操作，来测试 AWS 上的 Puppet 设置。我们将查看 Puppet 代理的模块清单，应用配置并验证是否已成功应用配置。</p><h2 id="审查模块和清单"><a href="#审查模块和清单" class="headerlink" title="审查模块和清单"></a>审查模块和清单</h2><p>可通过多种方法将配置应用于代理节点（请参阅 <a href="https://puppet.com/docs" target="_blank" rel="noopener">Puppet 文档</a>）。此快速入门对每个 Linux 和 Windows 节点使用模块，并在引导启动阶段将这些模块从 Amazon S3 下载到主节点。</p><p>Puppet 程序称作<em>清单</em>，它们是使用 Puppet 代码开发的。（有关 Puppet 语言的信息，请参阅 <a href="https://puppet.com/docs/puppet/5.5/lang_summary.html" target="_blank" rel="noopener">Puppet 文档</a>。） 主清单的名称为 <strong>site.pp</strong>，并且位于清单文件夹中的主节点上。图 5 显示此快速入门中的主节点所使用的 site.pp 清单。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/4.png" alt=""></p><p><strong>图 5：主清单</strong></p><p>此清单包含三个节点声明：</p><ul><li><strong>第 1 行</strong> – 定义默认情况下可应用于任何系统的节点块。我们不执行任何常见配置，因此大括号内没有代码。</li><li><strong>第 3 行</strong> – 为名为 <em>linuxagent.example.com</em> 的代理定义节点块。这是由快速入门启动的 Ubuntu 代理。我们引用名为 <code>lampserver</code> 的模块中的类，而不是将资源定义置于此节点块中。使用类是减少代码重复的绝佳方式。在这种情况下，当 Linux 代理应用其配置时，它将使用 <code>lampserver</code> 类中的代码来定义系统的状态。</li><li><strong>第 7 行</strong> – 为名为 <em>windowsagent.example.com</em> 的代理定义节点块。这是由快速入门启动的 Windows Server 2012 R2 代理。我们引用名为 <code>iisserver</code> 的模块中的类，而不是将资源定义置于此节点块中。当 Windows 代理应用其配置时，它将使用 <code>iisserver</code> 类中的代码来定义系统的状态。</li></ul><p>接下来，我们来看看 <code>lampserver</code> 和 <code>iisserver</code> 类以了解其功能。</p><p>在名为 <code>lampserver</code> 的模块中定义 <code>lampserver</code> 类。模块的清单文件名为 <strong>init.pp</strong>，并且位于主节点上的 <strong>/etc/puppet/modules/lampserver/manifests</strong> 中。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/5.png" alt=""></p><p><strong>图 6：lampserver 类</strong></p><p>请注意以下与图 6 中显示的 <code>lampserver</code> 代码有关的内容：</p><ul><li><strong>第 1 行</strong> – 这是主清单文件中引用的 <code>lampserver</code> 的类定义。</li><li><strong>第 2 行</strong> – <code>exec</code> 关键字定义资源声明。您可使用资源来描述系统的所需状态。在这里，我们使用 <code>exec</code> 资源来对节点执行 <code>apt-update</code> 命令。</li><li><strong>第 6 行</strong> – 包资源用于在节点上安装 Apache 2。请注意，<code>require</code> 语句可确保 <code>apt-update</code> 在能够安装此资源之前已运行。</li><li><strong>第 11 行</strong> – <code>service</code> 资源确保 Apache 2 服务正在运行。</li><li><strong>第 15 行</strong> – <code>package</code> 资源确保一旦成功执行 <code>apt-update</code>，就立即安装 MySQL 服务器。</li><li><strong>第 20 行</strong> – <code>service</code> 资源确保 MySQL 正在运行。</li><li><strong>第 24 行</strong> – <code>package</code> 资源确保一旦成功执行 <code>apt-update</code>，就立即安装 PHP 5。</li><li><strong>第 29 行</strong> – <code>file</code> 资源确保在默认 <strong>apache</strong> 根目录中创建名为 <strong>info.php</strong> 的新文件。这需要安装 Apache 2。PHP 代码将添加到文件内容中，以便在用户通过 Web 浏览器访问网站时提供有关 Web 服务器的信息性页面。</li></ul><p>在名为 <code>iisserver</code> 的模块中定义 <code>iisserver</code> 类。模块的清单文件名为 <strong>init.pp</strong>，并且位于主节点上的 <strong>/etc/puppet/modules/iisserver/manifests</strong> 中。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/6.png" alt=""></p><p><strong>图 7：iisserver 类</strong></p><p>请注意以下与图 7 中显示的 <code>iisserver</code> 代码有关的内容：</p><ul><li><strong>第 1 行</strong> – 这是主清单文件中引用的 <code>iisserver</code> 的类定义。</li><li><strong>第 15 行</strong> – <code>windowsfeature</code> 资源利用 Windows PowerShell 确保安装 IIS 和 ASP.NET 的所有必需组件。</li><li><strong>第 19 行</strong> – <code>windowsfeature</code> 资源安装用于 IIS 管理的管理工具。</li><li><strong>第 25 行</strong> – <code>file</code> 资源确保 Web 服务器根目录中有一个名为 <strong>info.aspx</strong> 的信息性 ASP.NET 网页。此网页的内容因空间限制而被截断 (图 7 中所示)，但它包含一个提供服务器相关信息的页面指令，就像 Linux 节点上的 <strong>info.php</strong> 一样。</li></ul><p>除了创建您自己的模块之外，您还可以直接使用清单，或者利用 Puppet Forge 中预先存在的模块。有关编写模块和清单的详细信息，请参阅 Puppet 网站上的<a href="https://docs.puppet.com/puppet/4.3/modules_fundamentals.html" target="_blank" rel="noopener">模块基础知识</a>和<a href="https://puppet.com/support-services/training" target="_blank" rel="noopener">培训课程</a>。</p><h2 id="连接到-Puppet-代理"><a href="#连接到-Puppet-代理" class="headerlink" title="连接到 Puppet 代理"></a>连接到 Puppet 代理</h2><p>现在，您已了解示例模块的用途，已准备好远程连接到您的代理。</p><h3 id="Linux-代理"><a href="#Linux-代理" class="headerlink" title="Linux 代理"></a>Linux 代理</h3><p>您将需要使用 SSH 从 VPC 外部连接到您的 Linux 代理。在 Amazon EC2 控制台中，选择标记有 <strong>LinuxAgent</strong> 的 EC2 实例，如图 8 所示。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/7.png" alt=""></p><p><strong>图 8：选择 LinuxAgent 实例</strong></p><p>在公有 DNS 名称中检索 <strong>LinuxAgent</strong>，按照<em>适用于 Linux 实例的 Amazon EC2 用户指南</em>中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html#ec2-connect-to-instance-linux" target="_blank" rel="noopener">说明</a>操作，以将 SSH 客户端连接到实例。您将需要可用的密钥对才能建立远程 SSH 连接。</p><h3 id="Windows-代理"><a href="#Windows-代理" class="headerlink" title="Windows 代理"></a>Windows 代理</h3><p>您可以使用 RDP 通过 Internet 连接到 Windows 代理。在 Amazon EC2 控制台中，选择标记有 <strong>WindowsAgent</strong>的 EC2 实例，如图 9 所示。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/8.png" alt=""></p><p><strong>图 9：选择 WindowsAgent 实例</strong></p><p>在公有 DNS 名称中检索 <strong>WindowsAgent</strong>，按照<em>适用于 Microsoft Windows 实例的 Amazon EC2 用户指南</em>中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/connecting_to_windows_instance.html" target="_blank" rel="noopener">说明</a>操作，以建立连接。您将需要可用的密钥对才能解密 Windows 管理员密码并建立远程连接。</p><h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><p>在此部分中，您将应用节点配置并验证一切是否已配置成功。</p><h3 id="Linux-代理-1"><a href="#Linux-代理-1" class="headerlink" title="Linux 代理"></a>Linux 代理</h3><p>在通过 SSH 连接到 Linux 代理后，请运行以下命令以应用 <code>lampserver</code> 模块中的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo puppet agent --test</span><br></pre></td></tr></table></figure><p>您应看到与图 10 中的内容类似的输出，这指示已成功应用配置。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/9.png" alt=""></p><p><strong>图 10：Linux Puppet 代理输出</strong></p><p>接下来，打开 Web 浏览器并导航到 info.php 页面。您将需要使用 <strong>LinuxAgent</strong> EC2 实例的公有 DNS 名称 — 例如，http://&lt;<em>public DNS name</em>&gt;/info.php。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/10.png" alt=""></p><p><strong>图 11：测试 Apache Web 服务器</strong></p><p>您应看到与图 11 中所示内容类似的 PHP 版本页面。这表示您已将配置成功应用于您的 Linux 代理。</p><h3 id="Windows-代理-1"><a href="#Windows-代理-1" class="headerlink" title="Windows 代理"></a>Windows 代理</h3><p>在通过 RDP 连接到您的 Windows 代理后，在“Start”屏幕上查找 <strong>Start Command Prompt with Puppet</strong> 快捷方式。打开快捷方式的上下文 (右键单击) 菜单，然后选择 <strong>Run as administrator</strong>。运行以下命令以应用 <code>iisserver</code> 模块中的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puppet_interactive.bat</span><br></pre></td></tr></table></figure><p>您应看到与图 12 中的内容类似的输出，这指示已成功应用配置。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/12.png" alt=""></p><p><strong>图 12：Windows Puppet 代理输出</strong></p><p>最后，打开 Web 浏览器并导航到 info.aspx 页面。您将需要使用 <strong>WindowsAgent</strong> EC2 实例的公有 DNS 名称 — 例如，http://&lt;<em>public DNS name</em>&gt;/info.aspx。</p><p><img src="/AWS/AWS云上的Puppet-快速入门参考部署/13.png" alt=""></p><p><strong>图 13：测试 IIS Web 服务器</strong></p><p>您应看到与图 13 中所示内容类似的 IIS 版本页面。这表示您已将配置成功应用于您的 Windows 代理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本快速入门参考部署指南讨论在 Amazon Web Services (AWS) 云中部署和测试 Puppet Master 和 Puppet 代理所需的步骤。它还提供了用于查看和启动 &lt;a href=&quot;https://aws.amazon.com/cloudformati
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="AWS" scheme="http://blog.ozairs.com/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>2019年DevOps必备面试问题</title>
    <link href="http://blog.ozairs.com/DevOps/2019%E5%B9%B4DevOps%E5%BF%85%E5%A4%87%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ozairs.com/DevOps/2019年DevOps必备面试问题/</id>
    <published>2019-03-14T02:51:03.000Z</published>
    <updated>2019-03-14T03:34:20.327Z</updated>
    
    <content type="html"><![CDATA[<p>您是DevOps工程师还是想进入DevOps？那么，未来就是你的。顶级研究公司Forrester宣布2018年为“ <a href="https://go.forrester.com/blogs/2018-the-year-of-enterprise-devops/" target="_blank" rel="noopener">企业DevOps年</a> ”，并估计全球有50％的组织正在实施DevOps。</p><p>在这篇博客中，我列出了几十个可能的问题，面试官会问潜在的DevOps员工。此列表是根据Edureka教练的专业知识精心制作的，他们是行业专家，来自60个国家的近30,000名Edureka DevOps学习者的经验。</p><p>要理解的关键是DevOps不仅仅是一种技术集合，而是<a href="https://www.edureka.co/blog/devops-is-neither-a-method-nor-a-tool-its-a-culture/" target="_blank" rel="noopener">一种思维方式，一种文化</a>。DevOps需要一种将运营与发展相结合的文化转变，并需要一个相互关联的技术工具链来促进协作变革。由于DevOps理念仍处于初期阶段，因此DevOps的应用以及适应和协作所需的带宽因组织而异。但是，您可以开发<a href="https://www.edureka.co/blog/devops-skills" target="_blank" rel="noopener">DevOps技能组合，</a>使您成为任何类型组织的理想候选人。</p><p>如果您想以周到，有条理的方式开发DevOps技能并获得DevOps工程师认证，<a href="https://www.edureka.co/devops" target="_blank" rel="noopener">我们很乐意为您提供帮助</a>。完成Edureka DevOps认证课程后，我们承诺您将能够处理业内各种DevOps角色。</p><p><strong>成为DevOps工程师有哪些要求？</strong></p><p>在寻求填写DevOps角色时，组织会寻找一套清晰的技能。其中最重要的是：</p><ul><li>具有基础架构自动化工具的经验，如Chef，Puppet，Ansible，SaltStack或Windows PowerShell DSC。</li><li>熟练使用Ruby，Python，PHP或Java等网络语言。</li><li>人际关系技巧，可帮助您跨团队和角色进行沟通和协作。</li></ul><h2 id="顶级Devops面试问题"><a href="#顶级Devops面试问题" class="headerlink" title="顶级Devops面试问题"></a><strong>顶级Devops面试问题</strong></h2><p>这些是您在DevOps求职面试中可能遇到的首要问题：</p><p><strong>一般DevOps面试问题</strong></p><p>此类别将包含与任何特定DevOps阶段无关的问题。这里的问题旨在测试您对DevOps的理解，而不是关注特定工具或阶段。</p><h3 id="Q1。DevOps和Agile之间的根本区别是什么？"><a href="#Q1。DevOps和Agile之间的根本区别是什么？" class="headerlink" title="Q1。DevOps和Agile之间的根本区别是什么？"></a><strong>Q1。DevOps和Agile之间的根本区别是什么？</strong></h3><p>两者之间的差异列于下表中。</p><table><thead><tr><th><strong>特征</strong></th><th><strong>DevOps的</strong></th><th><strong>敏捷</strong></th></tr></thead><tbody><tr><td><strong>敏捷</strong></td><td>开发和运营方面的敏捷性</td><td>只有发展的敏捷性</td></tr><tr><td><strong>流程/实践</strong></td><td>涉及CI，CD，CT等流程。</td><td>涉及敏捷Scrum，敏捷看板等实践。</td></tr><tr><td><strong>重点关注领域</strong></td><td>及时性和质量同等重要</td><td>及时性是主要优先事项</td></tr><tr><td><strong>发布周期/开发冲刺</strong></td><td>较小的发布周期和即时反馈</td><td>较小的发布周期</td></tr><tr><td><strong>反馈来源</strong></td><td>反馈来自自我（监测工具）</td><td>反馈来自客户</td></tr><tr><td><strong>工作范围</strong></td><td>敏捷性和自动化需求</td><td>只有敏捷</td></tr></tbody></table><h3 id="Q2。DevOps需要什么？"><a href="#Q2。DevOps需要什么？" class="headerlink" title="Q2。DevOps需要什么？"></a><strong>Q2。DevOps需要什么？</strong></h3><p>据我所知，这个答案应该从解释一般市场趋势开始。公司不是发布大量功能，而是试图通过一系列发布列表来查看是否可以将小功能传输给客户。这具有许多优点，例如来自客户的快速反馈，更好的软件质量等，这反过来导致高的客户满意度。为实现这一目标，公司必须：</p><ol><li>增加部署频率</li><li>降低新版本的故障率</li><li>缩短了修复之间的准备时间</li><li>新版本崩溃时平均恢复时间更快</li></ol><p>DevOps满足所有这些要求，有助于实现无缝的软件交付。您可以举出像Etsy，Google和亚马逊这样的公司的例子，这些公司已经采用了<a href="https://www.edureka.co/blog/why-devops-improves-organization-performance/" target="_blank" rel="noopener">DevOps来达到</a>甚至五年前<a href="https://www.edureka.co/blog/why-devops-improves-organization-performance/" target="_blank" rel="noopener">无法</a>想象<a href="https://www.edureka.co/blog/why-devops-improves-organization-performance/" target="_blank" rel="noopener">的性能水平</a>。他们每天进行数十，数百甚至数千次代码部署，同时提供世界级的稳定性，可靠性和安全性。</p><p>如果我必须测试你对DevOps的了解，你应该知道Agile和DevOps之间的区别。下一个问题是针对这一点的。</p><h3 id="Q3。DevOps与Agile-SDLC有何不同？"><a href="#Q3。DevOps与Agile-SDLC有何不同？" class="headerlink" title="Q3。DevOps与Agile / SDLC有何不同？"></a><strong>Q3。DevOps与Agile / SDLC有何不同？</strong></h3><p>我建议你按照以下说明进行操作：</p><p>敏捷是一套关于如何生产即开发软件的价值观和原则。示例：如果您有一些想法，并且希望将这些想法转变为可用的软件，则可以使用敏捷值和原则作为实现此目的的方法。但是，该软件可能只适用于开发人员的笔记本电脑或测试环境。您希望以安全，简单的方式快速，轻松，可重复地将该软件移植到生产基础架构中。要做到这一点，您需要DevOps工具和技术。</p><p>您可以总结一下，敏捷软件开发方法侧重于软件的开发，但另一方面，DevOps负责开发以及以最安全和最可靠的方式部署软件。这是一个博客，将为您提供有关<a href="https://www.edureka.co/blog/what-is-devops/" target="_blank" rel="noopener">DevOps演变的</a>更多信息。</p><p>现在请记住，您在之前的答案中包含了DevOps工具，因此请准备好回答与此相关的一些问题。</p><h3 id="Q4。哪些是最顶级的DevOps工具？你做过哪些工具？"><a href="#Q4。哪些是最顶级的DevOps工具？你做过哪些工具？" class="headerlink" title="Q4。哪些是最顶级的DevOps工具？你做过哪些工具？"></a><strong>Q4。哪些是最顶级的DevOps工具？你做过哪些工具？</strong></h3><p>最受欢迎的DevOps工具如下所述：</p><ul><li>Git：版本控制系统工具</li><li>Jenkins：持续集成工具</li><li>Selenium：连续测试工具</li><li>Puppet，Chef，Ansible：配置管理和部署工具</li><li>Nagios：持续监控工具</li><li>Docker：容器化工具</li></ul><p>如果需要，您还可以提及任何其他工具，但请确保在答案中包含上述工具。<br>答案的第二部分有两种可能性：</p><ol><li>如果您有上述所有工具的经验，那么您可以说我已经使用所有这些工具来开发高质量的软件并轻松，经常和可靠地部署这些软件。</li><li>如果您只有上述某些工具的经验，那么请提及这些工具，并说我对这些工具有专业性，并对其余工具进行了概述。</li></ol><p>我们的DevOps认证课程包括最流行的DevOps工具的实际操作培训。<a href="https://www.edureka.co/devops" target="_blank" rel="noopener">找出下一批次开始的时间</a>。</p><h3 id="Q5。所有这些工具如何协同工作？"><a href="#Q5。所有这些工具如何协同工作？" class="headerlink" title="Q5。所有这些工具如何协同工作？"></a><strong>Q5。所有这些工具如何协同工作？</strong></h3><p>下面给出了一个通用的逻辑流程，其中所有内容都自动进行无缝交付 但是，根据要求，此流程可能因组织而异。</p><ol><li>开发人员开发代码，此源代码由Git等版本控制系统工具管理。</li><li>开发人员将此代码发送到Git存储库，并且代码中所做的任何更改都将提交到此存储库。</li><li>Jenkins使用Git插件从存储库中提取此代码，并使用Ant或Maven等工具构建它。</li><li>配置管理工具，如puppet部署和配置测试环境，然后Jenkins在测试环境中发布此代码，使用selenium等工具进行测试。</li><li>一旦代码被测试，Jenkins就会将其发送到生产服务器上进行部署（甚至生产服务器也由puppet等工具进行配置和维护）。</li><li>部署后，Nagios等工具会持续监控。</li><li>Docker容器提供测试环境来测试构建功能。</li></ol><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/2-DevOps-tools.png" alt="devops工具 -  devops面试问题"></p><h3 id="Q6。DevOps有哪些优势？"><a href="#Q6。DevOps有哪些优势？" class="headerlink" title="Q6。DevOps有哪些优势？"></a><strong>Q6。DevOps有哪些优势？</strong></h3><p>对于这个答案，您可以使用您过去的经验并解释DevOps如何帮助您完成上一份工作。如果您没有任何此类经验，那么您可以提及以下优势。</p><p>技术优势：</p><ul><li>持续的软件交付</li><li>修复不太复杂的问题</li><li>更快地解决问题</li></ul><p>商业利益：</p><ul><li>更快速地传递功能</li><li>更稳定的操作环境</li><li>更多时间可用于增加价值（而不是修复/维护）</li></ul><h3 id="Q7。DevOps帮助我们实现的最重要的事情是什么？"><a href="#Q7。DevOps帮助我们实现的最重要的事情是什么？" class="headerlink" title="Q7。DevOps帮助我们实现的最重要的事情是什么？"></a><strong>Q7。DevOps帮助我们实现的最重要的事情是什么？</strong></h3><p>据我所知，DevOps帮助我们实现的最重要的事情是尽可能快地将更改投入生产，同时最大限度地降低软件质量保证和合规性的风险。这是DevOps的主要目标。在<a href="https://www.edureka.co/blog/devops-tutorial" target="_blank" rel="noopener">DevOps教程</a>博客中了解更多信息。<br>但是，您可以添加DevOps的许多其他积极效果。例如，团队之间更清晰的沟通和更好的工作关系，即Ops团队和开发团队共同合作提供高质量的软件，从而提高客户满意度。</p><h3 id="Q8。解释DevOps可用于工业-现实生活中的用例。"><a href="#Q8。解释DevOps可用于工业-现实生活中的用例。" class="headerlink" title="Q8。解释DevOps可用于工业/现实生活中的用例。"></a><strong>Q8。解释DevOps可用于工业/现实生活中的用例。</strong></h3><p>有许多行业正在使用DevOps，所以你可以提到任何这些用例，你也可以参考下面的例子：<br>Etsy是一个点对点的电子商务网站，专注于手工或古董物品和用品，以及独特的工厂制造的物品。Etsy在缓慢，痛苦的网站更新中挣扎，经常导致网站崩溃。它影响了数百万Etsy用户的销售，这些用户通过在线市场销售商品并冒险将其推向竞争对手。<br>在新技术管理团队的帮助下，Etsy从其瀑布模型转变为更敏捷的方法，瀑布模型每周两次进行4小时全站点部署。如今，它拥有完全自动化的部署管道，据报道，其持续交付实践每天导致50多次部署，中断更少。</p><h3 id="Q9。解释您在过去曾与之合作过的组织的软件开发方面和技术操作方面的理解和专业知识。"><a href="#Q9。解释您在过去曾与之合作过的组织的软件开发方面和技术操作方面的理解和专业知识。" class="headerlink" title="Q9。解释您在过去曾与之合作过的组织的软件开发方面和技术操作方面的理解和专业知识。"></a><strong>Q9。解释您在过去曾与之合作过的组织的软件开发方面和技术操作方面的理解和专业知识。</strong></h3><p>对于这个答案，分享您过去的经验并尝试解释您在以前的工作中的灵活性。您可以参考以下示例：<br>DevOps工程师几乎总是在24/7关键业务在线环境中工作。我适应了随叫随到的职责，可以承担实时，实时系统的责任。我成功实现了自动化流程，以支持持续的软件部署 我有使用公共/私有云，Chef或Puppet等工具，使用Python和PHP等工具编写脚本和自动化的经验，以及Agile的背景知识。</p><h3 id="Q10。DevOps的反模式有哪些？"><a href="#Q10。DevOps的反模式有哪些？" class="headerlink" title="Q10。DevOps的反模式有哪些？"></a><strong>Q10。DevOps的反模式有哪些？</strong></h3><p>通常遵循一种模式。如果其他人普遍采用的模式对您的组织不起作用，并且您继续盲目地遵循它，那么您实际上采用的是反模式。有关于DevOps的神话。其中一些包括：</p><ul><li>DevOps是一个过程</li><li>敏捷等于DevOps？</li><li>我们需要一个单独的DevOps组</li><li>Devops将解决我们所有的问题</li><li>DevOps意味着开发人员管理生产</li><li>DevOps是开发驱动的发布管理<ol><li>DevOps不是开发驱动的。</li><li>DevOps不是IT运营驱动的。</li></ol></li><li>我们不能做DevOps - 我们是独一无二的</li><li>我们不能做DevOps - 我们遇到了错误的人</li></ul><h2 id="版本控制系统（VCS）面试问题"><a href="#版本控制系统（VCS）面试问题" class="headerlink" title="版本控制系统（VCS）面试问题"></a><strong>版本控制系统（VCS）面试问题</strong></h2><p>现在让我们来看看有关VCS的一些访谈问题。如果您希望获得像Git这样的VCS的实际操作培训，它将包含在我们的<a href="https://www.edureka.co/devops" target="_blank" rel="noopener">DevOps认证课程中。</a></p><h3 id="Q1。什么是版本控制？"><a href="#Q1。什么是版本控制？" class="headerlink" title="Q1。什么是版本控制？"></a><strong>Q1。什么是版本控制？</strong></h3><p>这可能是您在面试中将面临的最简单的问题。我的建议是首先给出版本控制的定义。它是一个记录文件或文件集随时间变化的系统，以便您以后可以调用特定版本。版本控制系统由一个中央共享存储库组成，队友可以在其中提交对文件或文件集的更改。然后你可以提到版本控制的用途。</p><p>版本控制允许您：</p><ul><li>将文件还原为以前的状态。</li><li>将整个项目还原为以前的状态。</li><li>比较一段时间内的变化</li><li>查看最后一次修改可能导致问题的内容。</li><li>谁介绍了一个问题，何时。</li></ul><h2 id="Q2。使用版本控制有什么好处？"><a href="#Q2。使用版本控制有什么好处？" class="headerlink" title="Q2。使用版本控制有什么好处？"></a><strong>Q2。使用版本控制有什么好处？</strong></h2><p>我建议你包括版本控制的以下优点：</p><ol><li>使用版本控制系统（VCS），所有团队成员都可以随时在任何文件上自由工作。稍后VCS将允许您将所有更改合并到一个通用版本中。</li><li>所有过去的版本和变体都整齐地打包在VCS中。当您需要它时，您可以随时请求任何版本，您将获得完整项目的快照。</li><li>每次保存项目的新版本时，VCS都要求您提供已更改内容的简短说明。此外，您还可以查看文件内容的确切更改内容。这可以让您知道谁在项目中做了哪些更改。</li><li>像Git这样的分布式VCS允许所有团队成员拥有项目的完整历史记录，因此如果中央服务器出现故障，您可以使用任何团队成员的本地Git存储库。</li></ol><h3 id="Q3。描述您使用的分支策略。"><a href="#Q3。描述您使用的分支策略。" class="headerlink" title="Q3。描述您使用的分支策略。"></a><strong>Q3。描述您使用的分支策略。</strong></h3><p>这个问题被要求测试你的分支经验，告诉他们你在以前的工作中如何使用分支以及它的用途是什么，你可以参考以下几点：</p><ul><li>功能分支<br>功能分支模型保留分支内特定功能的所有更改。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。</li><li>任务分支<br>在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。</li><li>发布分支<br>一旦开发分支为发布获得了足够的功能，您就可以克隆该分支以形成发布分支。创建此分支将启动下一个发布周期，因此在此之后不能添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它应该合并回到开发分支，自发布以来可能已经取得了进展。</li></ul><p>最后告诉他们分支策略因组织而异，所以我知道基本的分支操作，如删除，合并，检查分支等。</p><h3 id="Q4。您熟悉哪种VCS工具？"><a href="#Q4。您熟悉哪种VCS工具？" class="headerlink" title="Q4。您熟悉哪种VCS工具？"></a><strong>Q4。您熟悉哪种VCS工具？</strong></h3><p>你可以提到你曾经使用的VCS工具：“我已经使用过Git，它对SVN等其他VCS工具的一个主要优势就是它是一个分布式版本控制系统。”<br>分布式VCS工具不一定依靠中央服务器来存储项目文件的所有版本。相反，每个开发人员都“克隆”存储库的副本，并在自己的硬盘上拥有项目的完整历史记录。</p><h3 id="Q5。什么是Git？"><a href="#Q5。什么是Git？" class="headerlink" title="Q5。什么是Git？"></a><strong>Q5。什么是Git？</strong></h3><p>我建议您首先解释一下git的体系结构来尝试这个问题，如下图所示。您可以参考下面给出的解释：</p><ul><li>Git是一个分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许您恢复到任何特定的更改。</li><li>与SVN等其他版本控制系统（VCS）相比，它的分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。相反，每个开发人员“克隆”我在下图中使用“本地存储库”显示的存储库副本，并在其硬盘驱动器上具有项目的完整历史记录，以便在出现服务器中断时，恢复所需的全部内容是你队友的本地Git存储库之一。</li><li>还有一个中央云存储库，开发人员可以在其中提交更改并与其他团队成员共享，如图所示，所有协作者都在提交更改“远程存储库”。</li></ul><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/Git-architecture-devops-interview-questions.png" alt="git架构 -  devops面试问题"></p><h3 id="Q6。解释一些基本的Git命令？"><a href="#Q6。解释一些基本的Git命令？" class="headerlink" title="Q6。解释一些基本的Git命令？"></a><strong>Q6。解释一些基本的Git命令？</strong></h3><p>以下是一些基本的Git命令：</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/Git.png" alt="git命令 -  devops面试问题"></p><h3 id="Q7。在Git中，您如何还原已经被推送并公开的提交？"><a href="#Q7。在Git中，您如何还原已经被推送并公开的提交？" class="headerlink" title="Q7。在Git中，您如何还原已经被推送并公开的提交？"></a><strong>Q7。在Git中，您如何还原已经被推送并公开的提交？</strong></h3><p>此问题可以有两个答案，因此请确保包含两个答案，因为根据具体情况可以使用以下任何选项：</p><ul><li>在新提交中删除或修复错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的更改后，将其提交到远程存储库，我将使用<br><strong>git commit -m“commit message”</strong></li><li>创建一个新的提交，撤消在错误提交中所做的所有更改。为此，我将使用命令<br><strong>git revert <bad of="" bad="" commit=""></bad></strong></li></ul><h3 id="Q8。你如何将N次提交压缩成一次提交？"><a href="#Q8。你如何将N次提交压缩成一次提交？" class="headerlink" title="Q8。你如何将N次提交压缩成一次提交？"></a><strong>Q8。你如何将N次提交压缩成一次提交？</strong></h3><p>将N个提交压缩到单个提交中有两种选择。在您的答案中包括以下两个选项：</p><ul><li>如果要从头开始编写新的提交消息，请使用以下命令<br><strong>git reset -soft HEAD~N &amp;&amp;</strong><br><strong>git commit</strong></li><li>如果你想用现有提交消息的串联开始编辑新的提交消息，那么你需要提取这些消息并将它们传递给Git commit，我将使用<br><strong>git reset -soft HEAD~N &amp;&amp;</strong><br><strong>git commit -edit -m “$（git log -format =％B -reverse .HEAD @ {N}）”</strong></li></ul><p>DevOps认证培训观看课程预览</p><h3 id="Q9。什么是Git-bisect？你怎么用它来确定（回归）bug的来源？"><a href="#Q9。什么是Git-bisect？你怎么用它来确定（回归）bug的来源？" class="headerlink" title="Q9。什么是Git bisect？你怎么用它来确定（回归）bug的来源？"></a><strong>Q9。什么是Git bisect？你怎么用它来确定（回归）bug的来源？</strong></h3><p>我建议你先给出一个Git bisect的小定义，Git bisect用于查找通过二进制搜索引入bug的提交。Git bisect的命令是<br><strong>git bisect &lt;子命令&gt; <options></options></strong>现在你已经提到了上面的命令，解释一下这个命令会做什么，这个命令使用二进制搜索算法来查找项目历史中哪个提交引入了一个bug。您可以通过首先告诉它已知包含该错误的“错误”提交以及在引入错误之前已知的“良好”提交来使用它。然后Git bisect在这两个端点之间选择一个提交，并询问您所选的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。</p><h3 id="Q10。什么是Git-rebase以及它如何在合并之前用于解决功能分支中的冲突？"><a href="#Q10。什么是Git-rebase以及它如何在合并之前用于解决功能分支中的冲突？" class="headerlink" title="Q10。什么是Git rebase以及它如何在合并之前用于解决功能分支中的冲突？"></a><strong>Q10。什么是Git rebase以及它如何在合并之前用于解决功能分支中的冲突？</strong></h3><p>根据我的说法，您应首先说git rebase是一个命令，它将另一个分支合并到您当前正在工作的分支中，并将所有位于重新分支之前的本地提交移到该历史记录的顶部。科。<br>现在，一旦您为一个示例定义了Git rebase时间，以显示如何在合并之前使用它来解决功能分支中的冲突，如果从master创建了一个功能分支，那么主分支已经收到了新的提交，Git rebase可用于将要素分支移动到主要提示。<br>该命令有效地将重放在master的tip处的功能分支中所做的更改，从而允许在该过程中解决冲突。完成后，这将允许功能分支相对容易地合并到主服务器中，有时作为简单的快进操作。</p><h3 id="Q11。如何配置Git存储库以在提交之前运行代码健全性检查工具，并在测试失败时阻止它们？"><a href="#Q11。如何配置Git存储库以在提交之前运行代码健全性检查工具，并在测试失败时阻止它们？" class="headerlink" title="Q11。如何配置Git存储库以在提交之前运行代码健全性检查工具，并在测试失败时阻止它们？"></a><strong>Q11。如何配置Git存储库以在提交之前运行代码健全性检查工具，并在测试失败时阻止它们？</strong></h3><p>我建议你先介绍一下理智检查，理智或烟雾测试 确定继续测试是否可行和合理。<br>现在解释如何实现这一点，这可以通过与存储库的预提交钩子相关的简单脚本来完成。即使在您需要输入提交消息之前，也会在提交之前触发预提交挂钩。在此脚本中，可以运行其他工具，例如linters，并对提交到存储库中的更改执行完整性检查。<br>最后给出一个例子，你可以参考下面的脚本：<br><strong>＃！/ bin / sh files = $（git diff -cached -name-only -diff-filter = ACM | grep’.go $’）if [-z files] ; 然后退出0 fi unfmtd = $（gofmt -l $ files）如果[-z unfmtd]; 然后退出0 fi echo“一些.go文件不是fmt’d” 退出1</strong>此脚本检查是否需要通过标准Go源代码格式化工具gofmt传递任何即将提交的.go文件。通过以非零状态退出，脚本有效地阻止将提交应用于存储库。</p><h3 id="Q12。如何找到特定提交中已更改的文件列表？"><a href="#Q12。如何找到特定提交中已更改的文件列表？" class="headerlink" title="Q12。如何找到特定提交中已更改的文件列表？"></a><strong>Q12。如何找到特定提交中已更改的文件列表？</strong></h3><p>对于这个答案，而不是只是告诉命令，解释这个命令究竟会做什么，所以你可以这么说，为了获得在特定提交中更改的列表文件使用命令<br><strong>git diff-tree -r {hash}</strong><br>给定提交哈希，这将列出在该提交中更改或添加的所有文件。-r标志使命令列表单个文件，而不是仅将它们折叠到根目录名称中。<br>你也可以包括下面提到的点，虽然它是完全可选的，但有助于给面试官留下深刻的印象。<br>输出还将包含一些额外的信息，可以通过包含两个标志来轻松抑制：<br><strong>git diff-tree -no-commit-id -name-only -r {hash}</strong><br>这里-no-commit-id将禁止提交哈希值出现在输出中，而-name-only只会打印文件名而不是它们的路径。</p><h3 id="Q13。每次存储库通过推送接收新提交时，如何设置脚本运行？"><a href="#Q13。每次存储库通过推送接收新提交时，如何设置脚本运行？" class="headerlink" title="Q13。每次存储库通过推送接收新提交时，如何设置脚本运行？"></a><strong>Q13。每次存储库通过推送接收新提交时，如何设置脚本运行？</strong></h3><p>每次存储库通过push接收新提交时，有三种方法可以配置脚本运行，需要根据需要触发脚本的时间来定义预接收，更新或后接收挂钩。</p><ul><li>将提交提交到目标存储库时，将调用目标存储库中的预接收挂钩。绑定到此挂钩的任何脚本都将在更新任何引用之前执行。这是一个有用的钩子，用于运行有助于实施开发策略的脚本。</li><li>Update钩子以类似于预接收钩子的方式工作，并且在实际进行任何更新之前也会触发。但是，对于已推送到目标存储库的每个提交，都会调用一次update钩子。</li><li>最后，在将更新接受到目标存储库之后，将调用存储库中的post-receive挂钩。这是配置简单部署脚本，调用一些持续集成系统，向存储库维护人员发送通知电子邮件等的理想场所。</li></ul><p>钩子是每个Git存储库的本地存储，并且没有版本化。脚本可以在“.git”目录内的hooks目录中创建，也可以在别处创建，并且可以在目录中放置这些脚本的链接。</p><h3 id="Q14。如果分支已经合并为主分支，你怎么知道Git？"><a href="#Q14。如果分支已经合并为主分支，你怎么知道Git？" class="headerlink" title="Q14。如果分支已经合并为主分支，你怎么知道Git？"></a><strong>Q14。如果分支已经合并为主分支，你怎么知道Git？</strong></h3><p>我建议你包括下面提到的命令：<br>git branch -merged列出已合并到当前分支的分支。<br>git branch -no-merged列出了尚未合并的分支。</p><h2 id="持续整合问题"><a href="#持续整合问题" class="headerlink" title="持续整合问题"></a><strong>持续整合问题</strong></h2><p>现在，让我们来看看持续集成面试问题：</p><h3 id="Q1。持续集成是什么意思？"><a href="#Q1。持续集成是什么意思？" class="headerlink" title="Q1。持续集成是什么意思？"></a><strong>Q1。持续集成是什么意思？</strong></h3><p>我将建议您通过给出持续集成（CI）的小定义来开始这个答案。这是一种开发实践，需要开发人员每天多次将代码集成到共享存储库中。然后通过自动构建验证每个签入，允许团队尽早发现问题。<br>我建议您解释一下如何在以前的工作中实施它。您可以参考以下给出的示例：</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/Jenkins-standalone-architecture-Jenkins-tutorial-What-is-Jenkins-Edureka.png" alt="Jenkins独立架构 -  devops面试问题"></p><p>在上图中：</p><ol><li>开发人员将代码签入其私有工作区。</li><li>完成后，他们将更改提交到共享存储库（版本控制存储库）。</li><li>CI服务器监视存储库并在发生更改时检出更改。</li><li>然后，CI服务器将提取这些更改并构建系统，并运行单元和集成测试。</li><li>CI服务器现在将通知团队成功构建。</li><li>如果构建或测试失败，CI服务器将向团队发出警报。</li><li>该团队将尽早解决问题。</li><li>这个过程不断重复。</li></ol><h3 id="Q2。为什么需要开发和测试的持续集成？"><a href="#Q2。为什么需要开发和测试的持续集成？" class="headerlink" title="Q2。为什么需要开发和测试的持续集成？"></a><strong>Q2。为什么需要开发和测试的持续集成？</strong></h3><p>对于这个答案，您应该关注持续集成的需求。我的建议是在你的答案中提到以下解释：<br>开发和测试的持续集成通过在完成所有开发之后替换传统的测试实践来提高软件质量并减少交付时间。它允许Dev团队尽早检测和定位问题，因为开发人员需要每天多次（更频繁地）将代码集成到共享存储库中。然后自动测试每个登记入住。</p><h3 id="Q3。持续集成的成功因素有哪些？"><a href="#Q3。持续集成的成功因素有哪些？" class="headerlink" title="Q3。持续集成的成功因素有哪些？"></a><strong>Q3。持续集成的成功因素有哪些？</strong></h3><p>在这里，您必须提到持续集成的要求。您可以在答案中包含以下几点：</p><ul><li>维护代码存储库</li><li>自动化构建</li><li>使构建自我测试</li><li>每个人每天承诺到基线</li><li>应该构建每个提交（到基线）</li><li>保持快速构建</li><li>在生产环境的克隆中进行测试</li><li>让您轻松获得最新的可交付成果</li><li>每个人都可以看到最新版本的结果</li><li>自动部署</li></ul><h3 id="Q4。解释如何将Jenkins从一台服务器移动或复制到另一台服务器？"><a href="#Q4。解释如何将Jenkins从一台服务器移动或复制到另一台服务器？" class="headerlink" title="Q4。解释如何将Jenkins从一台服务器移动或复制到另一台服务器？"></a><strong>Q4。解释如何将Jenkins从一台服务器移动或复制到另一台服务器？</strong></h3><p>我将通过将jobs目录从旧服务器复制到新服务器来完成此任务。有多种方法可以做到这一点; 我在下面提到过它们：<br>你可以：</p><ul><li>只需复制相应的作业目录，即可将作业从一个Jenkins安装移动到另一个。</li><li>通过使用其他名称克隆作业目录来制作现有作业的副本。</li><li>通过重命名目录重命名现有作业。请注意，如果更改作业名称，则需要更改尝试调用重命名作业的任何其他作业。</li></ul><h3 id="Q5。解释如何在Jenkins中创建备份和复制文件？"><a href="#Q5。解释如何在Jenkins中创建备份和复制文件？" class="headerlink" title="Q5。解释如何在Jenkins中创建备份和复制文件？"></a><strong>Q5。解释如何在Jenkins中创建备份和复制文件？</strong></h3><p>回答这个问题真的很直接。要创建备份，您需要做的就是定期备份JENKINS_HOME目录。这包含所有构建作业配置，从属节点配置和构建历史记录。要创建Jenkins设置的备份，只需复制此目录即可。您还可以复制作业目录以克隆或复制作业或重命名目录。</p><h3 id="Q6。解释如何设置Jenkins工作？"><a href="#Q6。解释如何设置Jenkins工作？" class="headerlink" title="Q6。解释如何设置Jenkins工作？"></a><strong>Q6。解释如何设置Jenkins工作？</strong></h3><p>我对这个答案的解决方法是首先提一下如何创建Jenkins的工作。转到Jenkins首页，选择“New Job”，然后选择“Build a free-style software project”。<br>然后你可以告诉这个自由式工作的元素：</p><ul><li>可选的SCM，例如源代码所在的CVS或Subversion。</li><li>用于控制Jenkins何时执行构建的可选触发器。</li><li>某种构建脚本，用于执行实际工作的构建（ant，maven，shell脚本，批处理文件等）。</li><li>从构建中收集信息的可选步骤，例如归档工件和/或记录javadoc和测试结果。</li><li>使用构建结果通知其他人/系统的可选步骤，例如发送电子邮件，IM，更新问题跟踪器等。</li></ul><h3 id="Q7。提到Jenkins中一些有用的插件。"><a href="#Q7。提到Jenkins中一些有用的插件。" class="headerlink" title="Q7。提到Jenkins中一些有用的插件。"></a><strong>Q7。提到Jenkins中一些有用的插件。</strong></h3><p>下面，我提到了一些重要的插件：</p><ul><li>Maven 2项目</li><li>亚马逊EC2</li><li>HTML发布者</li><li>复制工件</li><li>加入</li><li>绿球</li></ul><h3 id="Q8。你如何保护Jenkins？"><a href="#Q8。你如何保护Jenkins？" class="headerlink" title="Q8。你如何保护Jenkins？"></a><strong>Q8。你如何保护Jenkins？</strong></h3><p>我保护Jenkins的方式如下所述。如果您有任何其他方式，请在下面的评论部分中提及：</p><ul><li>确保全球安全。</li><li>确保Jenkins与我公司的用户目录与适当的插件集成。</li><li>确保启用矩阵/项目矩阵以微调访问。</li><li>使用自定义版本控制的脚本自动化在Jenkins中设置权限/特权的过程。</li><li>限制对Jenkins数据/文件夹的物理访问。</li><li>定期对其进行安全审核。</li></ul><p>Jenkins是DevOps中广泛使用的众多流行工具之一。</p><h2 id="持续测试面试问题："><a href="#持续测试面试问题：" class="headerlink" title="持续测试面试问题："></a><strong>持续测试面试问题：</strong></h2><p>现在让我们继续讨论持续测试问题。</p><h3 id="Q1。什么是连续测试？"><a href="#Q1。什么是连续测试？" class="headerlink" title="Q1。什么是连续测试？"></a><strong>Q1。什么是连续测试？</strong></h3><p>我将建议您遵循以下提到的解释：<br>持续测试是将自动化测试作为软件交付管道的一部分执行的过程，以获得与最新构建相关的业务风险的即时反馈。通过这种方式，每个构建都会持续测试，允许开发团队获得快速反馈，以便他们可以防止这些问题进入软件交付生命周期的下一阶段。这大大加快了开发人员的工作流程，因为无需手动重建项目并在进行更改后重新运行所有测试。</p><h3 id="Q2。什么是自动化测试？"><a href="#Q2。什么是自动化测试？" class="headerlink" title="Q2。什么是自动化测试？"></a><strong>Q2。什么是自动化测试？</strong></h3><p>自动化测试或测试自动化是自动化手动过程以测试被测应用程序/系统的过程。自动化测试涉及使用单独的测试工具，使您可以创建可以重复执行的测试脚本，而不需要任何手动干预。</p><h3 id="Q3。-自动化测试有哪些好处-？"><a href="#Q3。-自动化测试有哪些好处-？" class="headerlink" title="Q3。 自动化测试有哪些好处**？**"></a><strong>Q3。</strong> <strong>自动化测试有哪些好处**</strong>？**</h3><p>我列举了自动化测试的一些优点。在您的答案中包含这些内容，您可以添加自己的经验，了解Continuous Testing如何帮助您以前的公司：</p><ul><li>支持执行重复的测试用例</li><li>有助于测试大型测试矩阵</li><li>启用并行执行</li><li>鼓励无人看管的执行</li><li>提高准确性，从而减少人为产生的错误</li><li>节省时间和金钱</li></ul><h3 id="Q4。如何在DevOps生命周期中自动化测试？"><a href="#Q4。如何在DevOps生命周期中自动化测试？" class="headerlink" title="Q4。如何在DevOps生命周期中自动化测试？"></a><strong>Q4。如何在DevOps生命周期中自动化测试？</strong></h3><p>我已经提到了一个通用流程，您可以在其中参考：<br>在DevOps中，开发人员需要将源代码中的所有更改提交到共享存储库。像Jenkins这样的持续集成工具每次在代码中进行更改时都会从此共享存储库中提取代码，并将其部署到连续测试中，这些工作由Selenium等工具完成，如下图所示。<br>通过这种方式，与传统方法不同，代码的任何变化都会不断进行测试。</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/automate-testing-devops-interview-questions.png" alt="自动化测试 -  devops面试问题"></p><h3 id="Q5。-为什么持续测试对DevOps很重要？"><a href="#Q5。-为什么持续测试对DevOps很重要？" class="headerlink" title="Q5。**为什么持续测试对DevOps很重要？**"></a><strong>Q5。**</strong>为什么持续测试对DevOps很重要？**</h3><p>您可以通过说“连续测试允许立即测试代码中的任何更改来回答这个问题。这避免了在周期结束时进行“大爆炸”测试所产生的问题，例如发布延迟和质量问题。通过这种方式，持续测试可以促进更频繁和更好的质量发布。“</p><h3 id="Q6。连续测试工具的关键要素是什么？"><a href="#Q6。连续测试工具的关键要素是什么？" class="headerlink" title="Q6。连续测试工具的关键要素是什么？"></a><strong>Q6。连续测试工具的关键要素是什么？</strong></h3><p>连续测试的关键要素是：</p><ul><li><strong>风险评估：</strong>它涵盖风险缓解任务，技术债务，质量评估和测试覆盖范围优化，以确保构建准备好向下一阶段发展。</li><li><strong>策略分析：</strong>确保所有流程符合组织不断发展的业务和合规性要求。</li><li><strong>要求可追溯性：</strong>确保满足真正的要求，不需要返工。对象评估用于确定哪些需求存在风险，按预期工作或需要进一步验证。</li><li><strong>高级分析：</strong>它在静态代码分析，变更影响分析和范围评估/优先级划分等领域使用自动化，以便首先防止缺陷并在每次迭代中完成更多工作。</li><li><strong>测试优化：</strong>确保测试产生准确的结果并提供可操作的结果。方面包括测试数据管理，测试优化管理和测试维护</li><li><strong>服务虚拟化：</strong>它确保访问真实的测试环境。服务可视化使您能够访问所需测试阶段的虚拟表单，从而缩短测试环境设置和可用性的浪费时间。</li></ul><h3 id="Q7。您熟悉哪种测试工具以及该工具的优点是什么？"><a href="#Q7。您熟悉哪种测试工具以及该工具的优点是什么？" class="headerlink" title="Q7。您熟悉哪种测试工具以及该工具的优点是什么？"></a><strong>Q7。您熟悉哪种测试工具以及该工具的优点是什么？</strong></h3><p>这里提到您使用过的测试工具，并相应地构建您的答案。我已经提到了一个例子：<br>我已经在Selenium上工作，以确保高质量和更频繁的发布。</p><p>Selenium的一些优点是：</p><ul><li>它是免费和开源的</li><li>它拥有庞大的用户群和帮助社区</li><li>它具有跨浏览器兼容性（Firefox，Chrome，Internet Explorer，Safari等）</li><li>它具有出色的平台兼容性（Windows，Mac OS，Linux等）</li><li>它支持多种编程语言（Java，C＃，Ruby，Python，Pearl等）</li><li>它有新的和定期的存储库开发</li><li>它支持分布式测试</li></ul><h3 id="Q8。Selenium支持哪些测试类型？"><a href="#Q8。Selenium支持哪些测试类型？" class="headerlink" title="Q8。Selenium支持哪些测试类型？"></a><strong>Q8。Selenium支持哪些测试类型？</strong></h3><p>Selenium支持两种类型的测试：<br><strong>回归测试</strong>：它是在修复错误的区域周围重新测试产品的行为。<br><strong>功能测试</strong>：它指的是单独测试软件功能（功能点）。</p><h3 id="Q9。什么是Selenium-IDE？"><a href="#Q9。什么是Selenium-IDE？" class="headerlink" title="Q9。什么是Selenium IDE？"></a><strong>Q9。什么是Selenium IDE？</strong></h3><p>我的建议是通过定义Selenium IDE来开始这个答案。它是Selenium脚本的集成开发环境。它作为Firefox扩展实现，允许您记录，编辑和调试测试。Selenium IDE包含整个Selenium Core，允许您在他们将运行的实际环境中轻松快速地记录和回放测试。<br>现在，您的答案中包含一些优势。凭借自动完成支持和快速移动命令的能力，无论您喜欢何种类型的测试，Selenium IDE都是创建Selenium测试的理想环境。</p><h3 id="Q10。Selenium中的Assert和Verify命令有什么区别？"><a href="#Q10。Selenium中的Assert和Verify命令有什么区别？" class="headerlink" title="Q10。Selenium中的Assert和Verify命令有什么区别？"></a><strong>Q10。Selenium中的Assert和Verify命令有什么区别？</strong></h3><p>我在下面提到了Assert和Verify命令之间的区别：</p><ul><li>断言命令检查给定条件是真还是假。假设我们断言给定元素是否存在于网页上。如果条件为真，则程序控制将执行下一个测试步骤。但是，如果条件为假，则执行将停止，并且不会执行进一步的测试。</li><li>Verify命令还会检查给定条件是true还是false。无论条件是真还是假，程序执行都不会停止，即验证期间的任何故障都不会停止执行，并且所有测试步骤都将被执行。</li></ul><h3 id="Q11。如何使用WebDriver启动浏览器？"><a href="#Q11。如何使用WebDriver启动浏览器？" class="headerlink" title="Q11。如何使用WebDriver启动浏览器？"></a><strong>Q11。如何使用WebDriver启动浏览器？</strong></h3><p>以下语法可用于启动Browser：<br><strong>WebDriver driver = new FirefoxDriver（）;</strong><br><strong>WebDriver driver = new ChromeDriver（）;</strong><br><strong>WebDriver driver = new InternetExplorerDriver（）;</strong></p><h3 id="Q12。-我什么时候应该使用Selenium-Grid？"><a href="#Q12。-我什么时候应该使用Selenium-Grid？" class="headerlink" title="Q12。**我什么时候应该使用Selenium Grid？**"></a><strong>Q12。**</strong>我什么时候应该使用Selenium Grid？**</h3><p>对于这个答案，我的建议是给出Selenium Grid的一个小定义。它可以用于在多个平台和浏览器上同时执行相同或不同的测试脚本，以实现分布式测试执行。这允许在不同环境下进行测试并显着节省执行时间。</p><p>在我们的DevOps认证课程中，通过现场讲师指导的在线课程学习自动化测试和其他DevOps概念。</p><p><a href="https://www.edureka.co/devops/" target="_blank" rel="noopener"><strong>立即使用DevOps进行自动化测试&gt;&gt;</strong></a></p><h2 id="配置管理面试问题"><a href="#配置管理面试问题" class="headerlink" title="配置管理面试问题"></a><strong>配置管理面试问题</strong></h2><p>现在让我们来看看你对Configuration Management的了解程度。</p><h3 id="Q1。配置管理流程的目标是什么？"><a href="#Q1。配置管理流程的目标是什么？" class="headerlink" title="Q1。配置管理流程的目标是什么？"></a><strong>Q1。配置管理流程的目标是什么？</strong></h3><p>配置管理（CM）的目的是通过使开发或部署过程可控且可重复，确保产品或系统在其整个生命周期中的完整性，从而创建更高质量的产品或系统。CM流程允许有序管理系统信息和系统更改，以便：</p><ul><li>修改能力，</li><li>提高性能，</li><li>可靠性或可维护性，</li><li>延长寿命，</li><li>降低成本，</li><li>降低风险和</li><li>责任或纠正缺陷。</li></ul><h3 id="Q2。资产管理和配置管理有什么区别？"><a href="#Q2。资产管理和配置管理有什么区别？" class="headerlink" title="Q2。资产管理和配置管理有什么区别？"></a><strong>Q2。资产管理和配置管理有什么区别？</strong></h3><p>以下是资产管理和配置管理之间的一些差异：</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/asset-management-configuration-management-devops-interview-questions.png" alt="资产管理配置管理 -  devops面试问题"></p><h3 id="Q3。资产和配置项有什么区别？"><a href="#Q3。资产和配置项有什么区别？" class="headerlink" title="Q3。资产和配置项有什么区别？"></a><strong>Q3。资产和配置项有什么区别？</strong></h3><p>据我说，你应该首先解释资产。它具有财务价值以及附加的折旧率。IT资产只是它的一个子集。任何具有成本的组织和组织都将其用于资产价值计算和税收计算中的相关收益属于资产管理，此类项目称为资产。<br>另一方面，配置项可能有也可能没有分配给它的财务值。它不会有任何与之相关的折旧。因此，它的生命不依赖于其财务价值，而是取决于该项目对该组织过时的时间。</p><p>现在，您可以举例说明两者之间的相似性和差异：<br>1）相似性：<br>服务器 - 它既是资产又是CI。<br>2）差异：<br>建筑 - 这是一种资产，但不是CI。<br>文档 - 它是CI但不是资产</p><h3 id="Q4。您对“基础设施作为代码”有何看法？它如何适用于DevOps方法？它的目的是什么？"><a href="#Q4。您对“基础设施作为代码”有何看法？它如何适用于DevOps方法？它的目的是什么？" class="headerlink" title="Q4。您对“基础设施作为代码”有何看法？它如何适用于DevOps方法？它的目的是什么？"></a><strong>Q4。您对“基础设施作为代码”有何看法？它如何适用于DevOps方法？它的目的是什么？</strong></h3><p>作为代码的基础架构（IAC）是一种IT基础架构，运营团队可以使用它来自动管理和通过代码进行配置，而不是使用手动过程。<br>更快部署的公司会将软件等基础设施视为可以使用DevOps工具和流程管理的代码。利用这些工具，您可以更轻松，快速，安全，可靠地更改基础架构。</p><h3 id="Q5。Puppet，Chef，SaltStack和Ansible中哪一个是最好的配置管理（CM）工具？为什么？"><a href="#Q5。Puppet，Chef，SaltStack和Ansible中哪一个是最好的配置管理（CM）工具？为什么？" class="headerlink" title="Q5。Puppet，Chef，SaltStack和Ansible中哪一个是最好的配置管理（CM）工具？为什么？"></a><strong>Q5。Puppet，Chef，SaltStack和Ansible中哪一个是最好的配置管理（CM）工具？为什么？</strong></h3><p>这取决于组织的需求，因此在所有这些工具上提到几点：<br>Puppet是最古老，最成熟的CM工具。Puppet是一个基于Ruby的配置管理工具，虽然它有一些免费功能，但Puppet很棒的大部分内容仅在付费版本中可用。不需要大量额外功能的组织会发现Puppet很有用，但那些需要更多自定义的组织可能需要升级到付费版本。<br>Chef是用Ruby编写的，因此可以由熟悉该语言的人定制。它还包括免费功能，如果需要，还可以从开源升级到企业级。最重要的是，它是一个非常灵活的产品。<br>Ansible是一个非常安全的选项，因为它使用Secure Shell。它是一个简单的工具，但除了配置管理之外，它还提供了许多其他服务。它非常容易学习，因此非常适合那些没有专职IT人员但仍需要配置管理工具的人。<br>SaltStack是基于python的开源CM工具，适用于大型企业，但其学习曲线相当低。</p><h3 id="Q6。什么是Puppet？"><a href="#Q6。什么是Puppet？" class="headerlink" title="Q6。什么是Puppet？"></a><strong>Q6。什么是Puppet？</strong></h3><p>我会建议你先给出一个小小的Puppet定义。它是一个配置管理工具，用于自动执行管理任务。<br>现在您应该描述其架构以及Puppet如何管理其代理。Puppet有一个Master-Slave架构，其中Slave必须首先向Master发送证书签名请求，Master必须签署该证书才能在Puppet Master和Puppet Slave之间建立安全连接，如下图所示。Puppet Slave向Puppet Master和Puppet Master发送请求，然后在Slave上推送配置。<br>请参阅下面的图解释上述说明。</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/what-is-puppet-devops-interview-questions-1.png" alt="什么是傀儡 -  devops面试问题"></p><h3 id="Q7。-在客户端使用Puppet-Master进行身份验证之前，需要对其证书进行签名和接受。你将如何自动完成这项任务？"><a href="#Q7。-在客户端使用Puppet-Master进行身份验证之前，需要对其证书进行签名和接受。你将如何自动完成这项任务？" class="headerlink" title="Q7。**在客户端使用Puppet Master进行身份验证之前，需要对其证书进行签名和接受。你将如何自动完成这项任务？**"></a><strong>Q7。**</strong>在客户端使用Puppet Master进行身份验证之前，需要对其证书进行签名和接受。你将如何自动完成这项任务？**</h3><p>最简单的方法是在puppet.conf中启用自动签名。<br>请注意这是一个安全风险。如果您仍想这样做：</p><ul><li>防火墙您的Puppet大师 - 将端口tcp / 8140限制为仅您信任的网络。</li><li>为每个“信任区域”创建Puppet大师，并且只在该Puppet大师清单中包含可信节点。</li><li>切勿使用完整的通配符，例如*。</li></ul><h3 id="Q8。描述通过Puppet自动化流程所取得的最重要的收益。"><a href="#Q8。描述通过Puppet自动化流程所取得的最重要的收益。" class="headerlink" title="Q8。描述通过Puppet自动化流程所取得的最重要的收益。"></a><strong>Q8。描述通过Puppet自动化流程所取得的最重要的收益。</strong></h3><p>对于这个答案，我建议你解释一下你过去使用Puppet的经历。您可以参考以下示例：<br>我使用Puppet自动配置和部署Linux和Windows机器。除了将处理时间从一周缩短到10分钟之外，我还使用了角色和配置文件模式，并在README中记录了每个模块的用途，以确保其他人可以使用Git更新模块。我写的模块仍然在使用，但是我的团队成员和社区成员对它们进行了改进</p><h3 id="Q9。您使用哪些开源或社区工具来使Puppet更强大？"><a href="#Q9。您使用哪些开源或社区工具来使Puppet更强大？" class="headerlink" title="Q9。您使用哪些开源或社区工具来使Puppet更强大？"></a><strong>Q9。您使用哪些开源或社区工具来使Puppet更强大？</strong></h3><p>在这里，您需要提及工具以及如何使用这些工具使Puppet更强大。以下是一个供您参考的示例：<br>更改和请求通过Jira出票，我们通过内部流程管理请求。然后，我们使用Git和Puppet的Code Manager应用程序根据最佳实践管理Puppet代码。此外，我们使用烧杯测试框架通过Jenkins中的持续集成管道运行所有Puppet更改。</p><h3 id="Q10。什么是Puppet清单？"><a href="#Q10。什么是Puppet清单？" class="headerlink" title="Q10。什么是Puppet清单？"></a><strong>Q10。什么是Puppet清单？</strong></h3><p>这是一个非常重要的问题，所以请确保您正确的流程。据我说，你应该首先定义清单。每个节点（或Puppet Agent）都在Puppet Master中获得了配置细节，用本机Puppet语言编写。这些细节用Puppet可以理解的语言编写，称为Manifest。它们由Puppet代码组成，其文件名使用.pp扩展名。<br>现在举个例子。您可以在Puppet Master中编写一个清单，用于创建文件并在连接到Puppet Master的所有Puppet Agent（Slaves）上安装apache。</p><h3 id="Q11。-什么是Puppet模块以及它与Puppet-Manifest的不同之处？"><a href="#Q11。-什么是Puppet模块以及它与Puppet-Manifest的不同之处？" class="headerlink" title="Q11。 什么是Puppet模块以及它与Puppet Manifest的不同之处？"></a><strong>Q11。</strong> <strong>什么是Puppet模块以及它与Puppet Manifest的不同之处？</strong></h3><p>对于这个答案，您可以使用下面提到的解释：<br>Puppet模块是清单和数据（例如事实，文件和模板）的集合，它们具有特定的目录结构。模块对于组织Puppet代码很有用，因为它们允许您将代码拆分为多个清单。使用模块来组织几乎所有的Puppet清单是最佳实践。<br>Puppet程序称为Manifest，它由Puppet代码组成，其文件名使用.pp扩展名。</p><h3 id="Q12。-什么是Puppet的Facter？"><a href="#Q12。-什么是Puppet的Facter？" class="headerlink" title="Q12。 什么是Puppet的Facter？"></a><strong>Q12。</strong> <strong>什么是Puppet的Facter？</strong></h3><p>你应该回答Facter在Puppet中做了什么，所以根据我的说法，你应该说，“Facter收集有关Puppet Agent的基本信息（事实），如硬件细节，网络设置，操作系统类型和版本，IP地址，MAC地址， SSH密钥等等。这些事实随后在Puppet Master的清单中作为变量提供。“</p><h3 id="Q13。什么是Chef？"><a href="#Q13。什么是Chef？" class="headerlink" title="Q13。什么是Chef？"></a><strong>Q13。什么是Chef？</strong></h3><p>通过定义Chef来开始这个答案。它是一个强大的自动化平台，可将基础架构转换为代码。Chef是一个工具，您可以编写用于自动化流程的脚本。什么过程？几乎与IT相关的任何事情。<br>现在您可以解释Chef的架构，它包括：</p><ul><li><strong>Chef Server：</strong> Chef Server是基础架构配置数据的中央存储。Chef Server存储配置节点所需的数据并提供搜索功能，这是一个功能强大的工具，允许您根据数据动态驱动节点配置。</li><li><strong>Chef Node：</strong> Node是使用Chef-client配置的任何主机。Chef-client在您的节点上运行，与Chef Server联系以获取配置节点所需的信息。由于Node是运行Chef-client软件的机器，因此节点有时被称为“客户端”。</li><li><strong>Chef Workstation：</strong> Chef Workstation是您用来修改cookbook和其他配置数据的主机。</li></ul><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/Chef-server-devops-interview-questions.png" alt="Chef建筑 -  devops面试问题"></p><h3 id="Q14。Chef的资源是什么？"><a href="#Q14。Chef的资源是什么？" class="headerlink" title="Q14。Chef的资源是什么？"></a><strong>Q14。</strong>Chef的资源是什么？</h3><p>我的建议是先定义资源。资源代表一个基础架构及其所需的状态，例如应安装的软件包，应运行的服务或应生成的文件。<br>您应该解释资源的功能，包括以下几点：</p><ul><li>描述配置项的所需状态。</li><li>声明将该项目置于所需状态所需的步骤。</li><li>指定资源类型，例如包，模板或服务。</li><li>根据需要列出其他详细信息（也称为资源属性）。</li><li>分为配方，描述工作配置。</li></ul><h3 id="Q15。Chef的食谱是什么意思？"><a href="#Q15。Chef的食谱是什么意思？" class="headerlink" title="Q15。Chef的食谱是什么意思？"></a><strong>Q15。Chef的食谱是什么意思？</strong></h3><p>对于这个答案，我建议你使用上面提到的流程：首先定义食谱。Recipe是描述特定配置或策略的资源集合。配方描述了配置系统部分所需的一切。<br>定义之后，通过包括以下几点来解释食谱的功能：</p><ul><li>安装和配置软件组件。</li><li>管理文件。</li><li>部署应用程序。</li><li>执行其他食谱。</li></ul><h3 id="Q16。-Cookbook与Chef中的食谱有何不同？"><a href="#Q16。-Cookbook与Chef中的食谱有何不同？" class="headerlink" title="Q16。 Cookbook与Chef中的食谱有何不同？"></a><strong>Q16。</strong> <strong>Cookbook与Chef中的食谱有何不同？</strong></h3><p>对此的答案非常直接。您可以简单地说，“Recipe是一组资源，主要配置软件包或某些基础架构。“食谱”将食谱和其他信息整合在一起，比单独使用“食谱”更易于管理。“</p><h3 id="Q17。-如果未在Chef中指定Resource的操作，会发生什么？"><a href="#Q17。-如果未在Chef中指定Resource的操作，会发生什么？" class="headerlink" title="Q17。 如果未在Chef中指定Resource的操作，会发生什么？"></a><strong>Q17。</strong> <strong>如果未在Chef中指定Resource的操作，会发生什么？</strong></h3><p>我的建议是首先直接回答：当您未指定资源的操作时，Chef会应用默认操作。<br>现在用一个例子解释一下，下面的资源：<br><strong>文件’C：\ Users \ Administrator \ chef-repo \ settings.ini’做</strong><br><strong>内容’greeting = hello world’</strong><br><strong>结束</strong><br>与下面的资源相同：<br><strong>文件’C：\ Users \管理\Chef回购\的Settings.ini”做的</strong><br><strong>动作：创建</strong><br><strong>内容“的问候语=你好世界</strong><br><strong>结束</strong><br>的原因是：创造是文件资源的默认操作。</p><h3 id="Q18。什么是Ansible模块？"><a href="#Q18。什么是Ansible模块？" class="headerlink" title="Q18。什么是Ansible模块？"></a><strong>Q18。什么是Ansible模块？</strong></h3><p>模块被认为是Ansible的工作单元。每个模块大多是独立的，可以用标准的脚本语言编写，如Python，Perl，Ruby，bash等。模块的一个指导属性是幂等性，这意味着即使一个操作重复多次，例如，从停电中恢复，它将始终将系统置于同一状态。</p><h3 id="Q19。什么是Ansible的剧本？"><a href="#Q19。什么是Ansible的剧本？" class="headerlink" title="Q19。什么是Ansible的剧本？"></a><strong>Q19。什么是Ansible的剧本？</strong></h3><p>Playbooks是Ansible的配置，部署和编排语言。他们可以描述您希望远程系统实施的策略，或者描述一般IT流程中的一系列步骤。Playbooks设计为人类可读的，并以基本文本语言开发。<br>在基本级别，可以使用playbooks来管理远程计算机的配置和部署。</p><h3 id="Q20。-如何查看所有ansible-变量的列表？"><a href="#Q20。-如何查看所有ansible-变量的列表？" class="headerlink" title="Q20。 如何查看所有ansible_变量的列表？"></a><strong>Q20。</strong> <strong>如何查看所有ansible_变量的列表？</strong></h3><p>Ansible默认收集有关所管理机器的“事实”，这些事实可以在Playbooks和模板中访问。要查看有关计算机的所有可用事实的列表，可以将“设置”模块作为临时操作运行：<br><strong>Ansible -m setup hostname</strong>这将打印出所有可用事实的字典对于那个特定的主人。</p><h3 id="Q21。如何设置应用程序的部署顺序？"><a href="#Q21。如何设置应用程序的部署顺序？" class="headerlink" title="Q21。如何设置应用程序的部署顺序？"></a><strong>Q21。如何设置应用程序的部署顺序？</strong></h3><p>WebLogic Server 8.1允许您选择应用程序的加载顺序。请参阅Application中的Application MBean Load Order属性。WebLogic Server在部署应用程序之前部署服务器级资源（第一个JDBC，然后是JMS）。应用程序按以下顺序部署：连接器，然后是EJB，然后是Web应用程序。如果应用程序是EAR，则按照在application.xml部署描述符中声明它们的顺序加载各个组件。</p><h3 id="Q22。我是否可以刷新已部署应用程序的静态组件而无需重新部署整个应用程序？"><a href="#Q22。我是否可以刷新已部署应用程序的静态组件而无需重新部署整个应用程序？" class="headerlink" title="Q22。我是否可以刷新已部署应用程序的静态组件而无需重新部署整个应用程序？"></a><strong>Q22。我是否可以刷新已部署应用程序的静态组件而无需重新部署整个应用程序？</strong></h3><p>是的，您可以使用weblogic.Deployer指定组件并使用以下语法定位服务器：<br>java weblogic.Deployer -adminurl http：// admin：7001 -name appname -targets server1，server2 -deploy jsps / * .jsp</p><h3 id="Q23。如何关闭自动部署功能？"><a href="#Q23。如何关闭自动部署功能？" class="headerlink" title="Q23。如何关闭自动部署功能？"></a><strong>Q23。如何关闭自动部署功能？</strong></h3><p>自动部署功能每三秒检查一次应用程序文件夹，以确定是否有任何新应用程序或对现有应用程序的任何更改，然后动态部署这些更改。</p><p>为在开发模式下运行的服务器启用了自动部署功能。要禁用自动部署功能，请使用以下方法之一将服务器置于生产模式：</p><ul><li>在管理控制台中，单击左窗格中的域名，然后在右窗格中选择“生产模式”复选框。</li><li>在命令行中，在启动域的管理服务器时包括以下参数：<br>-Dweblogic.ProductionModeEnabled = true</li><li>为给定域中的所有WebLogic Server实例设置生产模式。</li></ul><h3 id="Q24。我什么时候应该使用external-stage选项？"><a href="#Q24。我什么时候应该使用external-stage选项？" class="headerlink" title="Q24。我什么时候应该使用external_stage选项？"></a><strong>Q24。我什么时候应该使用external_stage选项？</strong></h3><p>如果您想自己暂存应用程序，请使用weblogic.Deployer设置-external_stage，并希望通过自己的方式将其复制到目标。</p><h2 id="持续监控面试问题"><a href="#持续监控面试问题" class="headerlink" title="持续监控面试问题"></a><strong>持续监控面试问题</strong></h2><p>让我们测试您对持续监控的了解。</p><h3 id="Q1。为什么需要持续监控？"><a href="#Q1。为什么需要持续监控？" class="headerlink" title="Q1。为什么需要持续监控？"></a><strong>Q1。为什么需要持续监控？</strong></h3><p>我建议您使用下面提到的流程：<br>持续监控可以及时发现问题或缺陷，并采取快速纠正措施，有助于降低组织的费用。持续监控提供解决方案，解决三个操作规程，称为：</p><ul><li>持续审计</li><li>连续控制监测</li><li>持续交易检查</li></ul><h3 id="Q2。什么是Nagios？"><a href="#Q2。什么是Nagios？" class="headerlink" title="Q2。什么是Nagios？"></a><strong>Q2。什么是Nagios？</strong></h3><p>您可以通过首先提到Nagios是监视工具之一来回答这个问题。它用于DevOps文化中的系统，应用程序，服务和业务流程等的连续监视。如果发生故障，Nagios可以向技术人员提醒问题，允许他们在中断影响业务流程，最终用户或客户之前开始修复流程。使用Nagios，您无需解释为什么不可见的基础架构中断会影响您组织的底线。<br>现在，一旦你定义了什么是Nagios，你可以提到使用Nagios可以实现的各种事情。<br>通过使用Nagios，您可以：</p><ul><li>在过时的系统导致故障之前规划基础架构升级。</li><li>在出现问题的第一个迹象时回答问题。</li><li>检测到问题时自动修复问题。</li><li>协调技术团队的回应。</li><li>确保您的组织的SLA得到满足。</li><li>确保IT基础架构中断对组织的底线影响最小。</li><li>监控整个基础架构和业务流程。</li></ul><p>这就完成了这个问题的答案。可以根据讨论的方向添加诸如优点等的进一步细节。</p><h3 id="Q3。Nagios如何运作？"><a href="#Q3。Nagios如何运作？" class="headerlink" title="Q3。Nagios如何运作？"></a><strong>Q3。Nagios如何运作？</strong></h3><p>我将建议您按照以下解释来解答：<br>Nagios在服务器上运行，通常作为守护进程或服务运行。Nagios定期运行驻留在同一服务器上的插件，它们会联系您网络或Internet上的主机或服务器。可以使用Web界面查看状态信息。如果发生某些事情，您还可以收到电子邮件或短信通知<br>Nagios守护程序的行为类似于在某些时刻运行某些脚本的调度程序。它存储这些脚本的结果，并在这些结果发生变化时运行其他脚本。</p><p>现在期待关于Nagios组件的一些问题，如插件，NRPE等。</p><h3 id="Q4。什么是Nagios的插件？"><a href="#Q4。什么是Nagios的插件？" class="headerlink" title="Q4。什么是Nagios的插件？"></a><strong>Q4。什么是Nagios的插件？</strong></h3><p>通过定义插件开始这个答案。它们是脚本（Perl脚本，Shell脚本等），可以从命令行运行以检查主机或服务的状态。Nagios使用插件的结果来确定网络上主机和服务的当前状态。<br>一旦定义了插件，解释为什么我们需要插件。只要需要检查主机或服务的状态，Nagios就会执行插件。插件将执行检查，然后只是将结果返回给Nagios。Nagios将处理从插件接收的结果并采取必要的操作。</p><h3 id="Q5。Nagios中的NRPE（Nagios-Remote-Plugin-Executor）是什么？"><a href="#Q5。Nagios中的NRPE（Nagios-Remote-Plugin-Executor）是什么？" class="headerlink" title="Q5。Nagios中的NRPE（Nagios Remote Plugin Executor）是什么？"></a><strong>Q5。Nagios中的NRPE（Nagios Remote Plugin Executor）是什么？</strong></h3><p>对于这个答案，给出插件的简要定义。NRPE插件旨在允许您在远程Linux / Unix计算机上执行Nagios插件。这样做的主要原因是允许Nagios监视远程计算机上的“本地”资源（如CPU负载，内存使用情况等）。由于这些公共资源通常不会暴露给外部计算机，因此必须在远程Linux / Unix计算机上安装NRPE之类的代理。</p><p>我将建议您根据下图所示解释NRPE架构。NRPE插件由两部分组成：</p><ul><li>check_nrpe插件，驻留在本地监视机器上。</li><li>NRPE守护程序，在远程Linux / Unix机器上运行。</li></ul><p>监视主机和远程主机之间存在SSL（安全套接字层）连接，如下图所示。</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/01/nrpe-architecture-devops-interview-questions.png" alt="nrpe架构 -  devops面试问题"></p><h3 id="Q6。你对Nagios的被动检查是什么意思？"><a href="#Q6。你对Nagios的被动检查是什么意思？" class="headerlink" title="Q6。你对Nagios的被动检查是什么意思？"></a><strong>Q6。你对Nagios的被动检查是什么意思？</strong></h3><p>据我所知，答案应该从解释被动检查开始。它们由外部应用程序/进程启动和执行，被动检查结果将提交给Nagios进行处理。<br>然后解释被动检查的必要性。它们对于监视异步的服务非常有用，并且无法通过定期轮询其状态来有效监视。它们还可用于监视位于防火墙后面的服务，并且无法从监视主机主动检查。</p><h3 id="Q7。-Nagios何时检查外部命令？"><a href="#Q7。-Nagios何时检查外部命令？" class="headerlink" title="Q7。 Nagios何时检查外部命令？"></a><strong>Q7。</strong> <strong>Nagios何时检查外部命令？</strong></h3><p>确保在解释过程中坚持这个问题，所以我建议你按照下面提到的流程。Nagios在以下条件下检查外部命令：</p><ul><li>由主配置文件中的command_check_interval选项指定的定期间隔，或</li><li>事件处理程序执行后立即执行。这是外部命令检查的常规循环的补充，并且在事件处理程序向Nagios提交命令时提供立即操作。</li></ul><h3 id="Q8。-Nagios中的主动和被动检查有什么区别？"><a href="#Q8。-Nagios中的主动和被动检查有什么区别？" class="headerlink" title="Q8。**Nagios中的主动和被动检查有什么区别？**"></a><strong>Q8。**</strong>Nagios中的主动和被动检查有什么区别？**</h3><p>对于这个答案，首先指出主动和被动检查的基本区别。主动检查和被动检查之间的主要区别在于Active检查由Nagios启动和执行，而被动检查由外部应用程序执行。<br>如果您的面试官看起来不相信上述说明，那么您还可以提及主动和被动检查的一些关键功能：<br>被动检查对于监控以下服务非常有用：</p><ul><li>本质上是异步的，无法通过定期轮询其状态来有效监控。</li><li>位于防火墙后面，无法从监控主机主动检查。</li></ul><p>Actives检查的主要功能如下：</p><ul><li>Nagios流程启动主动检查。</li><li>主动检查定期运行。</li></ul><h3 id="Q9。Nagios如何帮助分布式监控？"><a href="#Q9。Nagios如何帮助分布式监控？" class="headerlink" title="Q9。Nagios如何帮助分布式监控？"></a><strong>Q9。Nagios如何帮助分布式监控？</strong></h3><p>面试官将期待与Nagios的分布式架构相关的答案。因此，我建议您以下面提到的格式回答：<br>使用Nagios，您可以使用分布式监控方案监控整个企业，Nagios的本地从属实例执行监控任务并将结果报告给单个主站。您可以管理主服务器的所有配置，通知和报告，而从服务器可以完成所有工作。这种设计利用了Nagios利用被动检查的能力，即外部应用程序或将结果发送回Nagios的过程。在分布式配置中，这些外部应用程序是Nagios的其他实例。</p><h3 id="Q10。解释Nagios的主要配置文件及其位置？"><a href="#Q10。解释Nagios的主要配置文件及其位置？" class="headerlink" title="Q10。解释Nagios的主要配置文件及其位置？"></a><strong>Q10。解释Nagios的主要配置文件及其位置？</strong></h3><p>首先提一下这个主配置文件包含的内容及其功能。主配置文件包含许多影响Nagios守护程序运行方式的指令。Nagios守护程序和CGI都读取此配置文件（它指定主配置文件的位置）。<br>现在您可以知道它的存在位置以及创建方式。运行configure脚本时，将在Nagios分发的基本目录中创建示例主配置文件。主配置文件的默认名称是nagios.cfg。它通常放在Nagios安装的etc /子目录中（即/ usr / local / nagios / etc /）。</p><h3 id="Q11。解释Flaip-Detection在Nagios中的工作原理？"><a href="#Q11。解释Flaip-Detection在Nagios中的工作原理？" class="headerlink" title="Q11。解释Flaip Detection在Nagios中的工作原理？"></a><strong>Q11。解释Flaip Detection在Nagios中的工作原理？</strong></h3><p>我会建议你先解释Flapping。当服务或主机过于频繁地更改状态时会发生抖动，这会导致大量问题和恢复通知。<br>定义Flapping后，解释Nagios如何检测Flapping。每当Nagios检查主机或服务的状态时，它将检查它是否已经开始或停止振荡。Nagios遵循以下给定的程序来做到这一点：</p><ul><li>存储分析历史检查结果的主机或服务的最后21次检查的结果，并确定状态更改/转换发生的位置</li><li>使用状态转换来确定主机或服务的百分比状态更改值（更改度量）</li><li>比较百分比状态变化值与低和高拍打阈值</li></ul><p>当主机或服务的百分比状态变化首先超过高振荡阈值时，确定主机或服务已开始振荡。当主机或服务的百分比状态低于低抖动阈值时，确定主机或服务已停止振荡。</p><h3 id="Q12。在Nagios中影响递归和继承的三个主要变量是什么？"><a href="#Q12。在Nagios中影响递归和继承的三个主要变量是什么？" class="headerlink" title="Q12。在Nagios中影响递归和继承的三个主要变量是什么？"></a><strong>Q12。在Nagios中影响递归和继承的三个主要变量是什么？</strong></h3><p>根据我的说法，这个答案的正确格式应该是：<br>首先命名变量，然后对每个变量做一个小解释：</p><ul><li>名称</li><li>使用</li><li>寄存器</li></ul><p>然后给出每个变量的简要说明。Name是其他对象使用的占位符。使用定义应使用其属性的“父”对象。寄存器的值可以为0（表示只有模板）和1（实际对象）。寄存器值永远不会被继承。</p><h3 id="Q13。Nagios的意思是面向对象？"><a href="#Q13。Nagios的意思是面向对象？" class="headerlink" title="Q13。Nagios的意思是面向对象？"></a><strong>Q13。Nagios的意思是面向对象？</strong></h3><p>回答这个问题非常直接。我将回答这个问题，“Nagios的一个特性是对象配置格式，因为您可以创建从其他对象定义继承属性的对象定义，从而创建名称。这简化并阐明了各个组件之间的关系。“</p><h3 id="Q14。什么是Nagios的州跟踪？"><a href="#Q14。什么是Nagios的州跟踪？" class="headerlink" title="Q14。什么是Nagios的州跟踪？"></a><strong>Q14。什么是Nagios的州跟踪？</strong></h3><p>我会建议你先介绍一下State Salking。它用于记录目的。当为特定主机或服务启用Stalking时，Nagios将非常仔细地监视该主机或服务，并记录它在检查结果输出中看到的任何更改。<br>根据您和访调员之间的讨论，您还可以添加“在以后分析日志文件时非常有用。在正常情况下，只有在主机或服务自上次检查后状态发生变化时，才会记录主机或服务检查的结果。“</p><p>想要接受像Nagios这样的监控工具的培训吗？想获得DevOps工程师认证吗？请务必<a href="https://www.edureka.co/masters-program/devops-engineer-training" target="_blank" rel="noopener">查看我们的DevOps硕士课程</a>。</p><h2 id="容器化和虚拟化面试问题"><a href="#容器化和虚拟化面试问题" class="headerlink" title="容器化和虚拟化面试问题"></a><strong>容器化和虚拟化面试问题</strong></h2><p>让我们看看您对容器和虚拟机的了解程度。</p><h3 id="Q1。什么是容器？"><a href="#Q1。什么是容器？" class="headerlink" title="Q1。什么是容器？"></a><strong>Q1。什么是容器？</strong></h3><p>我的建议是首先解释容器化的必要性，容器用于提供从开发人员的笔记本电脑到测试环境，从临时环境到生产的一致计算环境。<br>现在给出一个容器的定义，一个容器由一个完整的运行时环境组成：一个应用程序，以及它所有的依赖项，库和其他二进制文件，以及运行它所需的配置文件，捆绑到一个包中。容纳应用程序平台及其依赖项消除了操作系统分发和底层基础架构的差异。</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/containers-devops-interview-questions.png" alt="容器 -  devops面试问题"></p><h3 id="Q2。容器化相比虚拟化有哪些优势？"><a href="#Q2。容器化相比虚拟化有哪些优势？" class="headerlink" title="Q2。容器化相比虚拟化有哪些优势？"></a><strong>Q2。容器化相比虚拟化有哪些优势？</strong></h3><p>以下是容器化优于虚拟化的优势：</p><ul><li>容器提供实时配置和可伸缩性，但VM提供缓慢的配置</li><li>与VM相比，容器是轻量级的</li><li>与容器相比，VM的性能有限</li><li>与VM相比，容器具有更好的资源利用率</li></ul><h3 id="Q3。容器（在我们的例子中是Docker）与虚拟机管理程序虚拟化（vSphere）有何不同？有什么好处？"><a href="#Q3。容器（在我们的例子中是Docker）与虚拟机管理程序虚拟化（vSphere）有何不同？有什么好处？" class="headerlink" title="Q3。容器（在我们的例子中是Docker）与虚拟机管理程序虚拟化（vSphere）有何不同？有什么好处？"></a><strong>Q3。容器（在我们的例子中是Docker）与虚拟机管理程序虚拟化（vSphere）有何不同？有什么好处？</strong></h3><p>以下是一些差异。确保在答案中包含这些差异：</p><p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/Docker-vsphere-devops-interview-questions-507x300.png" alt="docker vsphere  -  devops面试问题"></p><h3 id="Q4。什么是Docker图像？"><a href="#Q4。什么是Docker图像？" class="headerlink" title="Q4。什么是Docker图像？"></a><strong>Q4。什么是Docker图像？</strong></h3><p>我建议你使用下面提到的流程：<br>Docker镜像是Docker容器的来源。换句话说，Docker镜像用于创建容器。使用build命令创建映像，并且在使用run启动时它们将生成容器。图像存储在Docker注册表中，例如registry.hub.docker.com，因为它们可能变得非常大，图像被设计为由其他图像层组成，允许在通过网络传输图像时发送最少量的数据。<br><strong>提示：请注意Dockerhub，以便回答有关预先可用图像的问题。</strong></p><h3 id="Q5。什么是Docker容器？"><a href="#Q5。什么是Docker容器？" class="headerlink" title="Q5。什么是Docker容器？"></a><strong>Q5。什么是Docker容器？</strong></h3><p>这是一个非常重要的问题，所以请确保您不偏离主题。我建议您遵循下面提到的格式：<br>Docker容器包括应用程序及其所有依赖项，但与其他容器共享内核，在主机操作系统的用户空间中作为独立进程运行。Docker容器不依赖于任何特定的基础架构：它们可以在任何计算机，任何基础架构和任何云中运行。<br>现在解释如何创建Docker容器，可以通过创建Docker镜像然后运行它来创建Docker容器，也可以使用Dockerhub上存在的Docker镜像。<br>Docker容器基本上是Docker镜像的运行时实例。</p><h3 id="Q6。-什么是Docker中心？"><a href="#Q6。-什么是Docker中心？" class="headerlink" title="Q6。**什么是Docker中心？**"></a><strong>Q6。**</strong>什么是Docker中心？**</h3><p>回答这个问题非常直接。Docker hub是一个基于云的注册表服务，允许您链接到代码存储库，构建映像并测试它们，存储手动推送的映像以及指向Docker云的链接，以便您可以将映像部署到主机。它为整个开发流程中的容器映像发现，分发和变更管理，用户和团队协作以及工作流自动化提供了集中资源。</p><h3 id="Q7。-Docker与其他容器技术有何不同？"><a href="#Q7。-Docker与其他容器技术有何不同？" class="headerlink" title="Q7。 Docker与其他容器技术有何不同？"></a><strong>Q7。</strong> <strong>Docker与其他容器技术有何不同？</strong></h3><p>据我<br>所知，您的答案应该在以下几点：Docker容器易于在云中部署。与其他技术相比，它可以在相同的硬件上运行更多的应用程序，使开发人员可以轻松快速创建，可立即运行的容器化应用程序，并使管理和部署应用程序变得更加容易。您甚至可以与您的应用程序共享容器。<br>如果你还有一些要点可以添加，你可以这样做，但要确保上面的解释在你的答案中。</p><h3 id="Q8。-什么是Docker-Swarm？"><a href="#Q8。-什么是Docker-Swarm？" class="headerlink" title="Q8。 什么是Docker Swarm？"></a><strong>Q8。</strong> <strong>什么是Docker Swarm？</strong></h3><p>你应该通过解释Docker Swarn来开始这个答案。它是Docker的本机群集，它将Docker主机池转变为单个虚拟Docker主机。Docker Swarm提供标准的Docker API，任何已经与Docker守护进程通信的工具都可以使用Swarm透明地扩展到多个主机。<br>我还建议您添加一些支持的工具：</p><ul><li>Dokku</li><li>Docker撰写</li><li>Docker Machine</li><li>Jenkins</li></ul><h3 id="Q9。Dockerfile用于什么？"><a href="#Q9。Dockerfile用于什么？" class="headerlink" title="Q9。Dockerfile用于什么？"></a><strong>Q9。Dockerfile用于什么？</strong></h3><p>根据我的回答应该从解释Dockerfile的使用开始。Docker可以通过读取Dockerfile中的指令自动构建图像。<br>现在我建议你给出一个Dockerfle的小定义。Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以组合图像的所有命令。使用docker构建用户可以创建一个连续执行多个命令行指令的自动构建。</p><p>现在期待一些问题来测试您使用Docker的体验。</p><h3 id="Q10。-我可以在Docker中使用json而不是yaml作为我的compose文件吗？"><a href="#Q10。-我可以在Docker中使用json而不是yaml作为我的compose文件吗？" class="headerlink" title="Q10。 我可以在Docker中使用json而不是yaml作为我的compose文件吗？"></a><strong>Q10。</strong> <strong>我可以在Docker中使用json而不是yaml作为我的compose文件吗？</strong></h3><p>你可以使用json而不是yaml作为你的compose文件，使用带有compose的json文件，指定用于例如的文件名：<br><strong>docker-compose -f docker-compose.json up</strong></p><h3 id="Q11。-告诉我们你在过去的职位中如何使用Docker？"><a href="#Q11。-告诉我们你在过去的职位中如何使用Docker？" class="headerlink" title="Q11。 告诉我们你在过去的职位中如何使用Docker？"></a><strong>Q11。</strong> <strong>告诉我们你在过去的职位中如何使用Docker？</strong></h3><p>解释您如何使用Docker来帮助快速部署。解释你如何使用脚本化Docker并将Docker与Puppet，Chef或Jenkins等其他工具一起使用。如果您在Docker中没有过去的实践经验，并且在类似的空间中有过其他工具的经验，请诚实并解释相同的内容。在这种情况下，如果您可以在功能方面与Docker比较其他工具，这是有意义的。</p><h3 id="Q12。如何创建Docker容器？"><a href="#Q12。如何创建Docker容器？" class="headerlink" title="Q12。如何创建Docker容器？"></a><strong>Q12。如何创建Docker容器？</strong></h3><p>我建议你直接回答这个问题。我们可以使用以下命令使用Docker镜像创建Docker容器：<br><strong>docker run -t -i <image name=""> <command name=""></image></strong>此命令将创建并启动容器。<br>您还应该添加，如果要检查主机上具有状态的所有正在运行的容器的列表，请使用以下命令：<br><strong>docker ps -a</strong></p><h3 id="Q13。如何停止并重新启动Docker容器？"><a href="#Q13。如何停止并重新启动Docker容器？" class="headerlink" title="Q13。如何停止并重新启动Docker容器？"></a><strong>Q13。如何停止并重新启动Docker容器？</strong></h3><p>为了停止Docker容器，您可以使用以下命令：<br><strong>docker stop &lt;容器ID&gt;</strong><br>现在重新启动Docker容器，您可以使用：<br><strong>docker restart &lt;容器ID&gt;</strong></p><h3 id="Q14。Docker容器可以扩展多远？"><a href="#Q14。Docker容器可以扩展多远？" class="headerlink" title="Q14。Docker容器可以扩展多远？"></a>Q14。Docker容器可以扩展多远？</h3><p>像谷歌和Twitter这样的大型网络部署，以及像Heroku和dotCloud这样的平台提供商都运行在容器技术上，并行运行数十万甚至数百万个容器。</p><h3 id="Q15。Docker运行的平台是什么？"><a href="#Q15。Docker运行的平台是什么？" class="headerlink" title="Q15。Docker运行的平台是什么？"></a>Q15。Docker运行的平台是什么？</h3><p>我将通过说Docker仅在Linux和云平台上运行来开始这个答案，然后我将提到以下Linux供应商：</p><ul><li>Ubuntu 12.04,13.04等</li><li>Fedora 19/20 +</li><li>RHEL 6.5+</li><li>CentOS 6+</li><li>Gentoo的</li><li>ArchLinux的</li><li>openSUSE 12.3+</li><li>CRUX 3.0+</li></ul><p>云：</p><ul><li>亚马逊EC2</li><li>Google Compute Engine</li><li>Microsoft Azure</li><li>Rackspace公司</li></ul><p><strong>请注意，Docker无法在Windows或Mac上运行。</strong></p><h3 id="Q16。当Docker容器退出时，我会丢失数据吗？"><a href="#Q16。当Docker容器退出时，我会丢失数据吗？" class="headerlink" title="Q16。当Docker容器退出时，我会丢失数据吗？"></a><strong>Q16。当Docker容器退出时，我会丢失数据吗？</strong></h3><p>你可以回答这个问题，当Dcoker容器退出时，我不会丢失我的数据。在您明确删除容器之前，应用程序写入磁盘的任何数据都会保留在其容器中。即使在容器停止之后，容器的文件系统仍然存在。</p><p>而且，就是这样！</p><p>我希望这些问题可以帮助您破解DevOps面试。如果您对我们有任何疑问，请在评论部分提及，我们会尽快回复您。</p><p>如果您希望为DevOps角色构建强大的简历，<a href="https://www.edureka.co/blog/devops-resume" target="_blank" rel="noopener">请查看我们为您编写的博客</a>。</p><p>您还可以通过<a href="https://www.facebook.com/edurekaIN/" target="_blank" rel="noopener">Facebook</a>，<a href="https://twitter.com/edurekaIN" target="_blank" rel="noopener">Twitter</a>，<a href="https://www.instagram.com/edureka_learning/" target="_blank" rel="noopener">Instagram</a>，<a href="https://www.youtube.com/user/edurekaIN?sub_confirmation=1" target="_blank" rel="noopener">YouTube</a>，<a href="https://www.linkedin.com/company/edureka/" target="_blank" rel="noopener">LinkedIn</a>甚至<a href="https://in.pinterest.com/edurekaco/" target="_blank" rel="noopener">Pinterest与我们联系</a>！</p><p>想要开始您的DevOps学习之旅吗？<a href="https://www.edureka.co/blog/edureka-online-courses/" target="_blank" rel="noopener">没有比Edureka更好的地方了</a>。我们的荒谬承诺保证了它！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;您是DevOps工程师还是想进入DevOps？那么，未来就是你的。顶级研究公司Forrester宣布2018年为“ &lt;a href=&quot;https://go.forrester.com/blogs/2018-the-year-of-enterprise-devops/&quot; ta
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="http://blog.ozairs.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>利用 Puppet 实现自动化管理配置 Linux 计算机集群</title>
    <link href="http://blog.ozairs.com/DevOps/Puppet/%E5%88%A9%E7%94%A8-Puppet-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE-Linux-%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9B%86%E7%BE%A4/"/>
    <id>http://blog.ozairs.com/DevOps/Puppet/利用-Puppet-实现自动化管理配置-Linux-计算机集群/</id>
    <published>2019-03-14T01:18:33.000Z</published>
    <updated>2019-03-14T03:39:22.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Puppet：开源系统配置和管理工具"><a href="#Puppet：开源系统配置和管理工具" class="headerlink" title="Puppet：开源系统配置和管理工具"></a>Puppet：开源系统配置和管理工具</h2><p>随着虚拟化和云计算技术的兴起，计算机集群的自动化管理和配置成为了数据中心运维管理的热点。对于 IaaS、Paas、Saas 来说，随着业务需求的提升，后台计算机集群的数量也会线性增加。对于数据中心的运维人员来说，如何自动化管理、配置这些大规模的计算机集群节点，对于数据中心的稳定运行以及运维成本控制都显得至关重要。</p><p>Puppet 是一个开源系统配置管理工具，它有着简明的架构以及良好的扩展性；同时，Puppet 还提供了自有的系统配置描述语言以及完善的公用库，非常适合用于管理和部署大规模集群系统。</p><h2 id="Puppet-的系统架构"><a href="#Puppet-的系统架构" class="headerlink" title="Puppet 的系统架构"></a>Puppet 的系统架构</h2><p>Puppet 使用简明的 C/S 架构，分为 Puppet Server 和 Puppet Node。</p><h5 id="图-1-Puppet-的架构"><a href="#图-1-Puppet-的架构" class="headerlink" title="图 1. Puppet 的架构"></a>图 1. Puppet 的架构</h5><p><img src="/DevOps/Puppet/利用-Puppet-实现自动化管理配置-Linux-计算机集群/1.png" alt=""></p><p><strong>Puppet Server</strong></p><p>Puppet Server 是配置和管理整个集群的大脑，管理着所有节点。系统管理员在 Puppet Server 上用 Puppet 特有的配置描述语言为各个节点编写配置文件 (manifest)，配置文件描述了节点的目标状态——资源的集合。这些资源可以是文件、服务、软件包等等。各个节点会周期性的查询 Puppet Server，获得自己的最新配置文件，并且在本地应用这些配置文件，使得自身的资源和状态达到配置文件要求。</p><p><strong>Puppet Node(Agent)</strong></p><p>被 Puppet Master 管理着的计算机节点称为 Puppet node。Puppet node 会周期性的查询 Puppet Master，来获取自己的配置文件，并且在本地应用。在每次应用配置文件之后，Puppet node 会提供上传一份报告给 Puppet Master，以便以后的统计和分析。系统管理员也可以手动地在 Puppet Node 上执行命令，让 Puppet Node 立即查询 Puppet Server 获取自身最新的配置文件，并且在本地应用。</p><h2 id="Puppet-的工作流程"><a href="#Puppet-的工作流程" class="headerlink" title="Puppet 的工作流程"></a>Puppet 的工作流程</h2><p>Puppet 的工作流程可以概括成这几步：定义、模拟、应用、报告。</p><h5 id="图-2-Puppet-的工作流程"><a href="#图-2-Puppet-的工作流程" class="headerlink" title="图 2. Puppet 的工作流程"></a>图 2. Puppet 的工作流程</h5><p><img src="/DevOps/Puppet/利用-Puppet-实现自动化管理配置-Linux-计算机集群/2.png" alt=""></p><h3 id="定义-Define"><a href="#定义-Define" class="headerlink" title="定义 (Define)"></a>定义 (Define)</h3><p>管理员为各个节点编写配置文件，配置文件中定义了该节点所需要的资源的集合以及资源之间的关系。这些资源可以是文件、服务、软件包、可执行的命令等等。Puppet 内置的配置管理语言对这些资源提供了较为完整的底层抽象，减轻了编写配置文件的复杂度。</p><h3 id="模拟-Simulate"><a href="#模拟-Simulate" class="headerlink" title="模拟 (Simulate)"></a>模拟 (Simulate)</h3><p>根据节点的配置文件，我们可以了解到该节点需要什么样的资源并且处于什么样的状态。配置文件描述了节点的状态，而不是具体的配置步骤。Puppet 会将配置文件 Manifest 编译成更为详细的一种配置文件 Catalog。通过 Catalog，Puppet 会根据节点的当前状态，模拟出节点达到该目标状态所需要的步骤。</p><h3 id="应用-Enforce"><a href="#应用-Enforce" class="headerlink" title="应用 (Enforce)"></a>应用 (Enforce)</h3><p>节点周期性地向 Puppet Server 来请求自己最新的配置文件。Puppet 会将节点的实际状态与节点配置文件中所表述的目标状态做比较，并根据得到的所需要的步骤，对节点执行操作，使其达到配置文件所表述的状态。</p><h3 id="报告-Report"><a href="#报告-Report" class="headerlink" title="报告 (Report)"></a>报告 (Report)</h3><p>当每次应用执行过后，节点都会给 Puppet Server 发送一份运行报告，报告该节点的状态，以便以后的分析和统计。</p><h2 id="Puppet-配置语言介绍"><a href="#Puppet-配置语言介绍" class="headerlink" title="Puppet 配置语言介绍"></a>Puppet 配置语言介绍</h2><p>Puppet 配置管理语言中的核心概念是资源，资源可以是一个软件包，一个文件，一种服务等等。一个节点的状态可以用资源的集合以及他们之间的关系来表示。管理员不需要详细地描述配置和部署系统的具体步骤，Puppet 只需要管理员来描述系统的目标状态，即资源的集合以及它们之间的关系。Puppet 内置的执行引擎会根据节点的现有状态将配置文件转化为具体的执行步骤并且执行。</p><p>在 Puppet 中，类是一系列相关资源的集合；模块是一系列类的集合。Puppet 内置提供了一些常用的类和模块，同时用户可以定义自己的类和模块。通过类和模块使用，配置模块重用和共享变的非常容易。</p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>由于 Puppet Server 和节点之间通过主机名来通信，所以需要双方可以通过彼此的主机名来找到对应的 IP 地址。可以通过配置 DNS 或者配置/ets/hosts 文件来实现。</p><h3 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h3><p>在安装官方提供的开源版本的 Puppet 软件之前，Puppet Server 和 agent 首先需要都安装官方的软件源 (Puppet 对各种 Linux 发行版都有提供支持，本文以 Ubuntu 14.04 系统为例)：</p><p>下载官方软件源的安装包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`wget https://apt.puppetlabs.com/puppetlabs-release-pc1-trusty.deb`</span><br></pre></td></tr></table></figure><p>更新软件源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo dpkg -i puppetlabs-release-pc1-trusty.deb``sudo apt-get update`</span><br></pre></td></tr></table></figure><p><strong>安装 Puppet Server</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo apt-get install puppetserver`</span><br></pre></td></tr></table></figure><p><strong>启动 PuppetServer</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo service puppetservice start`</span><br></pre></td></tr></table></figure><p><strong>安装 PuppetAgent</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo apt-get install puppet-agent`</span><br></pre></td></tr></table></figure><p>编辑/etc/puppetlabs/puppet/puppet.conf 文件，设置该 agent 的 puppet server 的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[main]``server = puppetmaster`</span><br></pre></td></tr></table></figure><p>注：puppetmaster 是 puppetserver 的主机名。</p><p><strong>启动 puppet service</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo /opt/puppetlabs/bin/puppet resource service puppet ensure=running enable=true`</span><br></pre></td></tr></table></figure><h2 id="编写第一个配置文件"><a href="#编写第一个配置文件" class="headerlink" title="编写第一个配置文件"></a>编写第一个配置文件</h2><h3 id="第一个-Hello-World-配置文件"><a href="#第一个-Hello-World-配置文件" class="headerlink" title="第一个 Hello World 配置文件"></a>第一个 Hello World 配置文件</h3><p>作为第一个实例配置文件，我们想让节点做一件最简单的事情：在/etc/文件夹下面创建一个文件 helloworld.txt，文件的内容是”hello world from puppet!\n”。</p><p>首先我们在 puppetserver 上进入/etc/puppetlabs/code/environments/production/manifests 文件夹，创建 site.pp 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`node puppetagent &#123;` `file &#123; &apos;helloworld&apos;:` `    ``path =&gt; &apos;/etc/helloworld.txt&apos;,``    ``owner  =&gt; &apos;root&apos;,``    ``group  =&gt; &apos;root&apos;,``    ``mode   =&gt; &apos;655&apos;,``    ``content =&gt; &quot;hello world from puppet!\n&quot;,``    ``&#125;` `&#125;`</span><br></pre></td></tr></table></figure><p>site.pp 就是节点的配置文件，里面可以包含对各个节点的配置描述。在实例配置文件中，”puppetagent”就是节点的主机名。包含在 puppetagent 中的配置描述就是该节点的资源集合的描述。</p><p>配置文件创建好后，节点会周期性地查询 PuppetServer 来获取自己的配置文件并在本地应用。当然 Puppet 也支持手动获取自己的配置。在本例中，我们通过手动的方式来进行配置更新。我们在 PuppetAgent 上手动执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`root@puppetAgent:/opt/puppetlabs/bin# ./puppet agent --test``2016-05-21 14:24:14.858673 WARN  puppetlabs.facter - locale environment variables were bad; ``                         ``continuing with LANG=C LC_ALL=C``Info: Using configured environment &apos;production&apos;``Info: Retrieving pluginfacts``Info: Retrieving plugin``Info: Caching catalog for puppetagent``Info: Applying configuration version &apos;1463811856&apos;``Notice: /Stage[main]/Main/Node[puppetagent]/File[helloworld]/ensure: ``                        ``defined content as &apos;&#123;md5&#125;c3aa68786c58c94ef6f3e2399920f268&apos;``Notice: Applied catalog in 0.02 seconds``root@puppetAgent:/opt/puppetlabs/bin# cat /etc/helloworld.txt ``hello world from puppet!`</span><br></pre></td></tr></table></figure><p>我们看到节点成功从 Puppet Server 获取配置文件，并且在本地应用，对应的文件成功创建。</p><h3 id="进阶：执行脚本任务"><a href="#进阶：执行脚本任务" class="headerlink" title="进阶：执行脚本任务"></a>进阶：执行脚本任务</h3><p>作为进阶的任务，我们希望节点可以执行一些更加复杂一点的任务。我们希望节点可以从 PuppetServer 获取一个命令脚本，并且执行该脚本。</p><p>我们首先在/etc/puppetlabs/code/environments/production/modules 中创建一个名叫”test”的模块，在 test 模块下面创建一个”files”文件夹。在这个文件夹里的文件是可以被节点获取的。然后我们在这个”files”文件夹里创建一个 shell 脚本 test.sh，路径如下：</p><p>/etc/puppetlabs/code/environments/production/modules/test/files/test.sh</p><p>test.sh 文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`touch /etc/helloworld.log``echo &quot;helloworld&quot; &gt;&gt; /etc/helloworld.log`</span><br></pre></td></tr></table></figure><p>该脚本会在/etc/目录下创建 helloworld.log 文件，然后在文件里添加”hello world”内容。</p><p>进入目录/etc/puppetlabs/code/environments/production/manifests，然后我们再来编辑 site.pp 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`node puppetagent &#123;``file &#123; &apos;test.sh&apos;:`` ``path =&gt; &apos;/etc/test.sh&apos;,`` ``owner  =&gt; &apos;root&apos;,`` ``group  =&gt; &apos;root&apos;,`` ``mode   =&gt; &apos;655&apos;,`` ``source =&gt; &apos;puppet:///modules/test/test.sh&apos;,`` ``&#125;``exec &#123; &apos;execute &apos;:`` ``command =&gt; &apos;bash /etc/test.sh&apos;,`` ``require =&gt; File[&apos;test.sh&apos;],`` ``path =&gt; [&quot;/bin/&quot;],``&#125;``&#125;`</span><br></pre></td></tr></table></figure><p>其中，我们定义了两个资源：一个文件资源和一个执行命令资源。同时这两个资源有依赖关系，命令执行资源依赖于文件资源，所以 Puppet 会优先处理文件资源。执行命令资源会在文件资源存在后再执行。</p><p>我们看下客户端的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`root@puppetAgent:/opt/puppetlabs/bin# ./puppet agent --test``2016-05-21 15:39:39.817370 WARN  puppetlabs.facter - locale environment variables were bad; ``                                ``continuing with LANG=C LC_ALL=C``Info: Using configured environment &apos;production&apos;``Info: Retrieving pluginfacts``Info: Retrieving plugin``Info: Caching catalog for puppetagent``Info: Applying configuration version &apos;1463816381&apos;``Notice: /Stage[main]/Main/Node[puppetagent]/File[test.sh]/ensure: ``                                ``defined content as &apos;&#123;md5&#125;2ce060ad2ddab2fe416ca8fb6f8da32a&apos;``Notice: /Stage[main]/Main/Node[puppetagent]/Exec[execute ]/returns: executed successfully``Notice: Applied catalog in 0.05 seconds``root@puppetAgent:/opt/puppetlabs/bin# cat /etc/helloworld.log ``helloworld`</span><br></pre></td></tr></table></figure><p>我们可以看到，helloworld.log 文件被正确的创建，说明脚本文件被正确地执行。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Puppet 是基于 Ruby 的开源系统配置和管理工具，它提供的独特的系统配置语言极大程度地简化了系统管理员管理和配置系统的过程。本文首先介绍了 Puppet 的系统架构和工作流程，并且介绍了 Puppet 独特的系统配置语言，之后我们简单介绍了安装和配置 Puppet 的具体步骤。最后，本文以两个实例介绍了如何在 Puppet 中为节点编写配置文件，来达到创建文件和执行命令的效果。希望本文能对系统管理员，Puppet 初学者有所帮助。</p><h2 id="问题集"><a href="#问题集" class="headerlink" title="问题集"></a>问题集</h2><p>问题1: Exiting; no certificate found and waitforcert is disabled </p><p>解决方案： <a href="https://fvtool.wordpress.com/2013/04/15/exiting-no-certificate-found-and-waitforcert-is-disabled-installing-puppet/" target="_blank" rel="noopener">https://fvtool.wordpress.com/2013/04/15/exiting-no-certificate-found-and-waitforcert-is-disabled-installing-puppet/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Puppet：开源系统配置和管理工具&quot;&gt;&lt;a href=&quot;#Puppet：开源系统配置和管理工具&quot; class=&quot;headerlink&quot; title=&quot;Puppet：开源系统配置和管理工具&quot;&gt;&lt;/a&gt;Puppet：开源系统配置和管理工具&lt;/h2&gt;&lt;p&gt;随着虚拟化和
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
      <category term="Puppet" scheme="http://blog.ozairs.com/categories/DevOps/Puppet/"/>
    
    
      <category term="Puppet" scheme="http://blog.ozairs.com/tags/Puppet/"/>
    
  </entry>
  
  <entry>
    <title>Puppet实用命令指南</title>
    <link href="http://blog.ozairs.com/DevOps/Puppet/Puppet_command/"/>
    <id>http://blog.ozairs.com/DevOps/Puppet/Puppet_command/</id>
    <published>2019-03-14T00:45:41.000Z</published>
    <updated>2019-03-14T03:36:15.747Z</updated>
    
    <content type="html"><![CDATA[<p>1、下载安装r10k Module<br>puppet module install puppet/r10k –modulepath=/etc/puppetlabs/code/modules</p><p>2、puppet code与github repo同步<br>r10k deploy environment -p</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、下载安装r10k Module&lt;br&gt;puppet module install puppet/r10k –modulepath=/etc/puppetlabs/code/modules&lt;/p&gt;
&lt;p&gt;2、puppet code与github repo同步&lt;br&gt;r10
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
      <category term="Puppet" scheme="http://blog.ozairs.com/categories/DevOps/Puppet/"/>
    
    
      <category term="Puppet" scheme="http://blog.ozairs.com/tags/Puppet/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.ozairs.com/uncategorized/Git%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.ozairs.com/uncategorized/Git实用教程/</id>
    <published>2019-03-13T11:16:43.451Z</published>
    <updated>2019-03-16T11:49:47.469Z</updated>
    
    <content type="html"><![CDATA[<p>&lt;Git实用教程&gt;</p><p>1、Git创建和切换Branch</p><p>git brach example</p><p>git checkout ‘example’</p><p>2、查看Branch，Branch改名和删除Branch</p><p>git branch</p><p>git branch -m originname newname</p><p>git branch -D branchname</p><p>3、提交代码到Staging Enviroment</p><p>git add example （git add . ）</p><p>4、提交代码到正式环境</p><p>git commit -m “comment”</p><p>5、合并不同 branch的代码</p><p>git merge branchname</p><p>6、查看代码日志</p><p>git log</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;lt;Git实用教程&amp;gt;&lt;/p&gt;
&lt;p&gt;1、Git创建和切换Branch&lt;/p&gt;
&lt;p&gt;git brach example&lt;/p&gt;
&lt;p&gt;git checkout ‘example’&lt;/p&gt;
&lt;p&gt;2、查看Branch，Branch改名和删除Branch&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 和 GitHub 基础配置</title>
    <link href="http://blog.ozairs.com/DevOps/Git-%E5%92%8C-GitHub-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.ozairs.com/DevOps/Git-和-GitHub-基础配置/</id>
    <published>2019-03-13T10:43:27.000Z</published>
    <updated>2019-03-13T10:52:52.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本系列的<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-git-and-github-1/index.html" target="_blank" rel="noopener">第一篇</a>文章中着重介绍了 Git 的基础特性。本文作为本系列的第二篇文章将介绍 Git 和 GitHub 的基础配置，包括 Git 安装、使用 Git 克隆 GitHub 上的代码库、使用 Git 克隆远端代码仓库、Git 的基本配置和设置忽略提交规则。您在阅读完本文将有能力完成本地 Git 环境的基础配置，为接下来的 Git 日常使用做基础。</p><p>GitHub 是一个代码托管平台，如果开发者想要在本地进行开发工作，那么就需要使用到 Git 的客户端工具来连接到 GitHub，再克隆代码到本地。如果您是重度的 GUI 使用者，那么有很多 GUI 客户端可以选择，在 Git 的官网就专门有个页面列出了业内的<a href="https://git-scm.com/downloads/guis/" target="_blank" rel="noopener"> GUI 客户端</a>。</p><p>但遗憾的是往往 GUI 客户端只能提供 Git 部分的功能，如果想要享受到 Git 自底向上强大的功能，使用命令行的方式来操作 Git 是不二之选。建议无论您是否擅长使用命令行工作，都可以尝试使用命令行方式来操作 Git。本文将只介绍如何从命令行来连接到 GitHub。</p><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>使用命令行方式操作 Git 工具，需要本地安装 Git。注意，这里没有使用 “Git 客户端” 一词，因为 Git 作为一个开源版本控制系统，本身既可以作为客户端工具，也可以用于建立服务器端代码库，所以本质上 Git 作为工具来讲没有客户端和服务器端之分。</p><p>本地安装 Git 十分简单。</p><p>对于 Windows 用户，可以下载 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">Git For Windows</a> 工具。下载安装成功之后，我们可以得到一个 Git Bash 工具，它是一个类 Linux Bash 工具。在该工具中我们可以直接执行 Git 相关命令。</p><p>对于 Mac 和 Linux 用户，只需通过对应的包管理工具安装即可，如清单 1 所示：</p><h5 id="清单-1-Mac-和-Linux-下安装-Git"><a href="#清单-1-Mac-和-Linux-下安装-Git" class="headerlink" title="清单 1. Mac 和 Linux 下安装 Git"></a>清单 1. Mac 和 Linux 下安装 Git</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`$ brew install git         # For Mac``$ apt-get install git      # For Ubuntu``# yum install git          # For RedHat EL, CentOS`</span><br></pre></td></tr></table></figure><h2 id="使用-Git-克隆-GitHub-代码库"><a href="#使用-Git-克隆-GitHub-代码库" class="headerlink" title="使用 Git 克隆 GitHub 代码库"></a>使用 Git 克隆 GitHub 代码库</h2><p>安装 Git 成功之后，我们就可以使用 Git 克隆 GitHub 上的代码库，本节仍然以我的代码库<a href="https://github.com/caozhi/repo-for-developerworks" target="_blank" rel="noopener"> repo-for-developerworks </a>为例。</p><p>GitHub 提供了两种克隆方式：HTTPS 和 SSH。我们可以点击仓库页面上的 <strong>Clone or download</strong> 按钮来查看用于克隆的链接，同时可以点击浮动框右上角的 <strong>Use SSH/Use HTTPS</strong> 换我们想要克隆的 link，如图 2 和 图 3 所示。注意，这里只是切换查看不同的链接，而不是设置代码库不同的链接方式。</p><p>由此我们可以获得两个 URL：</p><ul><li>HTTPS 链接：<code>https://github.com/caozhi/repo-for-developerworks.git</code></li><li>SSH 链接：<a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:caozhi/repo-for-developerworks.git`</li></ul><h3 id="使用-HTTPS-进行克隆"><a href="#使用-HTTPS-进行克隆" class="headerlink" title="使用 HTTPS 进行克隆"></a>使用 HTTPS 进行克隆</h3><p>由于代码库是开放的，因此使用 HTTPS 方式克隆时，无需 GitHub 用户名密码，如清单 2 所示：</p><h5 id="清单-2-使用-HTTPS-进行克隆"><a href="#清单-2-使用-HTTPS-进行克隆" class="headerlink" title="清单 2. 使用 HTTPS 进行克隆"></a>清单 2. 使用 HTTPS 进行克隆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`caozhi@ clone$ git clone https://github.com/caozhi/repo-for-developerworks.git``Cloning into &apos;repo-for-developerworks&apos;...``remote: Counting objects: 14, done.``remote: Compressing objects: 100% (9/9), done.``remote: Total 14 (delta 3), reused 5 (delta 1), pack-reused 0``Unpacking objects: 100% (14/14), done.`</span><br></pre></td></tr></table></figure><p>顺便提一下，进行 pull 和 fetch 操作时也无需用户名密码认证。因为 GitHub 的机制允许随意免费下载任何公开的代码库，如若要 push 代码需经过认证或者经过作者同意才可。当要进行 push 时，会出现提示要求输入用户名密码，如清单 3 所示：</p><h5 id="清单-3-HTTPS-方式下-push-代码"><a href="#清单-3-HTTPS-方式下-push-代码" class="headerlink" title="清单 3. HTTPS 方式下 push 代码"></a>清单 3. HTTPS 方式下 push 代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`caozhi@ repo-for-developerworks$ echo change &gt;&gt; README.md   ## make some modification``caozhi@ repo-for-developerworks$ git add .``caozhi@ repo-for-developerworks$ git commit -m &quot;changes&quot;``[master d774ecf] changes`` ``1 file changed, 1 insertion(+)``caozhi@ repo-for-developerworks$ git push``Username for &apos;https://github.com&apos;: caozhi0321@gmail.com    ## Enter GitHub account name``Password for &apos;https://caozhi0321@gmail.com@github.com&apos;:   ## Enter Password``Counting objects: 6, done.``Delta compression using up to 8 threads.``Compressing objects: 100% (4/4), done.``Writing objects: 100% (6/6), 528 bytes | 528.00 KiB/s, done.``Total 6 (delta 2), reused 0 (delta 0)``remote: Resolving deltas: 100% (2/2), completed with 1 local object.``To https://github.com/caozhi/repo-for-developerworks.git``   ``075c130..d774ecf  master -&gt; master`</span><br></pre></td></tr></table></figure><h3 id="使用-SSH-进行克隆"><a href="#使用-SSH-进行克隆" class="headerlink" title="使用 SSH 进行克隆"></a>使用 SSH 进行克隆</h3><p>使用 SSH 方式进行克隆，需要一步额外的配置 SSH-KEY 的操作。首先需要本地生成一个 SSH Key。我们可以借助 ssh-keygen 工具生成一对 RSA 的秘钥：私钥<code>id_rsa</code> 和公钥 <code>id_rsa.pub</code>。生成的秘钥文件会默认放在 home 目录下的 <code>.ssh</code> 目录下。</p><p>先将 <code>id_rsa.pub</code> 公钥文件的内容复制到剪贴板，如图 5 所示，使用 <code>cat id_rsa.pub</code> 命令可以查看公钥内容，随后将该公钥导入到 GitHub 里的账户之下。</p><p>在 GitHub 页面右上角的头像里点击展开一个下拉菜单，点击 <strong>Settings</strong> 可以打开个设置页面。</p><p>打开 <strong>SSH and GPG keys</strong> 的配置页面，点击右上角的 <strong>New SSH key</strong> 按钮。</p><p>在打开的页面中先设置一个您想导入的公钥的名称，再将前面复制的公钥内容粘贴到大文本框中，点击 <strong>Add SSH key</strong> 即可。</p><p>页面自动跳转回 <strong>SSH and GPG keys</strong> 设置页面，您可以看到在我的账号下成功新增了一个 SSH Key。</p><p>此时我们可以使用 SSH 的方式进行代码克隆，还可以使用 <code>ssh -T</code> 命令检测是否配置成功, 如清单 4 和 5 所示：</p><h5 id="清单-4-使用-SSH-方式克隆"><a href="#清单-4-使用-SSH-方式克隆" class="headerlink" title="清单 4. 使用 SSH 方式克隆"></a>清单 4. 使用 SSH 方式克隆</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`caozhi@ $ git clone git@github.com:caozhi/repo-for-developerworks.git``Cloning into &apos;repo-for-developerworks&apos;...``remote: Counting objects: 20, done.``remote: Compressing objects: 100% (12/12), done.``remote: Total 20 (delta 5), reused 10 (delta 2), pack-reused 0``Receiving objects: 100% (20/20), done.``Resolving deltas: 100% (5/5), done.`</span><br></pre></td></tr></table></figure><h5 id="清单-5-检测-SSH-是否配置成功"><a href="#清单-5-检测-SSH-是否配置成功" class="headerlink" title="清单 5. 检测 SSH 是否配置成功"></a>清单 5. 检测 SSH 是否配置成功</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`caozhi@bogon:~$ ssh -T git@github.com``Hi caozhi! You&apos;ve successfully authenticated, but GitHub does not provide shell access.`</span><br></pre></td></tr></table></figure><p>使用 SSH 的方式进行克隆，将使得我们本地与 GitHub 之间建立了信任连接，也就意味着之后所有需要进行用户认证的地方都不再需要显式地用户名密码认证。例如 <code>git push</code> 会直接通过 SSH 进行认证。经验表明，使用 SSH 的另一个好处是在网络环境较差的情况下，其稳定性要高于 HTTPS 连接。</p><p>至此，我们成功地使用 Git 命令行方式克隆了代码库，之后就可以进行正常的日常开发。</p><h2 id="使用-Git-克隆远程仓库"><a href="#使用-Git-克隆远程仓库" class="headerlink" title="使用 Git 克隆远程仓库"></a>使用 Git 克隆远程仓库</h2><p>当一个开发者刚进入某一项目，一般来说他所要做的第一件事是克隆远程仓库到本地，以进行本地开发工作。远程仓库可以是来自于 GitHub 或者 GitLab 等代码托管服务，也可以是项目组自己所搭设的 Git 服务器。无论是哪种远程仓库，都可以使用 <code>git clone</code> 命令 <code>git clone &lt;repository&gt; [local_path]</code> 将其从远端克隆到本地。命令中间的 <code>&lt;repository&gt;</code> 根据远端仓库提供的连接方式不同，其形式可能不同，例如：</p><ul><li>GitHub 的 HTTPS 连接：<br><code>https://github.com/caozhi/repo-for-developerworks.git</code></li><li>GitHub 的 SSH 连接：<br><a href="mailto:`git@github.com" target="_blank" rel="noopener">`git@github.com</a>:caozhi/repo-for-developerworks.git`</li><li>自建仓库的 SSH 连接：<br><a href="mailto:`git_user@192.168.0.1" target="_blank" rel="noopener">`git_user@192.168.0.1</a>:/usr/local/repo-for-developerworks.git`</li></ul><p>其中前两种 GitHub 的连接方式，其仓库的连接字符串可以在 GitHub 的对应仓库页面中找到，如前<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-git-and-github-2/index.html#1%E5%9B%BE2%E6%9F%A5%E7%9C%8BHTTPS%E5%85%8B%E9%9A%86%E9%93%BE%E6%8E%A5outline" target="_blank" rel="noopener">图 2</a> 和<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-git-and-github-2/index.html#1%E5%9B%BE3%E6%9F%A5%E7%9C%8BSSH%E5%85%8B%E9%9A%86%E9%93%BE%E6%8E%A5outline" target="_blank" rel="noopener">图 3</a>所示。</p><p>第三种自建仓库的 URL 一般需要提供远端服务器上的账号、host 和路径。以上面例子中的连接字符串 <a href="mailto:`git_user@192.168.0.1" target="_blank" rel="noopener">`git_user@192.168.0.1</a>:/usr/local/repo-for-developerworks.git` 为例：</p><ul><li><code>git_user</code> 是服务器上对代码库目录有访问权限的账号。</li><li><code>192.168.0.1</code> 是远端服务器的 IP，也可以是主机名或者 URL。</li><li><code>/usr/local/repo-for-developerworks.git</code> 是服务器上代码库的根目录。</li></ul><p><code>git clone</code> 命令中的 <code>local_path</code> 指定了本地想要存放代码库的地址。该参数是可选参数，如果不指定该参数就会在本地新建一个以远程仓库名为命名的目录，然后以该目录为代码库根目录。图 10 展示了在空目录 <code>clone_demo</code> 中执行不带 <code>local_path</code> 参数的 clone 命令：</p><p>从截图可以看到，<code>git clone</code> 命令在 <code>clone_demo</code> 目录中创建了一个 <code>repo-for-developerworks</code> 的代码库目录。</p><p>从截图可以看到，<code>git clone</code> 命令在 <code>clone_demo</code> 目录中新建了一个我们指定的<code>local_dev-repo</code> 目录，并将其作为本地代码库的根目录。</p><p>我们知道一般操作系统将一个英文句点表示当前目录，因此从截图可以看出，当 <code>local_path</code> 指定为当前目录时，<code>git clone</code> 命令会直接将当前目录作为本地代码库的根目录。</p><p>当然 Git 还提供其它的连接方式如 File、FTP。感兴趣的读者可以自己使用 Git 搭一个 Git 服务器尝试使用 File 和 FTP 方式进行连接。</p><p>默认情况下，<code>git clone</code> 会将远端代码库全部克隆到本地。Git 还支持只克隆特定分支到本地。我们可以使用 <code>git clone -b **branchname** --single-branch git@URL local_path</code> 命令。</p><h2 id="Git-的基本配置"><a href="#Git-的基本配置" class="headerlink" title="Git 的基本配置"></a>Git 的基本配置</h2><p>在克隆了代码库之后，我们一般仍需要对 Git 做一些基本的配置才能使用 Git 进行日常工作。Git 配置的作用域主要有三种：System、Global 和 Local，分别对应的配置文件地址为：</p><ul><li>System：<code>/etc/gitconfig</code>。系统级别有效。</li><li>Global：home 目录下的 <code>~/.gitconfig</code> 文件。用户级别有效。</li><li>Local：代码库目录的 <code>.git/config</code> 文件。代码库级别有效。</li></ul><p>另外我们也可以使用 <code>git config --system -l</code>，<code>git config --global -l</code>，<code>git config --local -l</code> 命令分别列出三个作用域下的配置。跟 Linux 操作系统的环境变量配置类似，Git 在执行命令中会首先查看 local 配置，如果没有找到所需配置会再查看 global 配置，最后再查看 system 配置。</p><p>在使用 <code>git config</code> 命令进行配置的时候，也可以使用 <code>git config --system</code>，<code>git config --global</code>，<code>git config --local</code> 三种不同的选项来修改不同作用域的配置。</p><p>下面介绍一些重要或有用的 Git 配置。</p><h3 id="配置-user-信息"><a href="#配置-user-信息" class="headerlink" title="配置 user 信息"></a>配置 user 信息</h3><p>配置 user 信息在 Git 中是十分重要的一个步骤, username 和 email 不能为空，它们将会被记录在每一条该 user 的 commit 信息中。</p><p>我们可以配置 <code>user.name</code> 和 <code>user.email</code> 的值来配置 user 信息，如清单 6 所示:</p><h5 id="清单-6-配置-user-name-和-user-email"><a href="#清单-6-配置-user-name-和-user-email" class="headerlink" title="清单 6. 配置 user.name 和 user.email"></a>清单 6. 配置 user.name 和 user.email</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`git config --global user.name &quot;caozhi&quot;``git config --global user.email &quot;caozhi0321@gmail.com&quot;`</span><br></pre></td></tr></table></figure><p>也可以将上述命令中的 –global改成 –local来修改只对代码库作用域有效的配置。</p><h3 id="配置命令的别名"><a href="#配置命令的别名" class="headerlink" title="配置命令的别名"></a>配置命令的别名</h3><p>Git 提供了很多有用的命令，我们可以将一些比较常用的命令设置上别名，提高工作效率。例如我们可以将 <code>git log --abbrev-commit</code> 设置一个别名 <code>lg</code>，使得查看 log 时只需要显示 commit id 的短名称，如: <code>git config --global alias.lg &quot;log --abbrev-commit&quot;</code></p><p>设置成功后就可以使用 <code>git lg</code> 来查看 commit 日志。</p><p>当然还可以设置一些其它的别名，如清单 7 所示:</p><h5 id="清单-7-配置-st-和-cm-别"><a href="#清单-7-配置-st-和-cm-别" class="headerlink" title="清单 7. 配置 st 和 cm 别"></a>清单 7. 配置 st 和 cm 别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`git config --global alias.st &quot;status&quot;``git config --global alias.cm &quot;commit&quot;`</span><br></pre></td></tr></table></figure><p>别名可以根据自己的喜好和习惯去设置。将常用的命令设为短别名将大大提高工作效率。</p><h3 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h3><p>配置成功后可以使用 <code>git config --global -l</code> 命令查看配置。</p><h3 id="使用-Config-文件进行配置"><a href="#使用-Config-文件进行配置" class="headerlink" title="使用 Config 文件进行配置"></a>使用 Config 文件进行配置</h3><p>除了使用命令之外，也可以直接编辑 config 文件进行相关配置。</p><h2 id="设置-Git-忽略提交规则"><a href="#设置-Git-忽略提交规则" class="headerlink" title="设置 Git 忽略提交规则"></a>设置 Git 忽略提交规则</h2><p>在进行完代码库克隆和简单的配置之后，接下来我们可以根据项目需要配置一些文件忽略规则。跟大多数的代码库管理工具一样，Git 也可以对不需要被代码库所管理的文件或文件类型进行配置，使得提交代码时，这些文件不会被提交到代码库中。Git 是通过忽略清单<code>.gitignore</code> 文件进行配置的。</p><p>通常我们会考虑将如下类型的文件添加到忽略清单中:</p><ul><li>编译过程的中间文件，例如 <code>*.class</code> 文件、<code>*.o</code> 文件、<code>*.obj</code> 文件等。</li><li>外部依赖的包或者工程编译的包，例如 jar 包、lib 包、dll 包或 war 包等。在有的项目实践中，可能会将这类依赖包也放到代码库中进行管理，通常这不是一个很好的策略，因为这样会显著地增加代码库的大小，降低开发者的工作效率。比较合理的方式是通过构建工具的依赖管理功能来管理这些依赖包，例如 Maven、Gradle 等。</li><li>编译过程中，通过某种机制自动生成的代码。某些项目中，可能会使用脚本或者 <code>xsd schema</code> 文件来生成代码；这类代码只需要将用于自动生成的脚本或者 schema 文件管理起来即可。</li><li>项目的配置文件。同一项目组的不同开发者可能有不同的项目配置，或者配置中包含敏感信息，例如账号密码等，这类配置文件也应该放到 ignore 清单里。</li><li>某些 IDE 的工程配置文件，例如 Eclipse 的 <code>setting</code> 和 <code>project</code> 文件、Idea 的<code>.idea</code> 目录等。</li><li>一些自动生成的系统文件，例如 Windows 的 <code>Thumbs.db</code> 或者 MacOS 的<code>.DS_Store</code> 文件等。</li><li>项目或者 IDE 的日志文件。</li></ul><p><code>.gitignore</code> 文件每行表示一个匹配模式（<code>#</code> 开头的行或者空行除外，<code>#</code> 用于注释）。它使用 glob 模式来进行匹配，glob 模式是一种简化的正则表达式，常用于来进行路径的模式匹配。我们可以在代码库的根目录或者任意子目录添加<code>.gitignore</code> 文件，特定目录下的<code>.gitignore</code> 文件使得忽略规则只在该目录及其子目录下有效。表 1 列出了常用的一些匹配模式的写法：</p><h5 id="表-1-常用匹配模式"><a href="#表-1-常用匹配模式" class="headerlink" title="表 1. 常用匹配模式"></a>表 1. 常用匹配模式</h5><table><thead><tr><th><strong>模式</strong></th><th><strong>含义</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>完整路径</td><td>忽略完整路径所定义的文件</td><td><code>dev/dev.conf</code></td></tr><tr><td>/path</td><td>以 / 开头，只匹配当前目录下路径为 path 的文件</td><td><code>/a.java /a.cpp</code></td></tr><tr><td>path</td><td>不以 / 开头，匹配当前目录及其子目录下所有文件</td><td><code>*.o web.xml</code></td></tr><tr><td>path/</td><td>以 / 结尾，用以只匹配目录；path 目录及其子目录和文件会被忽略；如果 path 是个文件，则不会被忽略</td><td><code>.settings/</code></td></tr><tr><td>带 * 号的模式</td><td>置于文件中，用于匹配所有满足规则的文件</td><td><code>*.zip *.jar</code></td></tr><tr><td>带 ** 的模式</td><td>置于路径中，用于匹配满足 ** 前后的所有路径</td><td><code>Dev/**/dev.conf**/*.jar</code></td></tr><tr><td>!path</td><td>在 ignore 文件中如果前面已经定义了某个模式，但是又有一些特殊文件我们不想被忽略，我们可以用 ! 来匹配</td><td><code>*.jar ##</code> 忽略所有 jar 包 <code>!server.jar ##</code>希望 <code>server.jar</code>仍被跟踪</td></tr></tbody></table><p>注意：</p><ul><li><p>当某个文件已经被提交到代码库中被 Git 所管理起来之后，将该文件再添加进 <code>.gitignore</code> 文件是无效的，对该文件进行修改时，执行 <code>git status</code> 操作之后仍然会提示该文件已被修改。针对已经提交代码库的文件我们又想忽略其修改的场景，将会在本系列第四篇文章中介绍。</p></li><li><p>每个目录下都可以放单独的 <code>.gitignore</code> 文件以控制子目录的忽略规则。</p></li><li><p>即使已经在忽略列表里，当我们确实想要提交一些符合忽略规则的文件时，仍可以使用 <code>git -f add</code> 加具体的文件路径的方式将这些文件提交到库中。</p></li></ul><ul><li>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表模板，可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它。</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>为使用 Git 和 GitHub 进行日常开发做准备，本文详细通过一些列演示向读者讲解了如何采用 SSH 和 HTTPS 两种方式从 GitHub 克隆代码库，如何进行本地 Git 开发环境的基础配置，如何配置 <code>.gitignore</code> 文件等。相信您在阅读完本文之后将有能力自己初始化一套本地的 Git 环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本系列的&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-g
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="git" scheme="http://blog.ozairs.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Azure上的Terraform文档</title>
    <link href="http://blog.ozairs.com/DevOps/Azure%E4%B8%8A%E7%9A%84Terraform%E6%96%87%E6%A1%A3/"/>
    <id>http://blog.ozairs.com/DevOps/Azure上的Terraform文档/</id>
    <published>2019-03-13T03:48:43.000Z</published>
    <updated>2019-03-13T03:53:37.553Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Terraform 在 Azure 上可靠地版本化和创建基础结构。 使用我们的快速入门和教程了解如何创建资源、使用 Azure Terraform 模块和维护包含代码的基础结构。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>配置 Terraform 并使用它在 Azure 中创建 Linux VM。</p><p><a href="https://docs.microsoft.com/azure/virtual-machines/linux/terraform-install-configure" target="_blank" rel="noopener"><img src="https://docs.microsoft.com/azure/media/index/azure_dev-9.svg" alt="img">安装和配置 Terraform</a></p><p><a href="https://docs.microsoft.com/azure/virtual-machines/linux/terraform-create-complete-vm" target="_blank" rel="noopener"><img src="https://docs.microsoft.com/azure/media/index/VirtualMachine.svg" alt="img">创建 Linux VM</a></p><h2 id="分步教程"><a href="#分步教程" class="headerlink" title="分步教程"></a>分步教程</h2><p>了解如何通过 Terraform 从代码创建 Azure 计算和网络基础结构。</p><ul><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-k8s-cluster-with-tf-and-aks" target="_blank" rel="noopener">使用 AKS 创建 Kubernetes 群集</a>。</li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-k8s-cluster-with-aks-applicationgateway-ingress" target="_blank" rel="noopener">将 AKS 与作为入口控制器的应用程序网关配合使用来创建 Kubernetes 群集</a>。</li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-vm-msi" target="_blank" rel="noopener">使用 Azure 市场映像创建启用了 MSI 身份验证的 Terraform VM</a>。</li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-vm-cluster-module" target="_blank" rel="noopener">使用 Azure Terraform 模块创建负载均衡的 VM 群集</a>。</li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-vm-cluster-with-infrastructure" target="_blank" rel="noopener">在 Azure Cloud Shell 中创建负载均衡的 VM 群集</a>。</li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-vm-scaleset-network-disks-hcl" target="_blank" rel="noopener">为 VM 规模集配置网络和存储</a></li><li><a href="https://docs.microsoft.com/zh-cn/azure/terraform/terraform-create-vm-scaleset-network-disks-using-packer-hcl" target="_blank" rel="noopener">从 Packer 自定义映像预配 VM 规模集</a></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>常见部署任务的示例配置模板。</p><ul><li><a href="https://github.com/terraform-providers/terraform-provider-azurerm/tree/master/examples" target="_blank" rel="noopener">GitHub</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><h3 id="Azure-Terraform-模块"><a href="#Azure-Terraform-模块" class="headerlink" title="Azure Terraform 模块"></a>Azure Terraform 模块</h3><p><a href="https://registry.terraform.io/modules/Azure/database/azurerm" target="_blank" rel="noopener">用于数据库的 Azure RM</a></p><p><a href="https://registry.terraform.io/modules/Azure/loadbalancer" target="_blank" rel="noopener">用于负载均衡器的 Azure RM</a></p><p><a href="https://registry.terraform.io/modules/Azure/computegroup" target="_blank" rel="noopener">Azure RM 计算组</a></p><p><a href="https://registry.terraform.io/modules/Azure/network" target="_blank" rel="noopener">Azure RM 网络</a></p><p><a href="https://registry.terraform.io/modules/Azure/compute" target="_blank" rel="noopener">Azure RM 计算</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 Terraform 在 Azure 上可靠地版本化和创建基础结构。 使用我们的快速入门和教程了解如何创建资源、使用 Azure Terraform 模块和维护包含代码的基础结构。&lt;/p&gt;
&lt;h2 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Terraform" scheme="http://blog.ozairs.com/tags/Terraform/"/>
    
  </entry>
  
</feed>
