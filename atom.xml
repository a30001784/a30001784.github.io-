<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>带你走进美丽的墨尔本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ozairs.com/"/>
  <updated>2019-03-28T12:00:08.126Z</updated>
  <id>http://blog.ozairs.com/</id>
  
  <author>
    <name>Mark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【DevOps进阶之路Day1】精通Jenkins Pipeline PartI</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%B2%BE%E9%80%9AJenkins-Pipeline-PartI/"/>
    <id>http://blog.ozairs.com/Jenkins/精通Jenkins-Pipeline-PartI/</id>
    <published>2019-03-28T11:48:43.000Z</published>
    <updated>2019-03-28T12:00:08.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/Jenkins/精通Jenkins-Pipeline-PartI/1.png" alt="jenkins的图像结果"></p><p>詹金斯</p><p>使用过水电工Travis-CI的朋友们，应该很多都试过翘胡子Jenkins。不过笔者猜应该大多数的朋友都是使用Jenkins的自由风格项目。</p><p>虽然Free Style项目可以让你客制化任何的Shell Script来执行你想要的脚本进行测试，但其脚本会依赖Jenkins节点上的环境来执行，Jenkins节点上的任何环境改变都可能影响到你的build job的状况，譬如说，系统套件的升级，工具路径的修改，不同的Job间互相的影响…等等。</p><p>此时，最好的做法是将每个Build Job都用VM或Container做隔离，确保每次执行建置的工作环境都是一样的。</p><p>Travis CI的做法是，为了避免给个建筑互相影响，会为每一个建置都开一台全新的GCE Instance，即使你的测试是在Container mode下执行，都会是全新的VM环境。</p><p>然而Travis CI采用YAML格式的设定档格式，这种做法虽然容易使用，但伴随而来的缺点就是动态性不足，你无法轻易的将某个Step产生出来的结果，做出一些逻辑判断，然后再把不同的操作逻辑丢到另外一台机器上平行执行。</p><p>在Jenkins上的选择相对得多，为了解决日渐庞大复杂的Build Flow，2016年四月Jenkins释出了Pipeline plugin，提供所谓的流水线建设功能来让建设工作变得容易扩大。而这个Pipeline Plugin是基于一种语言 - Apache Groovy开发的。</p><p>这系列文章不是要教读者一步一步如何使用Jenkins Pipeline，而是跟读者们解释Jenkins Pipeline的底层机制，在开发时，可以避免去踩到这些相关（你以为可以，但却不行）的陷阱。</p><h3 id="Apache-Groovy"><a href="#Apache-Groovy" class="headerlink" title="Apache Groovy"></a>Apache Groovy</h3><p>可能很多人对Apache Groovy很陌生，Apache Groovy是一位名叫James Strachan的Java开发者于2003年开发出的一套Java语法相容的新语言，在当时纳入了如Ruby，Perl，Python，Smalltalk ，功能语言等语言的特性，可以被静态编译，也可以被动态执行.Groovy可被编译为JVM字节码在JVM上执行，除此之外，Groovy也可使用Java原生套件，你可以一部分用Java写，一部分使用Groovy去调用Java的类。</p><p>在Groovy里的Closure也可以像函数式语言一样，使用Curry（部分申请）。</p><p>2007年约为Rails火红的年代，Groovy的设计在JAX 2007得到创新奖，2008年时的Grails（Groovy web framework）也在JAX 2008年得到创新奖。</p><p>后来设计Groovy和Grails的这家公司G2One被SpringSource收购，而2009年时VMware又收购了SpringSource。</p><p>一直谈Groovy的背景，可能很多人还是很难想像Groovy的程式码长什么样子，我们就来看几个范例：</p><p>很像Java的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  AGroovyBean &#123; </span><br><span class="line">  String color </span><br><span class="line">&#125; </span><br><span class="line">def bean = new AGroovyBean（）; </span><br><span class="line">bean.color =“baby blue” </span><br><span class="line">bean.setColor（“baby blue”）</span><br></pre></td></tr></table></figure><p>很像Ruby + Perl的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//相当于：取（2.pills）.of（氯喹）。之后（6.hours）6小时后服用2.pill的氯喹</span><br></pre></td></tr></table></figure><p>同Perl与Ruby，在Groovy里面的函数调用的圆括号是可以省略的，Closure也有多种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run = &#123;println it&#125; </span><br><span class="line">def run = &#123; - &gt; println it&#125; </span><br><span class="line">def run = &#123;a  - &gt; println a&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都是一样的。</p><p>此外Groovy本身针对DSL提供一些特别的语言功能，让你可以写出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withDocker（“mysql：5.7”）&#123; </span><br><span class="line">    sh“....” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样的程式码，他在Pipeline里实际上的语意与下列程式码相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.withDocker（“mysql：5.7”，&#123; - &gt; </span><br><span class="line">    this.sh（“...”）</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="管道DSL"><a href="#管道DSL" class="headerlink" title="管道DSL"></a>管道DSL</h3><p>回到Jenkins Pipeline，为什么Jenkins管道使用Groovy设计呢？主要是因为整个Jenkins生态系都是使用Java开发而成，而Java却不适合拿来设计Build Job的DSL（Domain Specific Language），Groovy既相容Java ，JVM就被Jenkins作者拿来设计Pipeline Plugin了。</p><p>编程语言有了DSL的强大功能，你就可以使用这样简化的语法，针对你的Build Pipeline写出一个以程序语言为基础的设定档案。</p><p>譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点（“ec2”）&#123; </span><br><span class="line">    sh“echo Hello World” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的范例就是一个最简单的Scripted Pipeline，纯Groovy的写法，意思是找到一台label为<code>ec2</code>的机器，然后在这台机器上面执行shell命令：“echo Hello World”。</p><p>这边要稍微说明一下，Jenkins Pipeline的语法分为两种，Scripted Pipeline与Declarative Pipeline。</p><p>这两种语法官方网站上并没有详细解释底层机制的不同，由笔者解释的话，<code>Scripted Pipeline</code>就是原生的Groovy Script，会在Jenkins里面的Groovy Shell执行。</p><p>而<code>Declarative Pipeline</code>相对复杂一些，<code>pipeline</code>这个关键字在<code>Jenkinsfile</code>里面是一个步骤（实际上是方法），这个步骤（方法）会将后面整个封闭的代码，对…就是程式码，带入到Pipeline Model Plugin的核心，用一套Groovy写成的Pipeline Model Parser来重新剖析程式码，转为AST后，再经过Groovy的AST Transformer来重新建构整个Pipeline的逻辑。</p><p>也因此你常用的Declarative Pipeline里面，<code>pipeline { }</code>所包起来的部分并不是纯Groovy Syntax，他利用客制化的剖析器（Parser）来达成一些语意上的限制。</p><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>在Groovy里面，万物皆为类，既使是脚本文件，也都被无形的类包装起来。</p><p>举例来说，你开一个纯文字档案叫<code>test.groovy</code>，然后在里面写入一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println this.getClass（）</span><br></pre></td></tr></table></figure><p>结果会印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">班级考试</span><br></pre></td></tr></table></figure><p>发现什么了吗？也就是说，当Jenkins在执行你的<code>Jenkinsfile</code>的时候，你在<code>Jenkinsfile</code>里就是在类的某个方法里面执行，而你的档案名称就变成你的类名。怎么证明呢？</p><p>如果你尝试把Call Stack dump出来会看到什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StackTraceElement [] cause = Thread.currentThread（）。getStackTrace（）; </span><br><span class="line">打印原因</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xr_89aKHzfC7BkcnzOq5JQ.png" alt="img"></p><p>注意到上面，，<code>test.run</code>其实意味着我们脚本里面写的程式码，是被包装在一个叫做run的方法里面执行的。</p><p>Groovy会编译你的程式码，转换为一个继承<code>groovy.lang.Script</code>的类别，这个类别包含了一个抽象化的方法（方法）叫做<code>run</code>。</p><p>当这个脚本被编译时，脚本体会变成这个运行方法的一部分，而其他的方法定义会转为这个类实现的一部分。</p><p>这个Stack Call往上追，你会看到<code>GroovyShell.run</code>，这是什么东西呢？</p><p><code>GroovyShell</code> 提供了一个介面，让你可以在Groovy里面动态建立一个执行环境，然后在这个沙盒里面执行程式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def binding = new Binding（）               </span><br><span class="line">def shell = new GroovyShell（binding）binding.setVariable（      </span><br><span class="line">&apos;x&apos;，1）                </span><br><span class="line">binding.setVariable（&apos;y&apos;，3）</span><br><span class="line">shell.evaluate&apos;z = 2 * x + y&apos;assert                  </span><br><span class="line">binding。 getVariable（&apos;z&apos;）== 5</span><br></pre></td></tr></table></figure><p><code>Binding</code>就是用来连结目前的执行环境与沙盒执行环境的类别，而Jenkins就是利用Binding来将Jenkins的环境资讯注入到<code>Jenkinsfile</code>执行的。</p><p>而这个脚本基类可以被客制化，DSL的设计师可以将这个基类改为自己特制的类来提供一些特别功能。</p><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEF配置=新CompilerConfiguration（）config.scriptBaseClass = &apos;MyBaseClass&apos;高清壳=新GroovyShell（this.class.classLoader，配置）shell.evaluate “” “ </span><br><span class="line">     的setName &apos;朱迪思&apos; </span><br><span class="line">     迎接（） </span><br><span class="line">”“”</span><br></pre></td></tr></table></figure><p>而你可以实作一个类叫做<code>MyBaseClass</code>来来提供<code>setName</code>与<code>greet</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抽象类MyBaseClass扩展Script &#123; </span><br><span class="line">     String name </span><br><span class="line">     public void greet（）&#123; </span><br><span class="line">         println“Hello，$ name！” </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这边我想读者已经很清楚了，为什么Jenkinsfile里面会有<code>sh</code>，<code>pipeline</code>，<code>echo</code>这些特有的函数可以用？</p><p>其实，你当使用<code>pipeline {}</code>的时候，他实际上就是等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.pipeline（&#123; - &gt; </span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><p>今天的Jenkins实作细节就先到这边，下集待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/Jenkins/精通Jenkins-Pipeline-PartI/1.png&quot; alt=&quot;jenkins的图像结果&quot;&gt;
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>如何遵循尽职调查法，做更多有效的工作</title>
    <link href="http://blog.ozairs.com/%E8%AF%84%E8%AE%BA/%E5%A6%82%E4%BD%95%E9%81%B5%E5%BE%AA%E5%B0%BD%E8%81%8C%E8%B0%83%E6%9F%A5%E6%B3%95%EF%BC%8C%E5%81%9A%E6%9B%B4%E5%A4%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C/"/>
    <id>http://blog.ozairs.com/评论/如何遵循尽职调查法，做更多有效的工作/</id>
    <published>2019-03-26T02:56:31.000Z</published>
    <updated>2019-03-26T03:09:34.360Z</updated>
    
    <content type="html"><![CDATA[<p>【译文】</p><p>ç什么容易谈到apitalizing是人们如何成功往往会获得成功。它也是成功故事的一部分，经常被遗漏，因为如果没有被误解，几乎不可能谈论它。</p><p>成功的人不努力工作（这个词，“难”，有错误的含义）。成功人士不会继续向死胡同努力。他们也不会强迫什么是不可行的，无效的，或者根本就是不锻炼。他们在看到最多结果的地方一直工作，他们能够经常工作的原因 - 通常比同龄人更多 - 是因为工作对他们来说有点自然。如果没有，他们就会筋疲力尽，被烧毁，而且结果很少。</p><p>传统智慧告诉你不要放弃<em>，</em>无论如何。但人们总是告诉你，当你停止努力让事情发生时，好事往往会发生。最受欢迎的关系建议是，当我们停止寻找他们时，我们的合作伙伴会出现。对于许多夫妻来说，他们想要怀孕的那一刻就是他们怀孕的那一刻。</p><p>当你试图强迫幸福时，它就会让你失望。如果不这样做，它往往会自行发生。你最终在生活中所做的工作几乎从来都不是A计划; 这是计划B，当你放弃那些不自然的事情时，你就开始做了。当你试着不去思考像白象这样的东西时 - 你可以专注于它。你试图避免的东西越多，你到处都看得越多。你试图抓住充满干燥沙子的拳头越多，它越快滑过你的手指。</p><blockquote><p>有些事情是我们无法控制的，它们会将我们重新定向到比我们最初为自己选择的结果更大的结果。</p></blockquote><p>人们通常不希望将他们在生活中的成功归因于机会，命运或预先存在的条件，因为当然，这些并不是唯一的因素。但是，根本不承认它们是剥夺他人的重要见解。成功不仅仅是因为很多人努力工作而使某人“努力”。你可以说服务行业的人比拥有他们工作的机构的人工作更加困难。他们看到不同的结果，因为他们的能量是针对不同的事情。当我们不得不强迫自己去做时，工作变得艰难，当它本身无趣或没有吸引力时，我们必须强迫自己。</p><p>当我们承诺做一些我们倾向于擅长或有自然兴趣的事情时，我们会立即开始一个快速加强的反馈循环。当我们付出努力并立即获得积极成果时，我们的能量得到加强。当我们看到结果并且相信那些结果时，我们会变得纪律严明。出于这个原因，有些人认为我们最喜欢的东西往往只是我们擅长的东西。</p><p>当您忘记时间并完全沉浸在任务中时，“ 心流”就是最佳性能状态。这通常是我们生产出我们生活中最好的作品，而那些每天都能做到的人往往会为自己的长期成功做出令人难以置信的成功。但自然实现心流状态几乎是不可能的，你必须强迫自己去做。</p><p>任何成功的人都会告诉你 - 尽管他们确实做了很多工作 - 但几乎总是有一些无助的元素在起作用。这项工作是学习如何出现，脱离自己的头脑，让它发生，而不会让你产生怀疑和焦虑。</p><hr><p>牛逼最省力的他律是比生产力黑客更多。这不是一个快速，简单的成功计划。这是我们生活中不变的，经常令人沮丧的一部分。这是我们的自然法则如何治理的一个要素，它在某种程度上是一种比我们更大的力量，一种我们想要理解并对我们有利的工作。</p><p>大自然遵循蓝图。当我们不干扰治疗时，我们的身体会自愈。我们的生活往往以同样的方式运作。当我们谈论生活中“无法控制”的东西时，它几乎总是消极的，如票据或损失或疾病。但它也是相反的。有些事情是我们无法控制的，它们会将我们重新定向到比我们最初为自己选择的结果更大的结果。</p><p>我们每个人都有一套完全独特的优点和缺点，好奇心，激情，沮丧和伤口。这些交叉往往是我们生活中最肥沃的繁殖地。我们经常回顾并且可以看到这些看似随机的因素中的每一个都在我们最终结束的地方发挥了作用。它们不是随机的; 他们绘制了我们根本上是谁的蓝图。</p><blockquote><p>您需要清楚地了解最终目标，然后将其分解为更小的步骤。这不是魔术。这就是我们取得进步的方式。</p></blockquote><p>我们的选择是我们是否激活了潜在的潜力。我们的身体和生活就像能量系统。当我们用压力阻塞他们时，他们开始出现故障。这就像我们心灵河底的一个错误 - 水仍然在顶部涟漪。我们需要清楚地了解我们的最终目标，然后将其分解为更小的步骤。这不是魔术。这就是我们取得进步的方式。</p><p>但是，以一种破坏和窘迫的方式强迫事情会让他们失望。想要的东西让你处于没有它的能量之中。过度依赖于结果会使你如此着迷于完美和你自己的时间，最终破坏真正重要的东西，这是最终的结果。我们怀念成功不是世界给予我们的事实; 这是我们为世界提供的东西，然后从中获益。</p><p>成功始于我们。我们的兴趣，技能和激情; 我们的创伤和不满; 我们肩膀上的筹码和心中的梦想都不是随意的。它们交叉的地方是我们的呼唤，它对我们每个人来说都是完全独特的。我们不必强迫它。我们没有必要竞争它。我们只需要回应它，开始向它展示，然后，像我们手掌中的沙子，学会放松我们的抓地力，并让它成为现实。</p><p>【原文】</p><p>Capitalizing on what comes easily is how successful people tend to get ahead. It’s also part of the success story that’s often left out because it’s almost impossible to talk about without it becoming misconstrued.</p><p>Successful people don’t work hard (that word, “hard,” has the wrong connotation). Successful people don’t keep throwing effort at dead ends. They also don’t force what’s nonviable, ineffective, or just simply not working out. They work consistently where they see the most results, and the reason they are able to work so often—usually much more than their peers—is because the work comes somewhat naturally to them. If it didn’t, they’d be exhausted, burned out, and left with minimal results.</p><p>Conventional wisdom tells you not to give up—ever<em>,</em> no matter what. But people tell you all the time that good things tend to happen when you stop trying so hard to make them happen. The most popular relationship advice is that our partners will show up when we stop looking for them. For many couples, the moment they stop trying to get pregnant is the moment they conceive.</p><p>When you try to force happiness, it eludes you. If you don’t, it tends to happen on its own. The work you end up doing in your life is almost never Plan A; it’s Plan B, which is what you started doing when you gave up on what didn’t come naturally. When you try not to think about something—like a white elephant—it’s all you can focus on. The more you try to avoid something, the more you see it everywhere. The more you try to grip a fist full of dry sand, the faster it slips through your fingers.</p><blockquote><p>There are things out of our control that sort of redirect us to outcomes greater than we would have initially chosen for ourselves.</p></blockquote><p>People generally don’t want to misattribute their successes in life to chance, fate, or pre-existing conditions because, of course, those aren’t the only factors at play. But to not acknowledge them at all is to deprive others of vital insight. Success is more than just how “hard” someone works because a lot of people work hard. You could argue that people in the service industry work a whole lot harder than the people who own the establishment they’re working in. They see different results because their energy is directed toward different things. Work becomes hard when we have to force ourselves to do it, and we have to force ourselves when it’s inherently uninteresting or unappealing.</p><p>When we commit to doing something we are inclined to be good at or have a natural interest in, we start an immediate feedback loop that strengthens quickly. When we put effort toward something and immediately receive positive results, our energy is reinforced. We become disciplined when we see results and when we trust those results. For this very reason, some people suggest that the things we enjoy most are often just the things we are good at.</p><p>“<a href="https://whatis.techtarget.com/definition/flow" target="_blank" rel="noopener">Flow</a>” is that peak performance state when you lose track of time and become fully immersed in your task. This is often when we produce the best work of our lives, and those who can do it every day often position themselves for incredible long-term success. But it’s almost impossible to achieve a flow state doing something you have to force yourself to do.</p><p>Any successful person will tell you that—although they have certainly worked a lot—there is almost always an element of effortlessness at play. The work is learning how to show up, get out of your own head, and allow it to happen without your doubts and anxieties stopping you.</p><hr><p>The law of least effort is more than a productivity hack. It’s not a quick, easy success scheme. It’s a constant, often frustrating, part of our lives. It’s an element of how our natural laws are governed, and it’s in some ways a force greater than we are, one that we want to understand and have work in our favor.</p><p>Nature follows a blueprint. Our bodies heal themselves when we don’t interfere with the healing. Our lives tend to function the same way. When we talk about what we “can’t control” in life, it’s almost always negative—like bills or loss or illness. But it works the opposite way too. There are things out of our control that sort of redirect us to outcomes greater than we would have initially chosen for ourselves.</p><p>Within each of us is a completely unique set of strengths and weaknesses, curiosities, passions, distastes, and wounds. Where these intersect tends to be the most fertile breeding ground of our lives. We often look back and can see that each of these seemingly random factors played a role in where we ultimately ended up. They weren’t random; they mapped a blueprint of who we fundamentally are.</p><blockquote><p>You need to clearly understand the end goal and then break it down into smaller steps. This isn’t magic. This is how we make progress.</p></blockquote><p>Our choice is whether we activate the latent potential. Our bodies and our lives are like energy systems. When we clog them with stress, they start to malfunction. It’s like a fault at the bottom of the river of our psyches—the water still ripples at the top. We need to clearly understand our end goals and then break them down into smaller steps. This isn’t magic. This is how we make progress.</p><p>But forcing things in a way that wreaks havoc and distress holds them back. Wanting something puts you in the energy of not having it. Being overly attached to an outcome makes you so obsessed with perfection and your own timing that you end up sabotaging what really matters, which is the end result. We miss the fact that success is not something the world gives us; it’s something we offer the world and then reap the benefits of doing so.</p><p>Success starts with us. Our interests, skills, and passions; our trauma and our grievances; the chips on our shoulders and the dreams in our hearts are not random. The place where they intersect is our calling, and it is wholly and completely unique to each of us. We don’t have to force it. We don’t have to compete for it. We simply have to respond to it, start showing up to it, and then, like the sand in our palms, learn to loosen our grip, and allow it to be.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【译文】&lt;/p&gt;
&lt;p&gt;ç什么容易谈到apitalizing是人们如何成功往往会获得成功。它也是成功故事的一部分，经常被遗漏，因为如果没有被误解，几乎不可能谈论它。&lt;/p&gt;
&lt;p&gt;成功的人不努力工作（这个词，“难”，有错误的含义）。成功人士不会继续向死胡同努力。他们也不会强
      
    
    </summary>
    
      <category term="评论" scheme="http://blog.ozairs.com/categories/%E8%AF%84%E8%AE%BA/"/>
    
    
      <category term="励志" scheme="http://blog.ozairs.com/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动化部署</title>
    <link href="http://blog.ozairs.com/Jenkins/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/Jenkins/Jenkins自动化部署/</id>
    <published>2019-03-25T10:13:57.000Z</published>
    <updated>2019-03-25T11:48:37.525Z</updated>
    
    <content type="html"><![CDATA[<p>一、 Pipeline平台部署</p><ol><li><a href="https://www.cnblogs.com/shenh/p/8963688.html" target="_blank" rel="noopener">jenkins + pipeline构建自动化部署</a></li></ol><p><a href="https://www.cnblogs.com/shenh/p/8963688.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenh/p/8963688.html</a></p><ol start="2"><li><p><a href="https://zhuanlan.zhihu.com/p/51533506" target="_blank" rel="noopener">Jenkins pipeline脚本编写实践分享（一）上篇</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59160884" target="_blank" rel="noopener">Jenkins pipeline脚本编写实践分享（二）</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/41604558" target="_blank" rel="noopener">jenkins学习之pipeline</a></p></li><li><a href="https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html" target="_blank" rel="noopener">Jenkins持续集成 - 管道详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、 Pipeline平台部署&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/shenh/p/8963688.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jenkins + pipeline构建自动
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Chef入门与实战</title>
    <link href="http://blog.ozairs.com/DevOps/Chef%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Chef入门与实战/</id>
    <published>2019-03-24T06:51:16.000Z</published>
    <updated>2019-03-24T07:21:08.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Chef-专用名词"><a href="#一、Chef-专用名词" class="headerlink" title="一、Chef 专用名词"></a>一、Chef 专用名词</h3><pre><code>1. package2. service3. file</code></pre><p>​    </p><h3 id="二、Chef命令汇总"><a href="#二、Chef命令汇总" class="headerlink" title="二、Chef命令汇总"></a>二、Chef命令汇总</h3><ol><li>执行Recipe： chef-client –local-mode hello.rb</li><li>创建Cookbook： chef generate cookbook cookbookname</li><li>创建Recipe： chef generate recipe cookbook/apacher server</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Chef-专用名词&quot;&gt;&lt;a href=&quot;#一、Chef-专用名词&quot; class=&quot;headerlink&quot; title=&quot;一、Chef 专用名词&quot;&gt;&lt;/a&gt;一、Chef 专用名词&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. package
2. service
3. f
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Chef" scheme="http://blog.ozairs.com/tags/Chef/"/>
    
  </entry>
  
  <entry>
    <title>Docker 实战应用</title>
    <link href="http://blog.ozairs.com/Docker/Docker-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Docker/Docker-实战应用/</id>
    <published>2019-03-23T08:39:20.000Z</published>
    <updated>2019-03-25T11:49:30.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Docker平台部署"><a href="#一、Docker平台部署" class="headerlink" title="一、Docker平台部署"></a>一、Docker平台部署</h3><p>Amazon ECS 的 Docker 基本知识</p><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker</a></p><h3 id="二、ECS中Dokcer的配置"><a href="#二、ECS中Dokcer的配置" class="headerlink" title="二、ECS中Dokcer的配置"></a>二、ECS中Dokcer的配置</h3><ol><li><p>Environment设置Entry Point</p><p>sh, -c, while true; do echo $(date)&gt; /shared-data/index_html; sleep 5; done</p></li><li><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/ecs-cli-tutorial-fargate.html" target="_blank" rel="noopener">使用 Amazon ECS CLI 创建包含 Fargate 任务的集群</a></p></li><li><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/ecs-cd-pipeline.html" target="_blank" rel="noopener">教程：CodePipeline 持续部署</a></p></li></ol><h3 id="三、使用Jenkins配合Github-hook持续集成"><a href="#三、使用Jenkins配合Github-hook持续集成" class="headerlink" title="三、使用Jenkins配合Github hook持续集成"></a>三、使用Jenkins配合Github hook持续集成</h3><ol><li><a href="http://callmedadaxin.github.io/2018/07/20/jenkins-github-hook" target="_blank" rel="noopener">使用Jenkins配合Github hook持续集成</a></li><li><a href="http://callmedadaxin.github.io/2018/07/20/jenkins-github-hook/" target="_blank" rel="noopener">使用Jenkins和Amazon ECS设置构建管道</a></li><li><a href="https://aws.amazon.com/cn/blogs/china/how-to-implement-the-continuous-integrated-continuous-deployment-solution-on-amazon-ecs-using-aws-codepipelineaws-codebuild-and-aws-cloudformation" target="_blank" rel="noopener">如何使用AWS CodePipeline，AWS CodeBuild与AWS CloudFormation实现Amazon ECS上的持续集成持续部署解决方案</a></li><li><a href="https://www.cnblogs.com/DFX339/p/8351780.html" target="_blank" rel="noopener">Docker使用jenkins部署java项目到远程linux</a></li><li><a href="https://zhuanlan.zhihu.com/p/39289273" target="_blank" rel="noopener">jenkins+docker+git构建java自动化部署</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Docker平台部署&quot;&gt;&lt;a href=&quot;#一、Docker平台部署&quot; class=&quot;headerlink&quot; title=&quot;一、Docker平台部署&quot;&gt;&lt;/a&gt;一、Docker平台部署&lt;/h3&gt;&lt;p&gt;Amazon ECS 的 Docker 基本知识&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>AWS 实战部署</title>
    <link href="http://blog.ozairs.com/AWS/AWS-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/AWS/AWS-实战部署/</id>
    <published>2019-03-22T11:30:34.000Z</published>
    <updated>2019-03-22T11:33:28.244Z</updated>
    
    <content type="html"><![CDATA[<p>如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon ECS 首次运行向导或 Amazon ECS 命令行界面 (CLI) 启动首个集群的准备。</p><p>注意</p><p>因为 Amazon ECS 使用 Amazon EC2 的许多组件，所以，您可以将 Amazon EC2 控制台用于这些步骤中的许多步骤。</p><p>要开始设置 Amazon ECS，请完成以下任务。如果您已完成以下任何步骤，可以将其跳过并继续安装自定义 AWS CLI。</p><ol><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#sign-up-for-aws" target="_blank" rel="noopener">注册 AWS</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-user" target="_blank" rel="noopener">创建 IAM 用户</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-role" target="_blank" rel="noopener">创建 IAM 角色</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-key-pair" target="_blank" rel="noopener">创建密钥对</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-vpc" target="_blank" rel="noopener">创建 Virtual Private Cloud</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#install_aws_cli" target="_blank" rel="noopener">安装 AWS CLI</a></li></ol><h2 id="注册-AWS"><a href="#注册-AWS" class="headerlink" title="注册 AWS"></a>注册 AWS</h2><p>当您注册 AWS 时，您的 AWS 账户会自动注册所有服务，包括 Amazon EC2 和 Amazon ECS。您只需为使用的服务付费。</p><p>如果您已有 AWS 账户，请跳到下一个任务。如果您还没有 AWS 账户，请使用以下步骤创建。</p><p><strong>创建 AWS 账户</strong></p><ol><li><p>打开 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html" target="_blank" rel="noopener">https://aws.amazon.com/</a>，然后选择 <strong>Create an AWS Account (创建 AWS 账户)</strong>。</p><p>注意</p><p>如果您之前曾使用 AWS 账户根用户 凭证登录 AWS 管理控制台，请选择 <strong>Sign in to a different account (登录其他账户)</strong>。如果您之前曾使用 IAM 凭证登录控制台，请选择 <strong>Sign-in using root account credentials (使用根账户凭证登录)</strong>。然后选择 <strong>Create a new AWS account (创建新的 AWS 账户)</strong>。</p></li><li><p>按照联机说明操作。</p><p>在注册时，您将接到一通电话，要求您使用电话键盘输入一个验证码。</p></li></ol><p>请记下您的 AWS 账号，因为在下一个任务中您会用到它。</p><h2 id="创建-IAM-用户"><a href="#创建-IAM-用户" class="headerlink" title="创建 IAM 用户"></a>创建 IAM 用户</h2><p>AWS 中的服务（如 Amazon EC2 和 Amazon ECS）要求您在访问时提供凭证，以便服务可以确定您是否有权限访问其资源。控制台要求您的密码。您可以为您的 AWS 账户创建访问密钥以访问命令行界面或 API。但是，我们不建议您使用 AWS 账户的凭证访问 AWS，而建议您改用 AWS Identity and Access Management (IAM)。创建 IAM 用户，然后将该用户添加到具有管理权限的 IAM 组或授予此用户管理权限。然后，您就可以使用专门的 URL 和该 IAM 用户的凭证来访问 AWS。</p><p>如果您已注册 AWS 但尚未为自己创建一个 IAM 用户，则可以使用 IAM 控制台自行创建。</p><p><strong>为您自己创建一个 IAM 用户并将该用户添加到管理员组</strong></p><ol><li><p>使用 AWS 账户电子邮件地址和密码，以 <em>AWS 账户根用户</em> 身份登录到 IAM 控制台 (<a href="https://console.aws.amazon.com/iam/" target="_blank" rel="noopener">https://console.aws.amazon.com/iam/</a>)。</p><p>注意</p><p>强烈建议您遵守以下使用 <strong>Administrator</strong> IAM 用户的最佳实践，妥善保存根用户凭证。只在执行少数<a href="https://docs.aws.amazon.com/general/latest/gr/aws_tasks-that-require-root.html" target="_blank" rel="noopener">账户和服务管理任务</a>时才作为根用户登录。</p></li><li><p>在控制台的导航窗格中，选择 <strong>Users (用户)</strong>，然后选择 <strong>Add user (添加用户)</strong>。</p></li><li><p>对于 <strong>User name (用户名)</strong>，键入 <strong>Administrator</strong>。</p></li><li><p>选中 <strong>AWS 管理控制台 access (AWS 管理控制台访问)</strong> 旁边的复选框，选择 <strong>Custom password (自定义密码)</strong>，然后在文本框中键入新用户的密码。您可以选择 <strong>Require password reset</strong> (需要重置密码) 以强制用户在下次登录时创建新密码。</p></li><li><p>选择<strong>下一步: 权限</strong>。</p></li><li><p>在<strong>设置权限</strong>页面上，选择<strong>将用户添加到组</strong>。</p></li><li><p>选择 <strong>Create group</strong>。</p></li><li><p>在 <strong>Create group (创建组)</strong> 对话框中，对于 <strong>Group name (组名称)</strong>，键入 <strong>Administrators</strong>。</p></li><li><p>对于 <strong>Filter policies (筛选策略)</strong>，选中 <strong>AWS managed - job function (AWS 托管 - 工作职能)</strong> 的复选框。</p></li><li><p>在策略列表中，选中 <strong>AdministratorAccess</strong> 的复选框。然后选择 <strong>Create group</strong>。</p></li><li><p>返回到组列表中，选中您的新组所对应的复选框。如有必要，选择 <strong>Refresh</strong> 以在列表中查看该组。</p></li><li><p>选择 <strong>Next: Tags (下一步: 标签)</strong> 通过以键值对的形式附加标签来向用户添加元数据。</p></li><li><p>选择 <strong>Next: Review</strong> 以查看要添加到新用户的组成员资格的列表。如果您已准备好继续，请选择 <strong>Create user</strong>。</p></li></ol><p>您可使用此相同的流程创建更多的组和用户，并允许您的用户访问 AWS 账户资源。要了解有关使用策略限制用户对特定 AWS 资源的权限的信息，请参阅<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html" target="_blank" rel="noopener">访问管理</a>和<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_examples.html" target="_blank" rel="noopener">示例策略</a>。</p><p>要以该新 IAM 用户的身份登录，请从 AWS 控制台注销，然后使用以下 URL，其中 <em>your_aws_account_id</em> 是您不带连字符的 AWS 账号（例如，如果您的 AWS 账号是 <code>1234-5678-9012</code>，则您的 AWS 账户 ID 是 <code>123456789012</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_aws_account_id.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>输入您刚创建的 IAM 用户名和密码。登录后，导航栏显示 <em>your_user_name</em> @ <em>your_aws_account_id</em>。</p><p>如果您不希望您的登录页面 URL 包含 AWS 账户 ID，可以创建账户别名。从 IAM 控制面板中，选择 <strong>Create Account Alias (创建账户别名)</strong>，然后输入一个别名，例如您的公司名称。要在创建账户别名后登录，请使用以下 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_account_alias.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>要为您的账户验证 IAM 用户的登录链接，请打开 IAM 控制台并在控制面板的 <strong>IAM users sign-in link (IAM 用户登录链接)</strong> 下进行检查。</p><p>有关 IAM 的更多信息，请参阅 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/" target="_blank" rel="noopener">AWS Identity and Access Management 用户指南</a>。</p><h2 id="创建-IAM-角色"><a href="#创建-IAM-角色" class="headerlink" title="创建 IAM 角色"></a>创建 IAM 角色</h2><p>在 Amazon ECS 容器代理可以代表您调用 Amazon ECS API 操作之前，它需要服务的 IAM 策略和角色，以便了解属于您的代理。</p><p>对于使用 EC2 启动类型的任务，您可以创建一个 IAM 角色，该角色可让代理知道应向哪个账户注册容器实例。当您使用 Amazon 通过此角色提供的经 Amazon ECS 优化的 AMI 启动容器实例时，代理会自动将容器实例注册到 <code>default</code> 集群中。此角色称为 Amazon ECS 容器实例 IAM 角色。有关更多信息，请参阅<a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/instance_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 容器实例 IAM 角色</a>。</p><p>Amazon ECS 容器代理还会代表您调用 Amazon EC2 和 Elastic Load Balancing API，以便在负载均衡器中注册和取消注册容器实例。您必须在启动服务前为其创建一个 IAM 角色，然后才能将负载均衡器附加到 Amazon ECS 服务。此要求适用于您计划用于负载均衡器的任意 Amazon ECS 服务。此角色称为 Amazon ECS 服务计划程序 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/service_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 服务计划程序 IAM 角色</a>。</p><p>对于使用 Fargate 启动类型的任务，您可以创建一个 IAM 角色，该角色允许代理从 Amazon ECR 中提取容器映像或者使用 awslogs 日志驱动程序，该驱动程序是当前唯一受支持的此启动类型的日志记录选项。此角色称为 Amazon ECS 任务执行 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/task_execution_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 任务执行 IAM 角色</a>。</p><p>注意</p><p>在 Amazon ECS 控制台首次运行体验中，将自动为您创建这些 IAM 角色，因此，如果您打算使用控制台，则可以继续下一个部分。如果您不打算使用控制台，而是计划使用 AWS CLI，则需要手动创建这些 IAM 角色。</p><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>对于 Amazon ECS，密钥对只有在您打算使用 EC2 启动类型时才需要。</p><p>AWS 使用公有密钥密码术来保护实例的登录信息。 Linux 实例（例如 Amazon ECS 容器实例）没有用于 SSH 访问的密码。您使用密钥对安全地登录到实例。您可以在启动容器实例时指定密钥对的名称，然后提供私有密钥（使用 SSH 登录时）。</p><p>如果您尚未创建密钥对，则可以通过 Amazon EC2 控制台自行创建。如果您计划在多个区域启动实例，则需要在每个区域中创建密钥对。有关区域的更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p><strong>创建密钥对</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中，选择密钥对所在的区域。您可以选择向您提供的任何区域，无需理会您身处的位置。但是，密钥对特定于区域。例如，如果您计划在美国东部（俄亥俄）区域中启动容器实例，则必须在美国东部（俄亥俄）区域中为实例创建密钥对。</p><p><img src="/AWS/AWS-实战部署/1.png" alt="                         选择一个区域                     "></p></li><li><p>在导航窗格中的 <strong>NETWORK &amp; SECURITY</strong> 下，选择 <strong>Key Pairs</strong>。</p><p>提示</p><p>导航窗格位于控制台的左侧。如果您看不到窗格，它可能被最小化了；请选择箭头展开该窗格。您可能必须向下滚动才能看到 <strong>Key Pairs</strong> 链接。</p><p><img src="/AWS/AWS-实战部署/2.png" alt="                         打开密钥对页                     "></p></li><li><p>选择 <strong>Create Key Pair</strong>。</p></li><li><p>在 <strong>Create Key Pair</strong> 对话框的 <strong>Key pair name</strong> 字段中输入新密钥对的名称，然后选择 <strong>Create</strong>。使用一个容易记住的名称 (如您的 IAM 用户名) 后跟 <code>-key-pair</code> 加区域名称。例如，<em>me</em>-key-pair-<em>useast2</em>。</p></li><li><p>您的浏览器会自动下载私有密钥文件。基本文件名是您为密钥对指定的名称，文件扩展名为 <code>.pem</code>。将私有密钥文件保存在安全位置。</p><p>重要</p><p>这是您保存私有密钥文件的唯一机会。启动实例时，提供密钥对的名称；每次连接到实例时，提供相应的私有密钥。</p></li><li><p>如果您在 macOS 或 Linux 计算机上使用 SSH 客户端连接到您的 Linux 实例，请使用以下命令设置您私有密钥文件的权限，以确保只有您可以读取它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 your_user_name-key-pair-region_name.pem</span><br></pre></td></tr></table></figure></li></ol><p>有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" target="_blank" rel="noopener">Amazon EC2 密钥对</a>。</p><p><strong>使用密钥对连接到实例</strong></p><p>要从运行 macOS 或 Linux 的计算机连接到 Linux 实例，需要使用 <code>-i</code> 选项对 SSH 客户端指定 <code>.pem</code> 文件和私有密钥的路径。若要从运行 Windows 的计算机连接到 Linux 实例，可以使用 MindTerm 或 PuTTY。如果您计划使用 PuTTY，则需要安装它并遵循以下过程将 <code>.pem</code> 文件转换为 <code>.ppk</code> 文件。</p><p><strong>（可选）准备使用 PuTTY 从 Windows 连接到 Linux 实例</strong></p><ol><li><p>从 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a> 下载并安装 PuTTY。请务必安装整个套件。</p></li><li><p>启动 PuTTYgen（例如，在<strong>开始</strong>菜单中，依次单击<strong>所有程序 &gt; PuTTY &gt; PuTTYgen</strong> ）。</p></li><li><p>在 <strong>Type of key to generate</strong> 下，选择 <strong>RSA</strong>。</p><p><img src="/AWS/AWS-实战部署/3.png" alt="                         PuTTYgen 中的 SSH-2 RSA 密钥                     "></p></li><li><p>选择 <strong>Load</strong>。默认情况下，PuTTYgen 仅显示扩展名为 <code>.ppk</code> 的文件。要找到您的 <code>.pem</code> 文件，请选择显示所有类型的文件的选项。</p><p><img src="/AWS/AWS-实战部署/4.png" alt="                         选择所有文件类型                     "></p></li><li><p>选择您在上一个过程中创建的私有密钥文件，然后选择 <strong>Open</strong>。选择 <strong>OK</strong> 关闭确认对话框。</p></li><li><p>选择 <strong>Save private key (保存私有密钥)</strong>。PuTTYgen 会显示一条警告，提示将在未提供口令的情况下保存密钥。选择<strong>是</strong>。</p></li><li><p>为密钥指定密钥对所用的相同名称。PuTTY 会自动添加 <code>.ppk</code> 文件扩展名。</p></li></ol><h2 id="创建-Virtual-Private-Cloud"><a href="#创建-Virtual-Private-Cloud" class="headerlink" title="创建 Virtual Private Cloud"></a>创建 Virtual Private Cloud</h2><p>Amazon Virtual Private Cloud (Amazon VPC) 允许您在已定义的虚拟网络内启动 AWS 资源。强烈建议您在 VPC 中启动您的容器实例。</p><p>注意</p><p>Amazon ECS 控制台首次运行体验会为您的集群创建 VPC，因此，如果您打算使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您有默认 VPC，也可以跳过此部分并进入下一个任务，即 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a>。要确定您是否具有默认 VPC，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html#console-updates" target="_blank" rel="noopener">Amazon EC2 控制台中支持的平台</a>。否则，您可以使用以下步骤在账户中创建非默认 VPC。</p><p>重要</p><p>如果您的账户在某个区域中支持 Amazon EC2 Classic，则您在该区域没有默认 VPC。</p><p><strong>创建非默认 VPC</strong></p><ol><li>打开 Amazon VPC 控制台 <a href="https://console.aws.amazon.com/vpc/" target="_blank" rel="noopener">https://console.aws.amazon.com/vpc/</a>。</li><li>从导航栏中，为 VPC 选择区域。VPC 特定于某一区域，因此您应选择已创建密钥对的区域。</li><li>在 VPC 控制面板上，选择 <strong>Launch VPC Wizard (启动 VPC 向导)</strong>。</li><li>在 <strong>Step 1: Select a VPC Configuration</strong> 页面上，确保选中 <strong>VPC with a Single Public Subnet</strong>，然后选择 <strong>Select</strong>。</li><li>在 <strong>Step 2: VPC with a Single Public Subnet (步骤 2: 带有单个公有子网的 VPC)</strong> 页面上，在 <strong>VPC name (VPC 名称)</strong> 字段中为您的 VPC 输入友好名称。保留其他默认配置设置，然后选择 <strong>Create VPC</strong>。在确认页面上，请选择 <strong>OK</strong>。</li></ol><p>有关 Amazon VPC 的更多信息，请参阅 <em>Amazon VPC 用户指南</em> 中的 <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/" target="_blank" rel="noopener">Amazon VPC 是什么？</a>。</p><h2 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h2><p>安全组用作相关容器实例的防火墙，可在容器实例级别控制入站和出站流量。您可以向安全组添加规则，以便使用 SSH 从您的 IP 地址连接到容器实例。您还可以添加允许来自任意位置的入站和出站 HTTP 和 HTTPS 访问的规则。向任务所需的开放端口添加任意规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。</p><p>注意</p><p>Amazon ECS 控制台首次运行时会为您的实例创建安全组并根据您使用的任务定义创建负载均衡器，因此，如果要使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您计划在多个区域中启动容器实例，则需要在每个区域中创建安全组。有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p>提示</p><p>您需要本地计算机的公有 IP 地址，可以使用服务获得该地址。例如，我们提供以下服务：<a href="http://checkip./" target="_blank" rel="noopener">http://checkip.amazonaws.com/</a> 或 <a href="https://checkip./" target="_blank" rel="noopener">https://checkip.amazonaws.com/</a>。要查找另一项可提供您的 IP 地址的服务，请使用搜索短语“what is my IP address”。 如果您通过 Internet 服务提供商 (ISP) 连接或者在不使用静态 IP 地址的情况下从防火墙后面连接，则必须找出客户端计算机使用的 IP 地址范围。</p><p><strong>为您的 VPC 创建具有最小特权的</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中选择安全组的区域。安全组特定于某一区域，因此您应选择已创建密钥对的区域。</p></li><li><p>在导航窗格中，选择 <strong>Security Groups</strong>，然后选择 <strong>Create Security Group</strong>。</p></li><li><p>输入新安全组的名称和描述。选择一个您容易记住的名称，例如 <em>ecs-instances-default-cluster</em>。</p></li><li><p>在 <strong>VPC</strong> 列表中，确保选择了您的默认 VPC。它标有星号 (*)。</p><p>注意</p><p>如果您的账户支持 Amazon EC2 Classic，请选择您在上一个任务中创建的 VPC。</p></li><li><p>Amazon ECS 容器实例不需要打开任何入站端口。但您可能需要添加 SSH 规则，以便登录容器实例并使用 Docker 命令检查任务。如果您希望容器实例托管运行 Web 服务器的任务，也可以添加适用于 HTTP 和 HTTPS 的规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。完成以下步骤可添加这些可选的安全组规则。</p><p>在 <strong>Inbound</strong> 选项卡上，创建以下规则 (为每个新规则选择 <strong>Add Rule</strong>)，然后选择 <strong>Create</strong>：</p><ul><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTP</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTPS</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>SSH</strong>。在 <strong>Source</strong> 字段中，确保选中 <strong>Custom IP</strong>，然后采用 CIDR 表示法指定您计算机或网络的公有 IP 地址。要采用 CIDR 表示法指定单个 IP 地址，请添加路由前缀 <code>/32</code>。例如，如果您的 IP 地址是 <code>203.0.113.25</code>，请指定 <code>203.0.113.25/32</code>。如果您的公司要分配同一范围内的地址，请指定整个范围，例如 <code>203.0.113.0/24</code>。</p><p>重要</p><p>出于安全原因，我们不建议您允许从所有 IP 地址 (<code>0.0.0.0/0</code>) 对您的实例进行 SSH 访问（以测试为目的的短暂访问除外）。</p></li></ul></li></ol><h2 id="安装-AWS-CLI"><a href="#安装-AWS-CLI" class="headerlink" title="安装 AWS CLI"></a>安装 AWS CLI</h2><p>可以在 AWS 管理控制台中手动管理 Amazon ECS 的所有操作。但是，您可以在本地桌面上安装 AWS CLI 或开发人员工具包并生成脚本，以便在 Amazon ECS 中自动执行常见管理任务。</p><p>要对 Amazon ECS 使用 AWS CLI，请安装最新版本的 AWS CLI。有关安装 AWS CLI 或升级到最新版本的信息，请参阅 <em>AWS Command Line Interface 用户指南</em> 中的<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" target="_blank" rel="noopener">安装 AWS 命令行界面</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon E
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="ECS" scheme="http://blog.ozairs.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Splunk入门手册</title>
    <link href="http://blog.ozairs.com/Big-Data/Splunk%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://blog.ozairs.com/Big-Data/Splunk入门手册/</id>
    <published>2019-03-22T04:07:41.000Z</published>
    <updated>2019-03-22T04:20:08.795Z</updated>
    
    <content type="html"><![CDATA[<p>一、关于搜索不同时间段的记录</p><p>*earliest=-24h@h latest=-12h@h</p><p>二、关于搜索不同目录的记录</p><p>*source=”/var/log/ansible.log” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、关于搜索不同时间段的记录&lt;/p&gt;
&lt;p&gt;*earliest=-24h@h latest=-12h@h&lt;/p&gt;
&lt;p&gt;二、关于搜索不同目录的记录&lt;/p&gt;
&lt;p&gt;*source=”/var/log/ansible.log” &lt;/p&gt;

      
    
    </summary>
    
      <category term="Big Data" scheme="http://blog.ozairs.com/categories/Big-Data/"/>
    
    
      <category term="Splunk" scheme="http://blog.ozairs.com/tags/Splunk/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes实战应用</title>
    <link href="http://blog.ozairs.com/Kubernetes/Kubernetes%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Kubernetes/Kubernetes实战应用/</id>
    <published>2019-03-20T22:35:07.000Z</published>
    <updated>2019-03-22T02:45:54.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、平台构建"><a href="#一、平台构建" class="headerlink" title="一、平台构建"></a>一、平台构建</h3><p>1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Service Mesh</p><p><a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md</a></p><h3 id="二、集群部署命令"><a href="#二、集群部署命令" class="headerlink" title="二、集群部署命令"></a>二、集群部署命令</h3><ol><li><p>运营应用：kubectl run helloworld –image=karthequian/helloworld –port=80</p></li><li><p>查看部署，资源，pods</p><p>kubectl get deployments</p><p>kubectl get rs</p><p>kuebectl get pods</p></li><li><p>部署服务</p><p>kubectl expose deployment helloworld –type=NodePort</p></li><li><p>通过文件方式部署服务和Deployment</p><p>kubectl create -f deploy-all.yml</p></li><li><p>查看服务</p><p>kubectl get services</p></li><li><p>扩展集群服务器</p><p>kubectl scale –replicas=3 deploy/helloworld</p></li><li><p>启动应用</p><p>minikube service helloworld</p></li><li><p>查看所有部署服务</p><p>minikube get all</p></li><li><p>将部署服务导出到YAML文件</p><p>kubectl get deploy/helloworld -o yaml</p></li><li><p>查看服务器集群状态： kubectl cluster-info</p></li><li><p>定位故障</p><p>kubectl describe deploy/depolyname</p><p>kubectl describe po/podname</p><p>kubectl log podname</p><p>登陆到服务节点：kubectl exec -it podname /bin/bash</p><p>如果单节点存在多个Container，登陆到某个服务节点：<code>kubectl exec -it -c containername podname /bin/bash</code></p><p>查看所有服务进程：<code>ps -ef</code></p></li></ol><h3 id="三、图形化管理工具"><a href="#三、图形化管理工具" class="headerlink" title="三、图形化管理工具"></a>三、图形化管理工具</h3><ol><li><p>查看minikube 插件</p><p><code>minikube addons list</code></p><p><code>minikube addon enable heapester</code></p></li></ol><h3 id="四、如何配置数据"><a href="#四、如何配置数据" class="headerlink" title="四、如何配置数据"></a>四、如何配置数据</h3><ol><li><p>To create a configmap for this literal type <code>kubectl create configmap logger --from-literal=log_level=debug</code></p></li><li><p>To see all your configmaps: <code>kubectl get configmaps</code></p></li><li><p>To read the value in the logger configmap: <code>kubectl get configmap/logger -o yaml</code></p></li><li><p>To edit the value, we can run <code>kubectl edit configmap/logger</code></p></li></ol><p>`</p><h3 id="五、如何配置应用密钥"><a href="#五、如何配置应用密钥" class="headerlink" title="五、如何配置应用密钥"></a>五、如何配置应用密钥</h3><ol><li><p>To create a secret: <code>kubectl create secret generic apikey --from-literal=api_key=123456789</code></p></li><li><p>Notice that we can’t read the value of the secret directly:<br><code>kubectl get secret apikey -o yaml</code></p></li><li><p>Understand how to add a secret to a deployment</p><p>​         Adding a secret to a deployment is similar to what we did for configmaps. You can add a secret to the env portion, and start up the deployment with:<br><code>kubectl create -f secretreader-deployment.yaml</code></p></li></ol><h3 id="六、如何创建任务"><a href="#六、如何创建任务" class="headerlink" title="六、如何创建任务"></a>六、如何创建任务</h3><h3 id="How-to-run-jobs"><a href="#How-to-run-jobs" class="headerlink" title="How to run jobs"></a>How to run jobs</h3><p>Jobs are a construct that run a pod once, and then stop. However, unlike pods in deployments, the output of the job is kept around until you decide to remove it.</p><p>Running a job is similar to running a deployment, and we can create this by <code>kubectl create -f simplejob.yaml</code></p><p>To see the output of the job: <code>kubectl get jobs</code></p><p>You can find the pod that ran by doing a <code>kubectl get pods --all-pods</code>, and then get the logs from it as well.</p><h3 id="How-to-run-cron-jobs"><a href="#How-to-run-cron-jobs" class="headerlink" title="How to run cron jobs"></a>How to run cron jobs</h3><p>Cron jobs are like jobs, but they run periodically.</p><p>Start your cron by running <code>kubectl create -f cronjob.yaml</code></p><p>We can use the cronjob api to view your cronjobs: <code>kubectl get cronjobs</code>. It adds the last schedule date</p><h3 id="七、如何创建DaemonSet"><a href="#七、如何创建DaemonSet" class="headerlink" title="七、如何创建DaemonSet"></a>七、如何创建DaemonSet</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、平台构建&quot;&gt;&lt;a href=&quot;#一、平台构建&quot; class=&quot;headerlink&quot; title=&quot;一、平台构建&quot;&gt;&lt;/a&gt;一、平台构建&lt;/h3&gt;&lt;p&gt;1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Serv
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Istio - Kubernetes和云原生系统的服务网格</title>
    <link href="http://blog.ozairs.com/Kubernetes/Istio-Kubernetes%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>http://blog.ozairs.com/Kubernetes/Istio-Kubernetes和云原生系统的服务网格/</id>
    <published>2019-03-20T21:17:38.000Z</published>
    <updated>2019-03-20T21:19:23.004Z</updated>
    
    <content type="html"><![CDATA[<p>微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改进授权和安全性，管理路由，收集指标等的能力。点击上面的视频观看剧集并获取所有详细信息。</p><iframe width="987" height="555" src="https://www.youtube.com/embed/rL_p8KIUgwE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong>编辑成绩单</strong><br><em>对于那些喜欢阅读的人，我们已经通过我们的编辑运行成绩单，以获得更顺畅的阅读体验。</em></p><p>如果您在过去几年中一直在微服务领域工作，那么服务网格的概念对您来说可能并不陌生。对于我们其他人来说，它有点诞生于微服务空间带来的一些需求，特别是对可见性，流量路由，身份验证，安全性和指标收集的一些需求。问题源于这样一个事实，即在云空间内，特别是微服务空间，当我们将服务转移到容器中时，这是一种非常常见的模型，我们失去了一些我们能够用来获得经典可见性的仪器单片应用。</p><p>例如，在单一应用程序中，应用程序内的内部服务将通过内部消息传递进行通信，并且这些消息通信范例通常通过应用程序本身内的交互来管理。您基本上可以监视在不同资源之间传递的消息的内存空间。当我们突然去微服务时，不再容易完成。当我们去容器时，我们突然失去了将一些额外服务添加到我们的基础虚拟机中以收集该信息的能力。</p><p>嗯，这就是服务网格概念发挥作用的地方。让我们在所有微服务之间放置一些东西，然后捕获它们之间的所有流量。这会产生一些问题。特别是在分布式系统中，我突然想知道如何管理实际监控和计量我的服务的所有那些交互式小组件。</p><p>随之而来的是Kubernetes，突然之间游戏发生了巨大的变化。并不是我们无法实现这些服务功能，而是现在我们可以直接在各个服务容器本身旁边注入该功能。这通过一种称为服务注入的技术或有效地将另一个容器添加到我们的环境中来完成 然后最重要的是，由于我们通常关注网络流量，我们再次谈到微服务是这种通信的主要模型，我们实际上可以开始在pod中绑定服务，我们实际上是重定向本地流量现在。</p><p>通过这样做，我们解决了微服务所带来的一些问题。特别是监视资源之间通信的能力。这是Google实际带入Istio领域的事情之一，能够有效地捕获这些数据，有效地扩展了容器引擎（cAdvisor引擎）的概念，用于人们在应用程序空间中使用的容器运行时。基本上，然后能够查看应用程序数据流，然后集中该度量数据并可能监视通信。</p><p>一旦我完成了这一切 - 一旦我在那个级别注入了自己 - 我正在看着来回流动的数据包我可以做一些非常有趣的事情。我可以添加身份验证，因此这是IBM为这一组合做出的贡献之一。在路由之上是能够对这些不同服务之间的连接进行排序。路由是我可以控制的另一件事; 任何帧被发送而不是只是说好我将永远转发到负载均衡器，它将分配给n个资源，负载均衡器成为我沟通的一部分。现在我可以确定我实际上要将这些帧发送到哪个目标非常强大。</p><p>由于我有这种控制水平，我甚至可以做一些有趣的事情，比如注入错误。因此，当我开始将我的应用程序分发给这些微服务时，如果出现问题，我很难弄清楚我的应用程序将如何表现。我如何在任何一个特定的微服务中实际强制失败，以检查我的应用程序在遇到这种故障时如何保持弹性？好吧，我现在可以开始注入它作为我的QA或开发过程的一部分，甚至包括生产级别的注入。我可以继续创建故障以确保我的系统继续正常运行，如果不是，我实际上可以提醒它。</p><p>所以这些是微服务网格的一些交互 - 服务网格 - 空间实际提供，而Istio通过可注入代理提供这一点。基本上，我将采用代理引擎，在这种情况下，Istio空间正在使用Envoy代理。Envoy最初由Lyft开发，现在是CNCF的一个开源项目。实际上，Isto也是CNCF的一部分，对于那些没有听说过的人来说，它是Cloud Native Computing Foundation，它是Linux Foundation空间中的一个子基础。</p><p>所以这个服务功能真的是Istio提供的。Istio提供此Envoy代理功能，可以在Kubernetes空间中注入每个容器，或者如果要使用非Kubernetes模型，则将其插入转发路径。使用像Docker这样的容器甚至是虚拟机; 您实际上可以将此代理添加为虚拟机中的进程，并通过该方式注入流量。所以我们可以使用微服务…我们也可以使用大型服务，单片服务，我们可以使用这个服务网格将它们连接在一起。</p><p>但是有了Istio，我们就会获得身份验证，所以因为所有流量都通过这些Envoy代理，我实际上可以验证和结束通信。我可以监控和计量流量，以了解延迟发生的情况; 看看我在路径基础上获得了什么样的吞吐量。我可以将它发送到中央跟踪服务开放跟踪，例如，Jaeger项目是在那里使用的相当常见的项目之一。我也可以像我说的那样开始研究路由。我可以重定向流量并在Kubernetes空间内，例如，我可以使用标签来实际定义我的端点在哪里以及应该在哪里提供服务。</p><p>这一切都非常强大，但现在我也有中央控制权。这是这个Istio带来的最后一件事 - 中央证书控制。这对TLS身份验证很重要。使用名为Mixer的工具收集中心指标，实际上将所有指标数据收集在一起，然后集中配置控制，这实际上是为什么Envoy被选为代理。因为使用Envoy，我现在有一个中央控制器，可以将配置分发到该网格内的所有分布式代理。Envoy以非常有效的方式实现这一点，因为它实际上不需要重新配置重启; 它可以进行热重新配置 - 一个非常强大的功能！</p><p>因此，服务网格是微服务空间的重要组成部分。它真正改变了微服务如何拼接在一起，如何对它们进行计量/监控，甚至通过从具有安全性的集中控制平面注入故障来改善这些服务的性能和弹性。所以在这一大捆绑中有很多东西，但那真的是Istio的能力。更一般地说，它是云本机引擎中更大的服务网格空间的一部分，它真正接管了当今应用程序的构建方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Ant简介以及两者的区别</title>
    <link href="http://blog.ozairs.com/DevOps/Maven%E5%92%8CAnt%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ozairs.com/DevOps/Maven和Ant简介以及两者的区别/</id>
    <published>2019-03-20T20:59:39.000Z</published>
    <updated>2019-03-20T21:02:59.763Z</updated>
    
    <content type="html"><![CDATA[<p>一．Maven简介<br>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代工具）不能满足绝大多数开发人员的需要。通过检查 Ant 构建文件，很难发现项目的相关性信息和其它信息（如开发人员/拥有者、版本或站点主页）。<br>Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。<br>Maven这个单词来自于意第绪语，意为知识的积累，最早在Jakata Turbine项目中它开始被用来试图简化构建过程。当时有很多项目，它们的Ant build文件仅有细微的差别，而JAR文件都由CVS来维护。于是Maven创始者开始了Maven这个项目，该项目的清晰定义包括，一种很方便的发布项目信息的方式，以及一种在多个项目中共享JAR的方式.<br>二．Maven常用命令<br>mvn archetype：create 创建Maven项目<br>mvn compile 编译源代码<br>mvn deploy 发布项目<br>mvn test-compile 编译测试源代码<br>mvn test 运行应用程序中的单元测试<br>mvn site 生成项目相关信息的网站<br>mvn clean 清除项目目录中的生成结果<br>mvn package 根据项目生成的jar<br>mvn install 在本地Repository中安装jar<br>mvn eclipse:eclipse 生成eclipse项目文件<br>mvnjetty:run 启动jetty服务<br>mvntomcat:run 启动tomcat服务</p><pre><code>Ant</code></pre><p>Ant简介<br>Ant是一种基于Java的build工具。理论上来说，它有些类似于（Unix）C中的make ，但没有make的缺陷。目前的最新版本为：Ant 1.9.1<br>既然我们已经有了make, gnumake, nmake, jam以及其他的build工具为什么还要要一种新的build工具呢？因为Ant的原作者在多种(硬件)平台上开发软件时，无法忍受这些工具的限制和不便。类似于make的工具本质上是基于shell（语言）的：他们计算依赖关系，然后执行命令（这些命令与你在命令行敲的命令没太大区别）。这就意味着你可以很容易地通过使用OS特有的或编写新的（命令）程序扩展该工具；然而，这也意味着你将自己限制在了特定的OS，或特定的OS类型上，如Unix。<br>Ant就不同了。与基于shell命令的扩展模式不同，Ant用Java的类来扩展。（用户）不必编写shell命令，配置文件是基于XML的，通过调用target树，就可执行各种task。每个task由实现了一个特定Task接口的对象来运行。<br>当一个代码项目大了以后，每次重新编译，打包，测试等都会变得非常复杂而且重复，因此c语言中有make脚本来帮助这些工作的批量完成。在Java 中应用是平台无关性的，当然不会用平台相关的make脚本来完成这些批处理任务了，ANT本身就是这样一个流程脚本引擎，用于自动化调用程序完成项目的编译，打包，测试等。除了基于JAVA是平台无关的外，脚本的格式是基于XML的，比make脚本来说还要好维护一些。<br>每个ant脚本（缺省叫build.xml）中设置了一系列任务(target)：比如对于一个一般的项目可能需要有以下任务。</p><ul><li>任务1：usage 打印本脚本的帮助信息（缺省）</li><li>任务2：clean &lt;– init 清空初始化环境</li><li>任务3：javadoc &lt;– build &lt;– init 生成JAVADOC</li><li>任务4：jar &lt;– build &lt;– init 生成JAR</li><li>任务5：all &lt;– jar + javadoc &lt;– build &lt;– init 完成以上所有任务：jar javadoc<br>注：我看到很多项目的ant脚本中的命名基本上都是一致的，比如：编译一般叫build或者compile；打包一般叫jar或war；生成文档一般命名为 javadoc或javadocs；执行全部任务all。在每个任务的中，ANT会根据配置调用一些外部应用并配以相应参数执行。虽然ANT可调用的外部应用种类非常丰富，但其实最常用的就2，3个：比如javac javadoc jar等。<br>二．Ant的优点<br>Ant是Apache软件基金会JAKARTA目录中的一个子项目，它有以下的优点。<br>跨平台性。Ant是纯Java语言编写的，因此具有很好的跨平台性。<br>操作简单。Ant是由一个内置任务和可选任务组成的。Ant运行时需要一个XML文件(构建文件)。<br>Ant通过调用target树，就可以执行各种task。每个task实现了特定接口对象。由于Ant构建文件时XML格式的文件，所以很容易维护和书写，而且结构很清晰。<br>Ant可以集成到开发环境中。由于Ant的跨平台性和操作简单的特点，它很容易集成到一些开发环境中去。<br>三．Ant 开发<br>Ant的构建文件<br>当开始一个新的项目时，首先应该编写Ant构建文件。构建文件定义了构建过程，并被团队开发中每个人使用。Ant构建文件默认命名为build.xml，也可以取其他的名字。只不过在运行的时候把这个命名当作参数传给Ant。构建文件可以放在任何的位置。一般做法是放在项目顶层目录中，这样可以保持项目的简洁和清晰。下面是一个典型的项目层次结构。<br>(1) src存放文件。<br>(2) class存放编译后的文件。<br>(3) lib存放第三方JAR包。<br>(4) dist存放打包，发布以后的代码。<br>Ant构建文件是XML文件。每个构建文件定义一个唯一的项目(Project元素)。每个项目下可以定义很多目标(target元素)，这些目标之间可以有依赖关系。当执行这类目标时，需要执行他们所依赖的目标。<br>每个目标中可以定义多个任务，目标中还定义了所要执行的任务序列。Ant在构建目标时必须调用所定义的任务。任务定义了Ant实际执行的命令。Ant中的任务可以为3类。<br>（1） 核心任务。核心任务是Ant自带的任务。<br>（2） 可选任务。可选任务实来自第三方的任务，因此需要一个附加的JAR文件。<br>（3） 用户自定义的任务。用户自定义的任务是用户自己开发的任务。<br>1.<project>标签<br>每个构建文件对应一个项目。<project>标签时构建文件的根标签。它可以有多个内在属性，就如代码中所示，其各个属性的含义分别如下。<br>(1) default表示默认的运行目标，这个属性是必须的。<br>(2) basedir表示项目的基准目录。<br>(3) name表示项目名。<br>(4) description表示项目的描述。<br>每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有自己的构建文件。<br>2.<target>标签<br>一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。<br>例如，有一个target用于编译程序，另一个target用于生成可执行文件。在生成可执行文件之前必须先编译该文件，因此可执行文件的target依赖于编译程序的target。Target的所有属性如下。<br>(1).name表示标明，这个属性是必须的。<br>(2).depends表示依赖的目标。<br>(3)if表示仅当属性设置时才执行。<br>(4)unless表示当属性没有设置时才执行。<br>(5)description表示项目的描述。<br>Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行每个target。在执行之前，首先需要执行它所依赖的target。程序中的名为run的target的depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执行的顺序是prepare-&gt;compile-&gt;run。<br>一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总会被执行。<br>3.<mkdir>标签<br>该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：<br><mkdir dir="”${class.root}”/"><br>通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。<br>4<jar>标签<br>该标签用来生成一个JAR文件，其属性如下。<br>(1) destfile表示JAR文件名。<br>(2) basedir表示被归档的文件名。<br>(3) includes表示被归档的文件模式。<br>(4) exchudes表示被排除的文件模式。<br>5．&lt;javac标签&gt;<br>该标签用于编译一个或一组java文件，其属性如下。<br>(1).srcdir表示源程序的目录。<br>(2).destdir表示class文件的输出目录。<br>(3).include表示被编译的文件的模式。<br>(4).excludes表示被排除的文件的模式。<br>(5).classpath表示所使用的类路径。<br>(6).debug表示包含的调试信息。<br>(7).optimize表示是否使用优化。<br>(8).verbose 表示提供详细的输出信息。<br>(9).fileonerror表示当碰到错误就自动停止。<br>6．<java>标签<br>该标签用来执行编译生成的.class文件，其属性如下。<br>(1).classname 表示将执行的类名。<br>(2).jar表示包含该类的JAR文件名。<br>(3).classpath所表示用到的类路径。<br>(4).fork表示在一个新的虚拟机中运行该类。<br>(5).failonerror表示当出现错误时自动停止。<br>(6).output 表示输出文件。<br>(7).append表示追加或者覆盖默认文件。<br>7.<delete>标签<br>该标签用于删除一个文件或一组文件，其属性如下。<br>(1)/file表示要删除的文件。<br>(2).dir表示要删除的目录。<br>(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。<br>(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。<br>(5).verbose表示指定是否列出所删除的文件，默认值为不列出。<br>8.<copy>标签<br>该标签用于文件或文件集的拷贝，其属性如下。<br>(1).file 表示源文件。<br>(2).tofile 表示目标文件。<br>(3).todir 表示目标目录。<br>(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。<br>(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。<br>(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。<br>(7).verbose 表示制定是否显示详细信息，默认值不显示。<br>四．Ant的数据类型<br>在构建文件中为了标识文件或文件组，经常需要使用数据类型。数据类型包含在org.apache.tool.ant.types包中。下面镜简单介绍构建文件中一些常用的数据类型。</copy></delete></java></jar></mkdir></mkdir></target></project></project></li></ul><ol><li><p>argument 类型<br>由Ant构建文件调用的程序，可以通过<arg>元素向其传递命令行参数，如apply,exec和java任<br>务均可接受嵌套<arg>元素，可以为各自的过程调用指定参数。以下是<arg>的所有属性。<br>(1).values 是一个命令参数。如果参数中有空格，但又想将它作为单独一个值，则使用此属性。<br>(2).file表示一个参数的文件名。在构建文件中，此文件名相对于当前的工作目录。<br>(3).line表示用空格分隔的多个参数列表。<br>(4).path表示路径。<br>2.ervironment 类型<br>由Ant构建文件调用的外部命令或程序，<env>元素制定了哪些环境变量要传递给正在执行的系统命令，<env>元素可以接受以下属性。<br>(1).file表示环境变量值的文件名。此文件名要被转换位一个绝对路径。<br>(2).path表示环境变量的路径。Ant会将它转换为一个本地约定。<br>(3).value 表示环境变量的一个直接变量。<br>(4).key 表示环境变量名。<br>注意 file path 或 value只能取一个。<br>3.filelist类型<br>Filelist 是一个支持命名的文件列表的数据类型，包含在一个filelist类型中的文件不一定是存在的文件。以下是其所有的属性。<br>(1).dir是用于计算绝对文件名的目录。<br>(2).files 是用逗号分隔的文件名列表。<br>(3).refid 是对某处定义的一个<filelist>的引用。<br>注意 dir 和 files 都是必要的，除非指定了refid(这种情况下，dir和files都不允许使用)。<br>4.fileset类型<br>Fileset 数据类型定义了一组文件，并通常表示为<fileset>元素。不过，许多ant任务构建成了隐式的fileset,这说明他们支持所有的fileset属性和嵌套元素。以下为fileset 的属性列表。<br>(1).dir表示fileset 的基目录。<br>(2).casesensitive的值如果为false，那么匹配文件名时，fileset不是区分大小写的，其默认值为true.<br>(3).defaultexcludes 用来确定是否使用默认的排除模式，默认为true。<br>(4).excludes 是用逗号分隔的需要派出的文件模式列表。<br>(5).excludesfile 表示每行包含一个排除模式的文件的文件名。<br>(6).includes 是用逗号分隔的，需要包含的文件模式列表。<br>(7).includesfile 表示每行包括一个包含模式的文件名。<br>5.patternset 类型<br>Fileset 是对文件的分组，而patternset是对模式的分组，他们是紧密相关的概念。<patternset>支持4个属性：includes excludex includexfile 和 excludesfile,与fileset相同。Patternset 还允许以下嵌套元素：include,exclude,includefile 和 excludesfile.<br>6.filterset 类型<br>Filterset定义了一组过滤器，这些过滤器将在文件移动或复制时完成文件的文本替换。<br>主要属性如下：<br>(1).begintoken 表示嵌套过滤器所搜索的记号，这是标识其开始的字符串。<br>(2).endtoken表示嵌套过滤器所搜索的记号这是标识其结束的字符串。<br>(3).id是过滤器的唯一标志符。<br>(4).refid是对构建文件中某处定义一个过滤器的引用。<br>7.Path类型<br>Path元素用来表示一个类路径，不过它还可以用于表示其他的路径。在用作几个属性时，路经中的各项用分号或冒号隔开。在构建的时候，此分隔符将代替当前平台中所有的路径分隔符，其拥有的属性如下。<br>(1).location 表示一个文件或目录。Ant在内部将此扩展为一个绝对路径。<br>(2).refid 是对当前构建文件中某处定义的一个path的引用。<br>(3).path表示一个文件或路径名列表。<br>8.mapper类型<br>Mapper类型定义了一组输入文件和一组输出文件间的关系，其属性如下。<br>(1).classname 表示实现mapper类的类名。当内置mapper不满足要求时，用于创建定制mapper.<br>(2).classpath表示查找一个定制mapper时所用的类型路径。<br>(3).classpathref是对某处定义的一个类路径的引用。<br>(4).from属性的含义取决于所用的mapper.<br>(5).to属性的含义取决于所用的mapper.<br>(6).type属性的取值为identity，flatten glob merge regexp 其中之一，它定义了要是用的内置mapper的类型。<br>五．Ant的安装<br>解包后在系统可执行路径中加入指向ant的bin的路径就可以了，比如可以在GNU/Linux上把以下配置加入/etc/profile中：<br>export ANT_HOME=/home/ant<br>export JAVA_HOME=/usr/java/j2sdk1.4.1<br>export PATH=$PATH:$JAVA_HOME/bin:$ANT_HOME/bin<br>Windows 下的安装：<br>下载后解压到某个目录我这里以D:\apache-ant-1.7.1为例子：<br>添加path全局环境变量:D:\apache-ant-1.7.1\bin<br>这样在command line就可以运行ant命令了<br>测试：运行-&gt;cmd/command-&gt;ant 如果没有安装成功则回报找不到这个命令，安装成功会有相关的提示信息显示。<br>这样执行ant 后，如果不指定配置文件ant会缺省找build.xml这个配置文件，并根据配置文件执行任务，缺省的任务设置可以指向最常用的任务，比如： build，或指向打印帮助信息：usage，告诉用户有那些脚本选项可以使用。<br>六．Ant的运行<br>安装好Ant并且配置好路径之后，在命令行中切换到构建文件的目录，输入Ant命令就可以运行Ant.若没有指定任何参数，Ant会在当前目录下查询build.xml文件。如果找到了就用该文件作为构建文件。如果使用了 –find 选项，Ant 就会在上级目录中找构建文件，直至到达文件系统的根目录。如果构建文件的名字不是build.xml ，则Ant运行的时候就可以使用 –buildfile file,这里file 指定了要使用的构建文件的名称，示例如下：<br>Ant如下说明了表示当前目录的构建文件为build.xml 运行 ant 执行默认的目标。<br>Ant –buildfile test.xml<br>使用当前目录下的test.xml 文件运行Ant ,执行默认的目标</patternset></fileset></filelist></env></env></arg></arg></arg></p><pre><code>Moven与Ant的区别</code></pre><p>Maven 和 Ant 针对构建问题的两个不同方面。Ant 为 Java 技术开发项目提供跨平台构建任务。Maven 本身描述项目的高级方面，它从 Ant 借用了绝大多数构建任务。因此，由于 Maven 和 Ant 代表两个差异很大的工具，所以接下来只说明这两个工具的等同组件之间的区别。</p></li></ol><p>Maven Ant<br>标准构建文件 project.xml 和 maven.xml build.xml<br>特性处理顺序 ${maven.home}/bin/driver.properties<br>${project.home}/project.properties<br>${project.home}/build.properties<br>${user.home}/build.properties<br>通过 -D 命令行选项定义的系统特性<br>最后一个定义起决定作用。 通过 -D 命令行选项定义的系统特性<br>由 <property> 任务装入的特性<br>第一个定义最先被处理。<br>构建规则 构建规则更为动态（类似于编程语言）；它们是基于 Jelly 的可执行 XML。 构建规则或多或少是静态的，除非使用 <script> 任务。（请参阅 参考资料以获得相关教程。）<br>扩展语言 插件是用 Jelly（XML）编写的。 插件是用 Java 语言编写的。<br>构建规则可扩展性 通过定义 <preGoal> 和 <postGoal> 使构建 goal 可扩展。 构建规则不易扩展；可通过使用 <script> 任务模拟 <preGoal> 和 <postGoal> 所起的作用。<br>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。</p></script></property></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一．Maven简介&lt;br&gt;Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。&lt;br&gt;目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Maven" scheme="http://blog.ozairs.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation经验贴汇总</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation经验贴汇总/</id>
    <published>2019-03-19T12:30:11.000Z</published>
    <updated>2019-03-19T13:02:08.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CloudFormation两年：经验教训"><a href="#1-CloudFormation两年：经验教训" class="headerlink" title="1. CloudFormation两年：经验教训"></a>1. CloudFormation两年：经验教训</h2><p><a href="https://www.colabug.com/4023693.html" target="_blank" rel="noopener">https://www.colabug.com/4023693.html</a></p><h1 id="2-您的基础架构代码CloudFormation与Terraform？"><a href="#2-您的基础架构代码CloudFormation与Terraform？" class="headerlink" title="2.您的基础架构代码CloudFormation与Terraform？"></a>2.您的基础架构代码CloudFormation与Terraform？</h1><p><a href="https://www.colabug.com/3313548.html" target="_blank" rel="noopener">https://www.colabug.com/3313548.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CloudFormation两年：经验教训&quot;&gt;&lt;a href=&quot;#1-CloudFormation两年：经验教训&quot; class=&quot;headerlink&quot; title=&quot;1. CloudFormation两年：经验教训&quot;&gt;&lt;/a&gt;1. CloudFormatio
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>使用Cloud Formation为AWS上的私有实例设置绝对可靠的Bastion节点</title>
    <link href="http://blog.ozairs.com/AWS/%E4%BD%BF%E7%94%A8Cloud-Formation%E4%B8%BAAWS%E4%B8%8A%E7%9A%84%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E7%BB%9D%E5%AF%B9%E5%8F%AF%E9%9D%A0%E7%9A%84Bastion%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.ozairs.com/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/</id>
    <published>2019-03-19T10:43:25.000Z</published>
    <updated>2019-03-19T10:47:22.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg" alt=""></p><p>在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是在实例的安全组的入站规则中简单地允许端口22上的SSH流量，然后通过弹性IP和Internet网关将实例暴露给公共Internet。然而，由于攻击者可能很容易访问您的安全密钥对，并且如果这样的密钥对也可用于其他私有实例，则这会变得有缺陷，那么此类攻击者可以完全访问和控制您的基础结构。</p><p>为了避免这种情况，公司现在使用遍布所有可用区域（AZ）的堡垒实例，其中已经设置了基础架构。Bastion节点是一个专门的实例，故意暴露在互联网上，其设计和配置仅限于遭受攻击的唯一原因。看到堡垒节点暴露在非军事区（DMZ）的公共互联网中，面临潜在攻击的大量风险，因此有必要确保堡垒节点完全万无一失。本文提供了如何设置可靠的堡垒节点的实用见解。使用CloudFormation是因为它通过简单地调整云形成模板中的一些参数，简化了为每个AZ设置堡垒实例的整个瓶颈。</p><p><strong>先修知识：</strong></p><ol><li>基本了解以下Amazon Web服务/概念：EC2，VPC，子网，NAT，安全组和访问控制列表（ACL）</li><li>对云形成的基本认识。</li></ol><p>我们将在10.6.0.0/16 VPC中考虑在10.6.0.0/24子网上具有私有实例的假设网络。此外，我们的堡垒实例应存在于10.5.0.0/24子网中的10.5.0.0/16 VPC中，如下图所示：</p><p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/2.png" alt="img"></p><p>从上图可以看出，NAT网关也已添加到架构中。这为我们的私有实例提供了额外的安全层，只要他们需要访问公共互联网进行软件更新。NAT网关允许来自私有实例的所有出站流量，但阻止从Internet到私有实例的所有始发流量。使用NAT网关，因为我们只想允许来自堡垒节点的SSH流量并阻止来自互联网的所有其他流量。出于简化/清晰的目的，有意地从上面的图中省略了每个实例的安全组信息，但是应该在云形成模板中进行研究。该图还包含10.6.0的访问控制列表（ACL）信息。<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html" target="_blank" rel="noopener">有状态的</a>。我们将在以下部分中探索Bastion节点，私有实例和NAT网关的配置细节：</p><p><strong>堡垒节点</strong></p><p>它存在于自己的VPC中，该VPC暴露于Internet网关并使用VPC对等连接与VPC2（我们的私有实例的VPC）进行通信。互联网网关已与VPC相关联，并且已将弹性IP（EIP）分配给堡垒节点以允许来自互联网的流量。</p><p>路由表清楚地表明，除了10.5.0.0/16和10.6.0.0/16网络之外，所有来自堡垒节点的出站流量都应通过互联网网关转发。发往10.6.0.0/16的流量应使用VPC对等连接作为网关，这样，SSH流量就可以到达我们的私有实例。</p><p>对于安全组，我们只允许来自/到公共互联网的所有SSH流量并阻止所有其他流量。以下是使用云形成实现这一目标的方法：</p><p><strong>私有集群中的实例</strong></p><p>我们决定将我们的假设私有集群放在10.6.0.0/24子网上。路由表描述了发往10.5.0.0/16网络的所有流量都应使用对等连接作为网关。特定于Internet的出站流量使用NAT实例作为网关。</p><p>对于安全组，我们仅允许来自10.5.0.0/24子网的SSH流量和来自Internet上的Internet（0.0.0.0/0）的HTTP / HTTPS流量，并拒绝所有其他协议。</p><p>要添加额外的安全层，我们使用ACL，仅允许SSH，HTTP和HTTPS流量，如上图所示，同时显示入口和出口。由于NAT网关请求此端口以便与私有实例通信，因此端口1024-65535已保持打开以进行<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html#VPC_ACLs_Ephemeral_Ports" target="_blank" rel="noopener">短暂</a>连接。下面使用此云形成模板显示：</p><p><strong>NAT网关</strong></p><p>NAT网关也已放置在自己的10.6.1.0/24子网中。路由表描述了互联网的所有出站流量应使用Internet网关正确分段网络，因为NAT不需要访问对等连接。</p><p>NAT网关的安全组仅允许来自Internet的HTTP和HTTPs流量。以下是云形成如何实现：</p><p>现在我们有了堡垒架构的完整设置。还剩下最后一件事就是<a href="https://brainsik.net/2011/ssh-agent-forwarding/" target="_blank" rel="noopener">SSH Agent Forwarding</a></p><p><strong>SSH代理转发</strong></p><p>为什么需要这个？我们可以简单地进入堡垒，然后跳转到我们的任何私有实例中。为什么这是真的，这是一个巨大的安全风险。有权访问堡垒主机的任何人都可以访问其他所有用户的私钥，并可以模拟该用户。因此，凭证不应存储在堡垒主机上，而应通过<em>SSH代理</em>转发从本地计算机转发到堡垒<em>。</em></p><p><code>-A</code>使用SSH命令添加一段时间应该将您的本地凭据转发到下一台机器上，但是，我们将通过<strong>〜/ .ssh / config</strong>文件进行此配置以简化我们的生活并避免尝试在每次ssh尝试时转发代理。</p><p>将以下行添加到ssh配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host bastion</span><br><span class="line">  HostName       [Bastion Public Ip address]</span><br><span class="line">  User           ec2-user #For example</span><br><span class="line">  IdentityFile   [Path to Identity file]</span><br><span class="line">  ForwardAgent    Yes</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果该文件不存在，您可以直接触摸该文件<code>touch ~/.ssh/config</code></p><p>现在，我们可以简单地说<code>ssh bastion</code>，我们可以进入我们的堡垒实例，我们可以从中跳转到所有其他实例。</p><p>为了进一步简化，我们可以将以下行添加到文件<code>~/.bashrc</code>或<code>~/.zshrc</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ssh-instance（）&#123; </span><br><span class="line">  BASTION_USER =＃你的堡垒用户名</span><br><span class="line">  BASTION_IP =＃你的堡垒IP </span><br><span class="line">  SSH_OPTIONS =“ProxyCommand ssh -q -A -W％h：％p $ BASTION_USER @ $ BASTION_IP” </span><br><span class="line">  ssh $ 1 @ $ 2 -o $ SSH_OPTIONS </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件，通过它来源<code>source ~/.bashrc</code>，现在你可以简单地说<code>ssh-instance ec2-user [my instance ip]</code>，瞧，你直接进入你的私人实例，而不必首先通过堡垒。</p><p><strong>其他提示</strong></p><p>建议对堡垒节点和私有实例使用不同的ssh密钥，并经常轮换这些密钥以减少攻击者获取访问权限的可能性。</p><p>此外，专用的SysAdmin或DevOps工程师还可以在每个堡垒节点中设置用户组，并创建分配给具有各种管理权限的这些不同用户组的用户。应将每个用户的公共ssh密钥复制到<code>~/.ssh/authorized_keys</code>文件中。</p><p><strong>结论</strong></p><p>本文探讨了如何在AWS上为我们的私有实例设置一个万无一失的堡垒节点，而不会在需要系统/软件更新时损害这些实例的Internet可访问性。</p><p>本文的云形成模板可以在这里找到：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">https</a>：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">//github.com/nwochaadim/BastionNode-with-CloudFormation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>玩转Jenkins Pipeline</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%8E%A9%E8%BD%ACJenkins-Pipeline/"/>
    <id>http://blog.ozairs.com/Jenkins/玩转Jenkins-Pipeline/</id>
    <published>2019-03-18T08:47:54.000Z</published>
    <updated>2019-03-18T08:51:11.320Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins Pipeline的总体介绍<br>1.Jenkins Pipeline 的核心概念</p><p>Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。</p><p>Pipeline是Jenkins2.X的最核心的特性，帮助Jenkins实现从CI到CD与DevOps的转变</p><p>Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。</p><p>持续交付管道（CD Pipeline）是将软件从版本控制阶段到交付给用户或客户的完整过程的自动化表现。软件的每一次更改（提交到源代码管理系统）都要经过一个复杂的过程才能被发布。</p><p>Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language（DSL）syntax可以达到Pipeline as Code（Jenkinsfile存储在项目的源代码库）的目的。</p><p>Stage：阶段，一个Pipeline可以划分成若干个Stage，每个Stage代表一组操作，例如：“Build”，“Test”，“Deploy”。</p><p>注意，Stage是一个逻辑分组的概念，可以跨多个Node</p><p>Node：节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行环境。</p><p>Step：步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenklins Plugin提供，例如：sh ‘make’</p><p>Pipeline五大特性</p><p>1、代码:Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑、审查和迭代其CD流程。<br>2、可持续性：Jenklins重启或者中断后都不会影响Pipeline Job。<br>3、停顿：Pipeline可以选择停止并等待任工输入或批准，然后再继续Pipeline运行。<br>4、多功能：Pipeline支持现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力<br>5、可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。</p><p>Pipeline和Freestyle的区别</p><p>Freestyle：<br>上游/下游Job调度，如<br>BuildJob —&gt; TestJob —&gt; DeployJob<br>在DSL Job里面调度多个子Job（利用Build Flow Plugin）</p><p>Pipeline：<br>单个Job中完成所有的任务编排<br>全局视图</p><p>Multibranch Pipeline根据你的代码中Jenlinsfile自动创建Job</p><p>Jenlins Pipeline的基础语法<br>Pipeline脚本是由Groovy语言实现（无需专门学习）</p><p>支持两种语法<br>Declarative 声明式（在Pipeline plugin 2.5中引入）<br>Scripted Pipeline 脚本式</p><p>如何创建最基本的PIpeline<br>直接在Jenkins Web UI 网页界面中输入脚本<br>通过创建一个jenkinsfile可以检入项目的源代码管理库</p><p>通常推荐在Jenkins中直接从源代码控制（SCM）中载入Jenklinsfile Pipeline</p><p>声明式Pipeline</p><p>声明式Pipeline的基本语法和表达式遵循与Groovy语法相同的规则，但有以下例外：</p><p>声明式pipeline必须包含在固定格式pipeline{}快内<br>每个声明语句必须独立一行，行尾无需使用分号<br>块（blocks{}）只能包含章节（Sections），指令（Directives），步骤（Steps）或赋值语句<br>属性引用语句被视为无参数方法调用。例：输入被视为 input()<br>块（blocks{}）<br>由大括号括起来的语句，如pipeline{},Section{},parameters{},script{}<br>章节（Sections）<br>通常包含一个或多个指令或步骤。如 agent 、post、stages、steps<br>指令（Directives）<br>environment、options、parameters、triggers（触发）、stage、tools、when<br>步骤（Steps）<br>Pipeline steps reference<br>执行脚本式pipeline：使用script{}</p><p>agent<br>必须存在，agent必须在pipeline块内的顶层定义，但stage内是否使用使可选的<br>参数：any/none/label/node/docker/dockerfile<br>常用选项 label/cuetomWorkspace/reuseNode</p><p>示例</p><p>agent { label ‘my-label’ }</p><p>agent {<br>    node {<br>        label ‘my-label’<br>        customWorkspace ‘/some/other/path’<br>    }<br>}</p><p>agent {<br>    docker {<br>        image ‘nginx:1.12.2’<br>        label ‘my-label’<br>        args ‘-v /tmp:/tmp’<br>    }<br>}</p><p>post 不是必须的，用于pipeline的最外层或者stage{}中</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps {<br>            echo ‘Hello world’<br>            }<br>        }<br>    }<br>    post {<br>        always {<br>            echo ‘say goodbay’<br>        }<br>    }<br>}</p><p>stages 必须，包括顺序执行的一个或多个stage命令，在pipeline内仅能使用一次，通常位于agent/options后面，例子如上</p><p>steps 必须，steps位于stage指令块内部，包括一个或多个step。仅有一个step的情况下可以忽略关键字step及其{},例子如上</p><p>environment 不是必须的，environment定义了一组全局的环境变量键值对，存在于pipeline{}或者stage指令内。执行特殊方法credentials()可以获取jenkins中预定义的凭证明文内容</p><p>environment {CC=’clang’}<br>environment {AN_ACCESS_KEY = credentials(‘my-prefined-secret-text’)}<br>steps {sh ‘printenv’}</p><p>options 不是必须的 预定义pipeline专有的配置信息，仅可定义一次</p><p>pipeline {<br>    agent any<br>    options{<br>    timeout(time:1,unit: ‘HOURS’)<br>    }<br>    …<br>}</p><p>parameters 不是必须的 定义参数化构建的参数可选参数 booleanParam,choice,file,text,password,run,string</p><p>paramenters {<br>    choice(name:’PerformMavenRelease’,choices:’False\nTrue’,description:’desc’)<br>    password(name:’CredsToUse’,description:’Apassword to build with’,defaultValue:’’)<br>}<br>environment {<br>    BUILD_USR_CHOICE=”${params.PerformMavenRelease}”<br>    BUILD_USR_CREDS=”${params.CredsToUse}”<br>}</p><p>triggers 不是必须的 定义pipeline被自动触发的方式选项 cron、pollSCM、upstream</p><p>triggers {cron(‘H 4/<em> 0 0 1-5’)}<br>triggers {pollSCM(‘H 4/</em> 0 0 1-5’)}<br>triggers {upstream(upstreamProjects:’job1,job2’,threshold:hudson.model.Result.SUCCESS)}</p><p>快速创建一个pipeline<br>新建 选择pipeline 填写Job 的名字 </p><p>填写相应的pipeline script</p><p>pipeline{<br>    agent any<br>    stages {<br>        stage(‘Build’) {<br>            steps{<br>                echo ‘This is a build step’<br>            }<br>        }<br>        stage(‘Test’) {<br>            steps{<br>                echo ‘This is a test step’<br>            }<br>        }<br>        stage(‘Deploy’) {<br>            steps{<br>                echo ‘This is a deploy step’<br>            }<br>        }<br>    }<br>}<br>1</p><p>保存之后，立即构建</p><p>常用的辅助工具</p><p>Snipper Generator（代码片段生成器，语法检查器）<br>Replay Pipeline（重放pipeline，可以修改script，修改后的不存入config.xml）<br>DSL Reference 语法参考手册<br>全局变量引用<br>Stage View<br>BlueOcean(可视化)<br>Pipeline神器：可视化编辑器<br>命令行Pipeline调试工具<br>变量的传递</p><p>自定义变量（局部）<br>def username = ‘Jenkins’<br>echo “Hello Mr.${username}”</p><p>#注意一定要用双引号，单引号识别为字符串</p><p>环境变量（局部）<br>withEnv([‘MYTOOL_HOME=/usr/local/mytool’]){<br>    sh ‘$MYTOOL_HOME/bin/start’<br>}<br>1<br>2<br>3<br>环境变量（全局）<br>environment {CC=’clang’}<br>echo “Compiler is ${env.CC}”</p><p>参数化构建（全局）<br>parameters {string(name:’Jenkins’,defaultValue:’Hello’,description:’How should I greet the world’)}<br>ehco “${params.Greeting} World!”</p><p>判断<br>when仅用于stage内部<br>when的内置条件为：</p><ul><li>when {branch ‘master’}</li><li>when {environment name:’DEPLOY_TO’,value:’production’}<br>#当有环境变量 name 为 DEPLOY_TO 值是 production 条件成立</li><li>when {expression {return params.DEBUG_BUILD}}<br>#表达式返回值为真时</li><li>when {not {branch ‘master’}}</li><li>when {allOf {branch ‘master’; environment name:’DEBUG_TO’,value:’production’}}<br>#allOf 所有条件都满足时</li><li>when {anyOf {branch ‘master’ ; branch ‘staging’}}<br>#anyOf有一个条件满足时即可</li></ul><p>判断和异常处理<br>流程控制if/else条件</p><p>node {<br>    stage(‘Example’){<br>        if(env.BRANCH_NAME == ‘master’){<br>            echo ‘I only execute on the master branch’<br>        }else {<br>            echo ‘Iexecute elsewhere’<br>        }<br>    }<br>}</p><p>异常处理try/catch/finally</p><p>node{<br>    stage(‘Example’){<br>        try{<br>            sh ‘exit 1’<br>        }<br>        catch (exc) {<br>            echo ‘something failed,I should sound the klaxons!’<br>            throw<br>        }<br>    }<br>}</p><p>for循环仅存在域脚本式pipeline中，但是可以通过在声明式pipeline中调用script step来执行</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps{<br>                echo ‘Hello world!’<br>                script {<br>                    def browsers = [‘chrome’,’firefox’]<br>                    for (int i = 0;i &lt; browers.size();++i){<br>                        echo “Testing the ${browsers[i]} browser”<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</p><p>并发需要放在stages中，stages可以嵌套使用<br>stage下的steps和parallel不能共存，只能二选一<br>使用了并发的stage不能再有agent/tools </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jenkins Pipeline的总体介绍&lt;br&gt;1.Jenkins Pipeline 的核心概念&lt;/p&gt;
&lt;p&gt;Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins+ant 构建非maven项目</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%BD%BF%E7%94%A8jenkins-ant-%E6%9E%84%E5%BB%BA%E9%9D%9Emaven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.ozairs.com/Jenkins/使用jenkins-ant-构建非maven项目/</id>
    <published>2019-03-18T05:06:47.000Z</published>
    <updated>2019-03-18T05:14:51.282Z</updated>
    
    <content type="html"><![CDATA[<p>使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下</p><h2 id="1-安装构建环境"><a href="#1-安装构建环境" class="headerlink" title="1. 安装构建环境"></a>1. 安装构建环境</h2><p>除普通必要的环境外，需要额外安装ANT</p><p>到官方主页<a href="http://ant.apache.org下载新版的ant，" target="_blank" rel="noopener">http://ant.apache.org下载新版的ant，</a></p><p>得到的是一个apache-ant-1.10.1-bin.zip的压缩包。将其解压到你的硬盘上</p><p>接下来配置环境变量即可，配置和java类似</p><p>ANT_HOME   :  D:\MyWorkApps\apache-ant-1.10.1</p><p>CLASSPATH  :  D:\MyWorkApps\apache-ant-1.10.1\lib</p><p>PATH:                D:\MyWorkApps\apache-ant-1.10.1\bin</p><p>注意：配置没有使用%ANT_HOME%bin</p><p> 原因:经测试部分系统path不识别%ANT_HOME%</p><p> 解决方法：换成解压目录路径，如上即可</p><p>测试一下是否安装成功</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/1.png" alt=""></p><p>build failed 即成功，只是没有build.xml而已</p><h2 id="2-jenkins安装ant插件并进行环境配置"><a href="#2-jenkins安装ant插件并进行环境配置" class="headerlink" title="2. jenkins安装ant插件并进行环境配置"></a>2. jenkins安装ant插件并进行环境配置</h2><p>进入系统设置，插件管理，安装ant插件</p><p>我这里已经安装好了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/2.png" alt=""></p><p>然后进入 系统管理 =》 <a href="http://localhost:8091/configureTools" target="_blank" rel="noopener"><strong>Global Tool Configuration</strong></a></p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/3.png" alt=""></p><p>配置<a href="https://www.baidu.com/s?wd=JDK&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">JDK</a>也是必须的，若果使用ANT构建就需配置ANT,使用MAVEN构建即要配置MAVEN</p><p>配置也很简单 如下</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/4.png" alt=""></p><p>Name 可以随意取 ,HOME即为安装目录</p><h2 id="3-进入jenkins构建项目"><a href="#3-进入jenkins构建项目" class="headerlink" title="3. 进入jenkins构建项目"></a>3. 进入jenkins构建项目</h2><p>点击新建</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/5.png" alt=""></p><p>如上填写选择，点击ok</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/6.png" alt=""></p><p>继续，到源码管理，选择svn,输入地址和账号密码</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/7.png" alt=""></p><p>继续</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.png" alt=""></p><p>可以看到这里实用最简单的配置，构建触发器，和构建环境都没有选，</p><p>构建里选择一下我们刚刚安装配置的ANT</p><p>点击保存即可</p><p>\4. build.xml文件配置</p><p>使用ANT进行构建，最主要的就是build.xml文件的编写</p><p>这里只需要修改property的几个属性即可</p><property name="catalina.home" value="D:\MyProject\tomcat-6.0.45"><p>由于我们在构建中指定了ANT，所以下面的这个可以去除掉</p><property name="ant.dir" value="D:\MyWorkApps\apache-ant-1.10.1"><p>project name 这个name即是打包之后的包名，也是我们进入工程的工程名称</p><p>如：<a href="http://localhost:8099/myweb/hello/world.do" target="_blank" rel="noopener">http://localhost:8099/myweb/hello/world.do</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"hellojk"</span> <span class="attr">default</span>=<span class="string">"deploy"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name"</span> <span class="attr">value</span>=<span class="string">"hellojk"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"catalina.home"</span> <span class="attr">value</span>=<span class="string">"D:\Program Files\Apache Software Foundation\Tomcat 8.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/dist"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webRoot.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/WebRoot"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/src"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/config"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lib.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/lib"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用eclipse jdt进行编译，而不使用JDK编译  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter" /&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="D:\MyWorkApps\Java\jdk1.8.0_51" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 初始化classpath --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加tomcat类路径 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/lib"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ant lib包  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;fileset dir="$&#123;ant.dir&#125;"&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;include name="**/*.jar" /&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/fileset&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- get the source compile classpath in a printable form --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pathconvert</span> <span class="attr">pathsep</span>=<span class="string">"$&#123;line.separator&#125;|   |-- "</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">property</span>=<span class="string">"echo.path.compile"</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">refid</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pathconvert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- show classpath jars --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"print_classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|-- compile classpath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |-- $&#123;echo.path.compile&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 删除之前的目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"清理旧文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;.war"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span> <span class="attr">depends</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"创建初始化目录结构"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编译java --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span> <span class="attr">description</span>=<span class="string">"编译java文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src.dir&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">includeantruntime</span>=<span class="string">"false"</span> <span class="attr">nowarn</span>=<span class="string">"on"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">source</span>=<span class="string">"1.8"</span> <span class="attr">target</span>=<span class="string">"1.8"</span> <span class="attr">deprecation</span>=<span class="string">"true"</span> <span class="attr">debug</span>=<span class="string">"true"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">encoding</span>=<span class="string">"UTF-8"</span> <span class="attr">classpathref</span>=<span class="string">"project.classpath"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-Xlint:unchecked"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;classpath refid="project.classpath" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;build.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;src.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;config.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将class文件打成 jar包 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;target name="pack" depends="compile"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;jar jarfile="$&#123;build.dir&#125;/$&#123;webapp.name&#125;.jar"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;fileset dir="$&#123;build.dir&#125;/classes"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &lt;include name="**/*.class"/&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;/fileset&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;/jar&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;/target&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打成war包, 名称默认为 项目名 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"war"</span> <span class="attr">depends</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"将工程打成war包"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">webxml</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/web.xml"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"***.*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">war</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- copy war包 tomcat的deploy目录 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"deploy"</span> <span class="attr">depends</span>=<span class="string">"war"</span> <span class="attr">description</span>=<span class="string">"部署项目"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">todir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如构建出现这样的错误（之前使用别的build.xml构建时错误）</p><p>大多是工程里缺少文件夹，手动创建即可</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.1.png" alt=""></p><p>走了很多弯路，不过最后成功了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/9.png" alt=""></p></blockquote></property></property>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下&lt;/p&gt;
&lt;h2 id=&quot;1-安装构建环境&quot;&gt;&lt;a href=&quot;#1-安装构建环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装构建环境&quot;&gt;&lt;/a&gt;1. 安装构建环境
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>从Docker到Jenkins再到Ansible的部署经验</title>
    <link href="http://blog.ozairs.com/Ansible/%E4%BB%8EDocker%E5%88%B0Jenkins%E5%86%8D%E5%88%B0Ansible%E7%9A%84%E9%83%A8%E7%BD%B2%E7%BB%8F%E9%AA%8C/"/>
    <id>http://blog.ozairs.com/Ansible/从Docker到Jenkins再到Ansible的部署经验/</id>
    <published>2019-03-17T10:53:04.000Z</published>
    <updated>2019-03-17T10:56:53.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Docker-到Jenkins-到Ansible的部署经验"><a href="#从Docker-到Jenkins-到Ansible的部署经验" class="headerlink" title="从Docker 到Jenkins 到Ansible的部署经验"></a>从Docker 到Jenkins 到Ansible的部署经验</h1><p>工作中，除了开发功能，还负责系统的部署工作。我从频繁的部署工作中，逐渐找到了一些偷懒的方法。从传统的Java -jar命令启动服务，到通过Docker 容器构建部署服务，再后来通过自动化部署工具Jenkins来完成部署，最后再结合Ansible完成远程部署。一步步的进步极大的减少部署工作，提高了工作效率（增加了许多划水时间）。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>Docker给我的印象很深，没有什么环境是docker pull 解决不了的，</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker ps           ， docker ps 默认显示运行中的容器，-a 显示所有，-l显示近期创建的容器</span><br><span class="line"></span><br><span class="line">docker start xxx    ， 启动xxx容器</span><br><span class="line"></span><br><span class="line">docker restart xxx  ， 重启xxx容器</span><br><span class="line"></span><br><span class="line">docker run xxx      ， 创建并运行xxx容器</span><br><span class="line"></span><br><span class="line">docker build -t xxx .   ，使用 Dockerfile 创建镜像</span><br><span class="line"></span><br><span class="line">docker stop xxx     ， 关闭容器</span><br><span class="line"></span><br><span class="line">docker rm xxx       ， 删除容器</span><br><span class="line"></span><br><span class="line">docker images       ， 查看所有镜像</span><br><span class="line"></span><br><span class="line">docker rmi xxx      ， 删除xxx镜像</span><br><span class="line"></span><br><span class="line">docker exec -it xxx sh          ， 进入xxx容器中，用quit退出</span><br><span class="line"></span><br><span class="line">docker logs -f xxx --tail 500   ， 查看xxx容器的日志，显示最后500行，常用命令</span><br><span class="line"></span><br><span class="line">docker inspect xxxx             ， 查看容器配置信息</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml up -d ， 按照app.yml文件配置以debug形式启动</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml down  ， 按照app.yml文件配置形式关闭</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：在gradle项目加入docker插件，即在gradle.build 文件中加入以下代码。需要注意的有插件的版本，项目打包后的名称，Dockerfile文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath(&quot;se.transmode.gradle:gradle-docker:1.2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;docker&apos;</span><br><span class="line"></span><br><span class="line">task buildDocker(type: Docker, dependsOn: build) &#123;</span><br><span class="line">    push = false</span><br><span class="line">    applicationName = &quot;项目名&quot;</span><br><span class="line">    dockerfile = file(&apos;src/main/docker/Dockerfile文件目录&apos;)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：创建Dockerfile文件，文件目录要和第一步中设置的保持一致。需要配置jdk镜像和基本的启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM frolvlad/alpine-oraclejdk8:slim</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD 项目jar名称.jar app.jar</span><br><span class="line">RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line">ENV JAVA_OPTS=&quot;&quot;</span><br><span class="line">ENV PORT=&quot;6666&quot;</span><br><span class="line">ENV DB_CONNECTION=&quot;jdbc:mysql://ip:port/database&quot;</span><br><span class="line">ENV DB_USER=&quot;user&quot;</span><br><span class="line">ENV DB_PASSWORD=&quot;password&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar --spring.datasource.url=$DB_CONNECTION --spring.datasource.usernam=$DB_USER --spring.datasource.password=$DB_PASSWORD --port=$PORT&quot;]</span><br></pre></td></tr></table></figure><p>第三步：将jar拷贝到服务器上，然后执行编译，运行的docker命令</p><p>一）、通过gradle的bootJar，将项目打包。同时需要把引入的第三方jar也要一起打入到项目jar中。</p><p>二）、Windows系统中可以通过Xftp将jar和Dockerfile文件拷贝同一个目录下。Linux系统可以通过scp命令上传文件。</p><p>三）、执行docker ps，查看当前运行的容器，执行docker stop和docker rm 关闭和删除之前旧版本的容器</p><p>四）、找到jar的目录，并在当前目录下，执行 docker build -t 镜像名称 . 的命令编译项目，注意后面的点不要漏了。</p><p>五）、编译成功后执行 docker run –name 容器名 -v /tmp:/tmp -p 对外开发的端口:项目启动的端口 镜像名:latest 。启动容器</p><p>六）、执行docker ps，查看容器启动是否正常启动。同时执行docker logs -f 容器名 –tail 500，查看容器启动日志，检查是否有异常</p><p>七）、最后浏览器访问一下，已确保部署成功。</p><p>全称大概需要几分钟的时间，虽然不算麻烦。可次数多了，就很麻烦了。有没有什么好的工具帮助我们完成这一系列操作呢？答案是肯定的。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>The leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.</p></blockquote><p>Jenkins 的logo是一个管家的形象，很贴切。对它的理解比较肤浅。他通过管理Git上的项目，来确保每次打包的jar都是最新的。同时在构建成功后执行我们输入的shell命令，来达到自动化部署的工作。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：创建一个负责编译的Jenkins项目，</p><p>在Jenkins控制台页面，点击页面左上角的“新建”按钮。再输入项目名后，可以选择创建一个空项目，也可以在页面最下面选择copy from 其他项目。不管如何创建，我们需要Jenkins管理项目的源码，构建和构建后的操作。</p><p>第二步：创建一个负责运行的Jenkins项目</p><p>以同样的方式创建项目，在构建触发器上，选择第一步创建的项目，构建的Shell命令是先删除之前的容器，然后在重新运行容器。若之前的容器不存在，则会构建失败。所以第一次构建的时候把第一行命令删掉。解决方案傻乎乎的，只是因为没有花时间去处理。</p><p>第三步：选择编译项目，点击立即构建，当第一个项目构成成功后，会自动触发运行项目。等待两个项目都成功后，就可以访问浏览器，检查功能。</p><p>有了Jenkins，一切变得轻松很多。但他也有一个较大的弊端，就是使用前必须要先安装。特别是在客户的服务器上，也许别人就只跑这一个服务，你给别人整了一个Jenkins，似乎有点大材小用了。有没有好的解决方法？答案是肯定的。</p><h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Ansible is an IT automation tool. It can configure systems, deploy software, and orchestrate more advanced IT tasks such as continuous deployments or zero downtime rolling updates.</p></blockquote><p>从接触到使用Ansible大概有一天的时间，对它的理解也是比较肤浅。我单纯的认为，他可以帮助我们在服务器之间传输文件，同时还可以执行一些shell命令。抱着这样的想法，我们可以通过Jenkins完成自动化编译，再通过Ansible传输资源文件到部署的环境中，同时执行启动Shell命令。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：修改Jenkins运行项目的构建Shell，将之前的docker run改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook ansible命令文件路径/app.yaml</span><br></pre></td></tr></table></figure><p>第二步：创建Ansible脚本文件app.yaml，目录和第一步中设置的保存一致，模版大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- hosts: &apos;需要部署的远程服务ip&apos;</span><br><span class="line">  tasks:</span><br><span class="line">   - name: &quot;关闭旧版本的容器&quot;</span><br><span class="line">     shell: docker stop xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除旧版本的容器&quot;</span><br><span class="line">     shell: docker rm xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除之前的旧文件&quot;</span><br><span class="line">     shell: rm -rf /旧文件路径/*</span><br><span class="line">   - name: &quot;传输Dockerfile文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/文件目录/Dockerfile</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;传输Jar文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/jar目录/xxx.jar</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;构建docker 镜像&quot;</span><br><span class="line">     shell: chdir=/jar所在目录 nohup docker build -t 镜像名 .</span><br><span class="line">   - name: &quot;启动容器&quot;</span><br><span class="line">     shell: nohup docker run --name 容器名 -v /挂载路径/:/挂载路径/ -p 对外端口:服务端口 -d 镜像名:latest</span><br></pre></td></tr></table></figure><p>第三步：在Jenkins上构建编译项目。</p><h2 id="前后端项目的部署"><a href="#前后端项目的部署" class="headerlink" title="前后端项目的部署"></a>前后端项目的部署</h2><p>到这里，三种部署的流程就完成了。如果你熟悉Docker的方式构建，再用Jenkins和Ansible的时候，就会简单很多。我在实际开发中，项目是前后端分离的。公司做了两个方案，</p><p>第一种：前后端分开部署，即Jenkins上有四个项目。前端和后端各两个项目。这样的好处就是前后端互不影响。不会因为对方的错误而从新编译。缺点也是有的，很难保证对方部署的环境是最新的。</p><p>第二种：把前后端放在一个项目中，一次构建完成两个项目的打包部署。缺点是构建慢，优点就是保证两端的代码都是最新的，适合发布到预发布环境和正式环境。</p><p>那么，针对前后端一起部署的需求，Jenkins和Ansible同样也需要简单的修改。其思路就是Jenkins负责编译项目，将资源文件压缩，再通过Ansible上传到其他服务器上。执行解压，构建，启动的命令。</p><p>看起来视乎很简单，但有一个坑希望你们跨过去。前端打包需要npm或者其他工具，但是你的服务器上没有安装。此时请务必通过Jenkins控制台，或者用Jenkins帐号登录服务器安装这些工具。笔者就是通过root帐号登录服务器安装的npm，通过Jenkins编译时提示没有权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从Docker-到Jenkins-到Ansible的部署经验&quot;&gt;&lt;a href=&quot;#从Docker-到Jenkins-到Ansible的部署经验&quot; class=&quot;headerlink&quot; title=&quot;从Docker 到Jenkins 到Ansible的部署经验&quot;&gt;
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ansible-playbook之roles实现</title>
    <link href="http://blog.ozairs.com/Ansible/ansible-playbook%E4%B9%8Broles%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.ozairs.com/Ansible/ansible-playbook之roles实现/</id>
    <published>2019-03-17T10:19:21.000Z</published>
    <updated>2019-03-17T10:26:15.653Z</updated>
    
    <content type="html"><![CDATA[<p>一、目标<br>两台主机：192.168.50.138（安装ansible）、192.168.50.139</p><p>[webservers]<br>192.168.50.138 httpd_point=80<br>192.168.50.139 httpd_point=8080<br>实现在两台主机上同时安装apache，提供配置文件，并启动。在139主机上提供mysql服务。</p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>二、roles之apache<br>1、创建目录</li></ul><p>mkdir -pv /ansible_playbooks/roles/{apache,mysql}/{tasks,files,templates,meta,handlers,vars}<br>2、复制一份httpd配置文件作为template</p></li></ul><p>cp /etc/httpd/conf/httpd.conf /ansible_playbooks/roles/apache/templates/<br>编辑此配置文件做变量引用</p><p>Listen <br>3、编写tasks任务</p><p>[root@node1 apache]# vim tasks/main.yml </p><ul><li>name: install httpd<br>yum: name=httpd state=latest</li><li>name: install config<br>template: src=httpd.conf dest=/etc/httpd/conf/httpd.conf<br>notify:<ul><li>restart apache</li></ul></li><li>name: start apache<br>service: name=httpd state=started<br>4、编写handlers</li></ul><p>[root@node1 apache]# vim handlers/main.yml </p><ul><li>name: restart apache<br>service: name=httpd state=restarted<br>三、roles之mysql<br>1、复制一份mysql配置文件到files文件中</li></ul><p>cp /etc/my.cnf /ansible_playbooks/roles/mysql/files/<br>2、编写tasks任务<br>[root@node1 mysql]# vim /ansible_playbooks/roles/mysql/tasks/main.yml </p><ul><li>name: install mysql<br>yum: name=mariadb state=latest</li><li>name: install config-mysql<br>copy: src=my.cnf dest=/etc/my.cnf</li><li>name: start mariadb<br>service: name=mariadb state=started<br>四、编写剧本</li></ul><p>[root@node1 mysql]# vim /ansible_playbooks/site.yml </p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>五、执行剧本</li></ul></li></ul><p>[root@node1 handlers]# ansible-playbook /ansible_playbooks/site.yml </p><p>PLAY [all] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.138]<br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>PLAY [192.168.50.139] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install config-mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>TASK [mysql : start mariadb] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>PLAY RECAP <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>192.168.50.138             : ok=4    changed=0    unreachable=0    failed=0<br>192.168.50.139             : ok=11   changed=2    unreachable=0    failed=0   </p><h2 id="成功！！！"><a href="#成功！！！" class="headerlink" title="成功！！！"></a>成功！！！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、目标&lt;br&gt;两台主机：192.168.50.138（安装ansible）、192.168.50.139&lt;/p&gt;
&lt;p&gt;[webservers]&lt;br&gt;192.168.50.138 httpd_point=80&lt;br&gt;192.168.50.139 httpd_point=
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible实战汇总</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%AE%9E%E6%88%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible实战汇总/</id>
    <published>2019-03-17T10:05:37.000Z</published>
    <updated>2019-03-17T11:02:01.798Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 实战目录</p><p>一、Ansible与Terraform相结合</p><p>1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；</p><p><a href="https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d" target="_blank" rel="noopener">https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d</a></p><p>二、Ansible操作Docker容器</p><p>1、使用 Ansible 高效交付 Docker 容器</p><p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html</a></p><p>2、基于 docker 的 jenkins-ansible-gitlab 实现自动化部署</p><p><a href="https://www.jianshu.com/p/191f0c81c6bb" target="_blank" rel="noopener">https://www.jianshu.com/p/191f0c81c6bb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible 实战目录&lt;/p&gt;
&lt;p&gt;一、Ansible与Terraform相结合&lt;/p&gt;
&lt;p&gt;1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/setu
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们抛弃ECS而选择了Kubernetes</title>
    <link href="http://blog.ozairs.com/Kubernetes/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%8A%9B%E5%BC%83ECS%E8%80%8C%E9%80%89%E6%8B%A9%E4%BA%86Kubernetes/"/>
    <id>http://blog.ozairs.com/Kubernetes/为什么我们抛弃ECS而选择了Kubernetes/</id>
    <published>2019-03-17T05:18:22.000Z</published>
    <updated>2019-03-17T05:20:40.489Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。</p><p>3个月前，我们在</p><p>nanit.com</p><p>希望选择一个合适的Docker编排框架，ECS成为了我们的首选，毕竟，我们对AWS的服务较为熟悉，并且我们的基础设施都是建立在AWS的。经过一段时间的测试，我们发现ECS并不成熟，缺少一些我们需要的关键功能，因此我们开始尝试其他的框架：Kubernetes。令人意外的是，Kubernetes非常成熟，几乎支持我们需要的所有功能。对于我们来说，Kubernetes在ECS的主场完胜了ECS。接下来，就让我们一起来看看Kubernetes赢在哪些方面。</p><p>注意：ECS一直在更新，我们会尽可能的跟进这些内容，但部分内容可能被忽略了，希望读者不要介意。</p><h3 id="构建集群（Cluster-Setup）"><a href="#构建集群（Cluster-Setup）" class="headerlink" title="构建集群（Cluster Setup）"></a>构建集群（Cluster Setup）</h3><p>ECS:为了启动一个ECS集群，用户需要设置一个Auto Scaling Group。用户可以编辑user-data来将EC2实例添加到指定的ECS集群上。当ASG被设置，实例启动之后，用户可以在ECS控制台看到这部分内容。现在，用户可以开始进行task-definition，方式类似于Docker-compose。</p><p>Kubernetes：想要在AWS上启动一个Kubernetes，用户需要先启动一个具有一定权限的EC2实例（通过IAM）。这将会创建多个AWS constructs来支持你的集群：VPC、ASG、一些安全组（Security Groups）和一个Kubernetes主实例。集群需要几分钟来启动，之后用户就能够在上面运行自己的容器。</p><p>比较结果：使用这两种框架来启动一个集群都非常的简单和友好。</p><h3 id="启动基础服务（Basic-Service-Setup）"><a href="#启动基础服务（Basic-Service-Setup）" class="headerlink" title="启动基础服务（Basic Service Setup）"></a>启动基础服务（Basic Service Setup）</h3><p>我们的任务是启动一个Nginx 镜像，并且让其他人能够访问这个Web服务。</p><p>ECS: 首先，我们需要创建一个ELB(Elastic Load Balancer)，它负责80端口的转发。然后，我们需要创建一个task-definition，它负责在80端口上启动一个Docker镜像。最后，需要创建一个Service，它会显示出有多少实例会同时运行。我们需要将它绑定到我们之前创建的ELB上。</p><p>Kubernetes：首先需要创建一个Replication Controller，它会显示出我们希望运行的Docker镜像和有多少镜像会同时运行。之后，我们需要创建一个Service object，这会启动一个ELB并且将ELB的流量转发到对应的容器上。</p><p>比较结果：Kubernetes的方式更舒服一些，更简洁。用户并不需要手工启动或者管理ELB。Kubernetes会完全负责管理：当用户创建了一个service，一个ELB会自动创建；当用户删除了一个service，它会自动从AWS上删除。</p><h3 id="服务发现（Service-Discovery）"><a href="#服务发现（Service-Discovery）" class="headerlink" title="服务发现（Service Discovery）"></a>服务发现（Service Discovery）</h3><p>当你使用了微服务架构和Docker，一个好的服务发现解决方案是至关重要的。Docker容器总是在不同虚拟机中迁移，用户必须有一个可靠的方法来发现在集群内和集群外的服务。</p><p>ECS: ECS并没有提供任何服务发现的解决方案。我能想到的最好方法就是构建一个内部加载平衡器（internal load balancer），并且将每一个service附加到一个平衡器上。平衡器的host name不会被改变，然后你就能够利用这个host name来作为服务的端点。其他的方法还有集成一个外部的程序，比如</p><p>Consul</p><p>。</p><p>Kubernetes：我认为这是Kubernetes的亮点之一。Kubernetes内置了一个完全的解决方案。它是一个插件，因此用户可以选择是否使用，但我强烈建议使用。它能够和namespace一起很好的工作。简单来说，当你创建了一个Kubernetes服务，比如说叫做redis，你就能够在集群的任何地方引用redis这个名字，即便是跨虚拟机。这就像是让docker网络跨越了特定的虚拟机，连通了整个集群。Namespaces允许你将多个服务归纳到一个具有逻辑的组中。现在假设我们有两个命名空间，分别是production和staging，他们都包含有一个redis的服务。一个在production命名空间下的容器可以通过redis来引用在production命名空间下的redis服务，同样的，在stagin命名空间下的容器也能通过redis来引用到位于stagine命名空间下的redis服务。这种自动化识别使得用户不需要花费时间去配置信息就能够构建一个隔离的环境，并且你可以随意在所有的命名空间中使用redis来引用对应的服务，接下来kunernetes会为你自动解析它们。</p><p>比较结果：毫无疑问，Kubernetes小胜一局。使用Kubernetes，用户完全不用关心服务发现的事情，全部交给Kubernetes来做就好了：）</p><h3 id="部署（Deployments）"><a href="#部署（Deployments）" class="headerlink" title="部署（Deployments）"></a>部署（Deployments）</h3><p>当我们升级一个服务的时候，即便还在部署，我们也想要确保它百分之百能用。我们的测试包括一个简单的NginX服务和一些简单的静态网页。我们启动了一个并发为30个请求的负载测试，并且在负载测试期间，我们会对该服务进行升级。</p><p>在部署期间，我们发现ECS丢失了比Kubernetes更多的请求。其中，Kubernetes丢失了0-2个请求，而ECS丢失了9-14个。</p><p>比较结果：说实话，我对ECS非常的失望。同样，我也对Kubernetes表示失望，但是它至少比ECS好多了。值得注意的是，Kubernetes 1.1.1版本应该会对轮询升级机制（rollong update mechanism）进行改善，还有一些其他的系统系能提升，这些改进都会使得这些数字变得更好看。</p><h3 id="持久卷（Persistent-Volumes）"><a href="#持久卷（Persistent-Volumes）" class="headerlink" title="持久卷（Persistent Volumes）"></a>持久卷（Persistent Volumes）</h3><p>我们经常需要挂载一些持久性的文件系统到一个指定的容器上，MySQL就是一个典型的例子。</p><p>ECS：ECS支持Docker原生的解决方案——用户可以启动一个数据容器，然后使用volumes-from命令来挂载它到其他容器上。就拿MySQL来看，你首先需要设置一个mysql-data容器，这个容器仅仅拥有一个数据卷。然后设置另外一个mysql-db容器，这个容器使用volumes-from命令来挂载之前创建的数据卷容器。这个方法看起来不错，但是它是host-sepicific的，这意味着你的mysql-db容器不能够在主机之间移动。你必须指定mysql-db容器在哪一个主机上运行，以此来防止容器被重新分配到其他主机上，最终失去了持久性。</p><p>Kubernetes：除了从一个指定的主机上挂载数据卷，Kubernetes还提供了一个选项：挂载一个EBS（Elastic Book Store）数据卷。这意味着一个容器的持久性存储可以在多个不同的虚拟机之间保留。你再也不需要强制你的MySQL容器必须运行在哪一个具体的虚拟机上。</p><p>注意：EBS同一时间只能被一个虚拟机挂载，这意味着如果有一个服务，它有两个运行在不同虚拟机的容器，他们将不能够挂载和共享这个EBS。</p><p>比较结果：即便Kubernetes的EBS挂载有一定的限制，但它依旧非常的独特和有用。</p><h3 id="健康检查（Health-Checks）"><a href="#健康检查（Health-Checks）" class="headerlink" title="健康检查（Health-Checks）"></a>健康检查（Health-Checks）</h3><p>确保拥有足够的服务容量是高可用性和冗余性的核心思想。健康检查就是用来确保服务不仅仅是运行的，并且它们还是健康和可操作的。</p><p>ECS：ECS使用ELB(Elastic Load Balancer)健康检查，这种方式有三个主要的缺点：</p><p>\1. ELB健康检查仅仅限于HTTP/TCP检查</p><p>\2. 如果你想要对一个不开放TCP端口的服务进行检查，这是不行的。仅仅是为了能够进行健康检查，你就必须运行一个HTTP/TCP服务器。</p><p>\3. 即便你拥有一个支持HTTP/TCP的服务，你还需要创建一个ELB，并将它绑定到这个服务上，这样才能进行健康检查。</p><p>Kubernetes：除了基于HTTP/TCP的健康检查，Kubernetes还提供了一种叫做Exec的方式。Exec可以让用户在容器中运行命令。如果命令结束，并且返回0则表示这个服务是健康的，否则这个服务很可能是不健康的，它会被其他的实例所替换。</p><p>比较结果：Kubernetes的方式更灵活，更简单配置。用户并不需要去启动一个冗余的HTTP/TCP服务器仅仅为了进行健康检查，并且即便服务没有绑定ELB，你也可以对它们进行健康检查。</p><h3 id="端口管理（Port-Management）"><a href="#端口管理（Port-Management）" class="headerlink" title="端口管理（Port Management）"></a>端口管理（Port Management）</h3><p>从我们的上篇文章中可以看出，端口管理在Docker中是比较困难的。我们想通过一个简单的例子来说明Kubernetes如何比ECS更优雅的解决了这个问题。我们拥有一台虚拟机和两个监听80端口的网站。我们不能够在同一个虚拟机上开2个80端口，因此我们需要寻找一个方法来解决这个问题。</p><p>ECS:用户必须手工确定两个服务没有使用同一个端口。我们只有一台虚拟机，因此只能运行一个开放80端口的容器。当我们想要开启第二个开放80端口的容器时，这是不行的，因为我们没有多余的虚拟机了。也就是说，能够开放多少个x端口的服务取决于拥有多少个虚拟机。在小型集群中，这是非常容易满足的条件，但是当你的服务数量变得越来越多时，这将成为一个头疼的问题，因为当你想要扩充容器时，你必须确认你还有足够的端口。</p><p>Kubernetes：Kubernetes非常优雅的解决了这个问题。它为每一个虚拟机上的容器都分配了一个随机的端口。然后它创建了2个ELB，一个将80端口转发到容器A的随机端口上，另外一个转发到容器B的随机端口上。一个内部的路由机制会负责将数据包转发到对应容器端口。</p><p>比较结果：Kubernetes使用虚拟端口的方式代替绑定原始端口的方法，很好的解决了这个头疼的问题。</p><h3 id="记录（Logging）"><a href="#记录（Logging）" class="headerlink" title="记录（Logging）"></a>记录（Logging）</h3><p>没有什么系统不需要记录功能。</p><p>我从没有想过记录会成为一个大问题，但能够为你解决问题令我非常的高兴，即便这个问题非常简单。我们之前提到Kubernetes提供了一个服务发现的扩展功能，在这里，我想说的是记录的扩展功能。它含有两个不同的记录和度量收集（metric collection）的机制。第一种是著名的</p><p>ELK</p><p>方法，ELK会收集容器的所有记录，并且能够让用户通过Kibana接口来查询和可视化这些记录。第二种是InfluxDB，它使用</p><p>Grafana</p><p>作为可视化工具来查询系统信息，如CPU和内存使用情况。</p><p>比较结果：Kubernetes的扩展功能更胜一筹。当然，你会说我并不需要这些扩展，系统也能很好工作，但是，它们效果如此之好，并且能适用于99%的用例，为什么不使用呢？ECS并没有提供内置的记录功能，用户想要集成一个进去并不是很困难，但是这些并不能和Kubernetes提供的功能相提并论。</p><h3 id="未知的云平台（Cloud-Agnostic）"><a href="#未知的云平台（Cloud-Agnostic）" class="headerlink" title="未知的云平台（Cloud Agnostic）"></a>未知的云平台（Cloud Agnostic）</h3><p>其实，Kubernetes和ECS之间并不存在竞争：）</p><p>ECS会专注于AWS平台，如果你已经在ECS上构建了你的基础架构，当你想要转移到其他云平台时，你将会遇到很多困难。</p><p>Kubernetes适用于多个云平台。你可以在AWS，Google Cloud，微软的ZURE，Rackspace等等上运行你的集群，并且运行效果或多或少都是相同的。在这里，或多或少指的是有一些功能只有部分云供应商提供。你必须确认你选择的新供应商能够支持Kubernetes中使用的功能，至少确保迁移是可能的。</p><h3 id="开源软件（OSS）"><a href="#开源软件（OSS）" class="headerlink" title="开源软件（OSS）"></a>开源软件（OSS）</h3><p>Kubernetes是开源的项目，而ECS不是。这意味着，所有的一切，从源代码到未来的发展路线都是对你开放的。发现了漏洞？你可以创建一个issue或者直接提交一个pull 请求来修复它。新的功能会被添加到每一个新版本，其中的贡献人数和pull请求是惊人的。</p><p>ECS有着不同的性质，我不能够在网上找到关于它未来发展路线的规划。你不能够获得一个漏洞和issue的列表，你必须深入到论坛上去寻找想要的答案。并且你寻找的答案往往都是缺乏实际的，并不能够提供任何帮助（请看</p><p>这里</p><p>）。也许这仅仅是因为我个人的糟糕经历，但是不管怎么说，这都是令人烦躁和失望的。</p><p>比较结果：就我个人而言，我更喜欢开源软件。我喜欢Kubernetes的开放性，每个人都能够参与讨论和贡献代码。我相信社区的力量会给我们带来一个更好的产品。</p><h3 id="多可用区域（Multi-AZ）"><a href="#多可用区域（Multi-AZ）" class="headerlink" title="多可用区域（Multi-AZ）"></a>多可用区域（Multi-AZ）</h3><p>当谈论到Kubernetes时，有一件事情困扰着我：它不支持AWS上的多可用区域集群（multiple availability-zones cluters）。这意味着所有EC2实例都集中在一个AZ上，这使得你的集群很可能会遭受到中断问题。</p><p>ECS有对Multi-AZ有很好的支持。</p><p>比较结果：在Kubernetes的issue上，已经有一些工作正在进行。我十分确定下个版本会很好的得到改善。因此ECS在这一点上的胜利并不会长久。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很多公司都开始使用Docker作为他们的主要基础设置，传递机制（delivery mechanism）和编排框架（orchestration frameworks）成为了系统的核心，并且影响着我们开发，迁移，运行，升级的方式。当我想要比较ECS和Kubernetes时，我找不到类似的文章。所以我认为把我们的经验公布出来非常的重要，这样其他人能够站在我们的肩膀上看的更远。</p><p>对于nanit.com来说，Kubernetes毫无疑问获得了胜利。如果你有任何的异议，请告诉我理由，我非常想要知道这些内容：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。&lt;/p&gt;
&lt;p&gt;3个月前，我们在&lt;/p&gt;
&lt;p&gt;nanit.com&lt;/p&gt;
&lt;p&gt;希望选择一个合适的Docker
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与Docker的自动化CI/CD实战</title>
    <link href="http://blog.ozairs.com/DevOps/Jenkins%E4%B8%8EDocker%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96CI-CD%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Jenkins与Docker的自动化CI-CD实战/</id>
    <published>2019-03-17T02:48:26.000Z</published>
    <updated>2019-03-17T03:02:41.598Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。</p><h2 id="一、发布流程设计"><a href="#一、发布流程设计" class="headerlink" title="一、发布流程设计"></a>一、发布流程设计</h2><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.1.png" alt=""></p><p>工作流程：**</p><ol><li>开发人员提交代码到Git版本仓库；</li><li>Jenkins人工/定时触发项目构建；</li><li>Jenkins拉取代码、代码编码、打包镜像、推送到镜像仓库；</li><li>Jenkins在Docker主机创建容器并发布。</li></ol><p>环境规划如下：</p><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>Jenkins/Docker</td><td>192.168.0.217</td></tr><tr><td>Docker</td><td>192.168.0.218</td></tr><tr><td>Git/Registry</td><td>192.168.0.219</td></tr></tbody></table><p>操作系统：CentOS7.4</p><h2 id="二、部署Git仓库"><a href="#二、部署Git仓库" class="headerlink" title="二、部署Git仓库"></a>二、部署Git仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install git -y</span><br></pre></td></tr></table></figure><ol><li><p>创建Git用户并设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># useradd git</span><br><span class="line"># passwd git</span><br></pre></td></tr></table></figure></li><li><p>创建仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># su - git</span><br><span class="line"># mkdir solo.git</span><br><span class="line"># cd solo.git</span><br><span class="line"># git --bare init</span><br></pre></td></tr></table></figure></li><li><p>访问创建的这个仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone git@192.168.0.212:/home/git/solo.git</span><br></pre></td></tr></table></figure><h2 id="三、准备Jenkins环境"><a href="#三、准备Jenkins环境" class="headerlink" title="三、准备Jenkins环境"></a>三、准备Jenkins环境</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于代码编译、部署、测试等工作。 Jenkins也是一个跨平台的，大多数主流的平台都支持，而且安装很简单，我们这里以部署war包方式安装它。<br>官网下载地址：<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a> </p><p>在安装前需要具备Java环境，安装方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tar zxf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8 </span><br><span class="line"># vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8 </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar </span><br><span class="line">export JAVA_HOME PATH CLASSPATH</span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>在192.168.0.217主机安装Jenkins，下载Tomcat二进制包将war包到webapps下即可：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war </span><br><span class="line"># wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># tar zxf apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># mv apache-tomcat-8.5.32 /usr/local/tomcat-jenkins </span><br><span class="line"># rm /usr/local/tomcat-jenkins/webapps/* -rf </span><br><span class="line"># unzip jenkins.war -d /usr/local/tomcat-jenkins/webapps/ROOT </span><br><span class="line"># cd /usr/local/tomcat-jenkins/bin/ </span><br><span class="line"># ./startup.sh </span><br><span class="line"># tail ../logs/catalina.out -f </span><br><span class="line">... </span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated. </span><br><span class="line">Please use the following password to proceed to installation: </span><br><span class="line"></span><br><span class="line">a5f1f7c167fd4b8ab62f9497d32d97db </span><br><span class="line"></span><br><span class="line">This may also be found at: /root/.jenkins/secrets/initialAdminPassword ...</span><br></pre></td></tr></table></figure><p>部署成功，访问Jenkins：<a href="http://ip:8080/" target="_blank" rel="noopener">http://ip:8080</a></p><p>第一步：输入上面日志输出的密码：a5f1f7c167fd4b8ab62f9497d32d97db，或者从本机/root/.jenkins/secrets/initialAdminPassword文件获取，点击继续<br>第二步：点击“选择插件来安装”<br>第三步：保持默认，点击继续<br>第四步：创建管理员用户，保存并完成<br>第五步：设置Jenkins访问地址，保持默认，点击保存完成</p><p>安装完成，开始使用Jenkins：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/2.png" alt=""></p><h2 id="四、部署私有镜像仓库"><a href="#四、部署私有镜像仓库" class="headerlink" title="四、部署私有镜像仓库"></a>四、部署私有镜像仓库</h2><p>Docker Hub作为Docker默认官方公共镜像；如果想自己搭建私有镜像仓库，官方也提供registry镜像，使得搭建私有仓库非常简单。<br>在192.168.0.219部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>接下来测试registry可用性。<br>由于Docker CLI默认以HTTPS访问，而部署的registry并未提供HTTPS，因此，需要在pull镜像的Docker主机（192.168.0.217，192.168.0.218）添加HTTP可信任：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> # vi /etc/docker/daemon.json </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.0.219:5000&quot;]&#125;</span><br><span class="line"># service docker restart</span><br></pre></td></tr></table></figure><h2 id="五、安装Docker"><a href="#五、安装Docker" class="headerlink" title="五、安装Docker"></a>五、安装Docker</h2><p>在192.168.0.217/192.168.0.218/192.168.0.219主机安装Docker，如下：</p><ol><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>添加Docker软件包源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install docker-ce -y</span><br></pre></td></tr></table></figure></li><li><p>配置加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://bc437cce.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>启动并开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="六、构建Tomcat基础镜像"><a href="#六、构建Tomcat基础镜像" class="headerlink" title="六、构建Tomcat基础镜像"></a>六、构建Tomcat基础镜像</h2><p>JAVA程序必须有JDK环境才可以运行，为了减少镜像大小及提高性能，这里直接把JDK放到宿主机上，容器以挂载形式使用。<br>在192.168.0.217/192.168.0.218安装JDK：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8</span><br></pre></td></tr></table></figure><p>Tomcat基础镜像Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.aliangedu.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.32</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk</span><br><span class="line"></span><br><span class="line">RUN yum install wget -y</span><br><span class="line"></span><br><span class="line">RUN wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v$&#123;VERSION&#125;/bin/apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    mv apache-tomcat-$&#123;VERSION&#125; /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    rm -rf apache-tomcat-$&#123;VERSION&#125;.tar.gz /usr/local/tomcat/webapps/* &amp;&amp; \</span><br><span class="line">    mkdir /usr/local/tomcat/webapps/ROOT</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure><p>构建镜像并上传到registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t 192.168.0.219:5000/tomcat-85 -f Dockerfile .</span><br><span class="line"># docker push 192.168.0.219:5000/tomcat-85</span><br></pre></td></tr></table></figure><h2 id="七、Jenkins配置全局工具配置"><a href="#七、Jenkins配置全局工具配置" class="headerlink" title="七、Jenkins配置全局工具配置"></a>七、Jenkins配置全局工具配置</h2><p>主页面 -&gt; 系统管理 -&gt; 全局工具配置</p><p>指定JDK、Maven路径，Git保持默认：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/3.png" alt=""><br>如果Jenkins主机没有git命令，需要安装Git：<br><code># yum install git -y</code></p><h2 id="八、Jenkins安装必要插件"><a href="#八、Jenkins安装必要插件" class="headerlink" title="八、Jenkins安装必要插件"></a>八、Jenkins安装必要插件</h2><p><strong>1. Jenkins安装必要插件</strong><br>主页面 -&gt; 系统管理 -&gt;管理插件：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/4.png" alt=""><br>安装SSH与Git Parameter插件。</p><p>插件说明：</p><ul><li>SSH：用于SSH远程Docker主机执行Shell命令</li><li>Git Parameter：动态获取Git仓库Branch、Tag</li></ul><p><strong>2. 配置SSH插件</strong><br><strong>第一步：先创建一个用于连接Docker主机的凭据。</strong><br>主页面 -&gt; 凭据 -&gt; 系统 -&gt; 右击全局凭据 -&gt; 添加凭据：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/5.png" alt="">输入连接Docker主机的用户名和密码：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/6.png" alt=""><br><strong>第二步：添加SSH远程主机</strong><br>主页面 -&gt; 系统管理 -&gt; 系统设置 -&gt; SSH remote hosts：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/7.png" alt=""></p><h2 id="九、上传JAVA项目代码到Git仓库"><a href="#九、上传JAVA项目代码到Git仓库" class="headerlink" title="九、上传JAVA项目代码到Git仓库"></a>九、上传JAVA项目代码到Git仓库</h2><p>从Github拉取开源JAVA博客系统solo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/b3log/solo</span><br><span class="line"># cd solo</span><br><span class="line">移除旧的推送地址，添加新的：</span><br><span class="line"># git remote remove origin </span><br><span class="line"># git remote add origin git@192.168.0.219:/home/git/solo.git</span><br><span class="line">提交代码到Git仓库并创建tag：</span><br><span class="line"># touch src/main/webapp/a.html</span><br><span class="line"># git add .</span><br><span class="line"># git commit -m “a”</span><br><span class="line">创建标签：</span><br><span class="line"># git tag 1.0.0</span><br><span class="line">推送到Git服务器：</span><br><span class="line"># git push origin 1.0.0</span><br></pre></td></tr></table></figure><h2 id="十、Jenkins创建项目并发布测试"><a href="#十、Jenkins创建项目并发布测试" class="headerlink" title="十、Jenkins创建项目并发布测试"></a>十、Jenkins创建项目并发布测试</h2><p>主页面 -&gt; 新建任务 -&gt; 输入任务名称，构建一个Maven项目：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/8.png" alt=""><br>注意：如果没有显示“构建一个Maven项目”选项，需要在管理插件里安装“Maven Integration plugin”插件。<br>配置Git参数化构建：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/9.png" alt=""><br>动态获取Git仓库tag，与用户交互选择Tag发布：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/10.png" alt=""><br>指定项目Git仓库地址：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/11.png" alt=""><br>修改*/master为$Tag，Tag是上面动态获取的变量名，表示根据用户选择打代码版本。</p><p>设置maven构建命令选项：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/12.png" alt=""></p><p>利用pom.xml文件构建项目。<br>在Jenkins本机镜像构建与推送到镜像仓库，并SSH远程连接到Docker主机使用推送的镜像创建容器：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/13.png" alt=""><br>上图中，在Jenkins主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 构建镜像</span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM 192.168.0.219:5000/tomcat-85:latest</span><br><span class="line">RUN rm -rf /usr/local/tomcat/webapps/ROOT</span><br><span class="line">COPY target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">EOF</span><br><span class="line">docker build -t $REPOSITORY .</span><br><span class="line"># 上传镜像</span><br><span class="line">docker push $REPOSITORY</span><br></pre></td></tr></table></figure><p>上图中，SSH远程Docker主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 部署</span><br><span class="line">docker rm -f blog-solo |true</span><br><span class="line">docker image rm $REPOSITORY |true</span><br><span class="line">docker container run -d --name blog-solo -v /usr/local/jdk1.8:/usr/local/jdk -p 88:8080 $REPOSITORY</span><br></pre></td></tr></table></figure><p>注：容器名称blog-solo，暴露宿主机端口88，即使用宿主机IP:88访问blog-solo项目。<br>blog-solo项目已配置完成，开始构建：</p><p>选择tag，开始构建：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/14.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/15.png" alt=""></p><p>点击左下角构建历史里，右击第一个查看控制台输出：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/16.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/17.png" alt=""></p><p>浏览器访问solo项目：<a href="http://192.168.0.218:88/" target="_blank" rel="noopener">http://192.168.0.218:88</a><br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/18.png" alt=""><br>如果输出上述页面说明是正常的，页面没有加载成功样式，需要修改下项目里访问地址。</p><p>至此，自动化CI环境搭建完成，你可以模拟提交代码并打tag测试自动化发布流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。&lt;/p&gt;
&lt;h2 id=&quot;一、发布流程设计&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>把一个Node.js web应用程序给Docker化</title>
    <link href="http://blog.ozairs.com/DevOps/%E6%8A%8A%E4%B8%80%E4%B8%AANode-js-web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%99Docker%E5%8C%96/"/>
    <id>http://blog.ozairs.com/DevOps/把一个Node-js-web应用程序给Docker化/</id>
    <published>2019-03-17T02:26:13.000Z</published>
    <updated>2019-03-17T03:02:41.595Z</updated>
    
    <content type="html"><![CDATA[<p>本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 <em>非</em> 产品发布人员。此教程同样假定你有一个可以正常工作的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装</a>，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。</p><p>在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。</p><p>Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。</p><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"First Last &lt;first.last@example.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><p>然后，创建一个 <code>server.js</code> 文件，使用 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a> 框架定义一个 Web 应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello world\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。</p><h2 id="创建一个名称为-Dockerfile-的文件"><a href="#创建一个名称为-Dockerfile-的文件" class="headerlink" title="创建一个名称为 Dockerfile 的文件"></a>创建一个名称为 <code>Dockerfile</code> 的文件</h2><p>创建一个空文件，命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>用你最喜欢的文本编辑器打开这个 <code>Dockerfile</code>。</p><p>我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），<code>Node</code> 的版本号为 <code>8</code>。你可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker 站点</a> 获取相关镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure><p>此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 <code>npm</code> 安装你的应用程序的所有依赖。请注意，如果你的 <code>npm</code> 的版本是 4 或者更早的版本，<code>package-lock.json</code> 文件将不会自动生成。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install app dependencies</span></span><br><span class="line"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span><br><span class="line"><span class="comment"># where available (npm@5+)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br></pre></td></tr></table></figure><p>请注意，我们只是拷贝了 <code>package.json</code> 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">见此</a>。 进一步说，对于生产环境而言，注释中提及的 <code>npm ci</code> 命令协助提供了一个更快、可靠、可再生的构建环境。欲知详情，可以参考<a href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" target="_blank" rel="noopener">此处</a>。</p><p>在 Docker 镜像中使用 <code>COPY</code> 命令绑定你的应用程序：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure><p>你的应用程序绑定的端口为 <code>8080</code>，所以你可以使用 <code>EXPOSE</code> 命令使它与 <code>docker</code> 的镜像做映射：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>最后但同样重要的事是，使用定义运行时的 <code>CMD</code> 定义命令来运行应用程序。这里我们使用最简单的 <code>npm start</code> 命令，它将运行 <code>node server.js</code> 启动你的服务器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>你的 <code>Dockerfile</code> 现在看上去是这个样子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>在 <code>Dockerfile</code> 的同一个文件夹中创建一个 <code>.dockerignore</code> 文件，带有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。</p><h2 id="构建你的镜像"><a href="#构建你的镜像" class="headerlink" title="构建你的镜像"></a>构建你的镜像</h2><p>进入到 <code>Dockerfile</code> 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 <code>-t</code> 让你标记你的镜像，以至于让你以后很容易地用 <code>docker images</code> 找到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;your username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><p>Docker 现在将给出你的镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">REPOSITORY                      TAG        ID              CREATED</span><br><span class="line">node                            8          1934b0b038d1    5 days ago</span><br><span class="line">&lt;your username&gt;/node-web-app    latest     d64d3505b0d2    1 minute ago</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用 <code>-d</code> 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 <code>-p</code> 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app</span><br></pre></td></tr></table></figure><p>把你应用程序的输出打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get container ID</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print app output</span></span><br><span class="line">$ docker logs &lt;container id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">Running on http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果你需要进入容器中，请运行 <code>exec</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter the container</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container id&gt; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为测试你的应用程序，给出与 Docker 映射过的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">ID            IMAGE                                COMMAND    ...   PORTS</span><br><span class="line">ecce33b30ebf  &lt;your username&gt;/node-web-app:latest  npm start  ...   49160-&gt;8080</span><br></pre></td></tr></table></figure><p>在上面的例子中，在容器中 Docker 把端口号 <code>8080</code> 映射到你机器上的 <code>49160</code> 。</p><p>现在你可以使用 <code>curl</code>（如果需要的话请通过 <code>sudo apt-get install curl</code> 安装）调用你的程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:49160</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 12</span><br><span class="line">ETag: W/<span class="string">"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"</span></span><br><span class="line">Date: Mon, 13 Nov 2017 20:53:59 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。</p><p>你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容：</p><ul><li><a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener">官方 Node.js 的 Docker 镜像</a></li><li><a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">Node.js 基于 Docker 使用的最佳经验</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方 Docker 文档</a></li><li><a href="https://stackoverflow.com/questions/tagged/docker" target="_blank" rel="noopener">在 StackOverFlow 上有关 Docker 标记内容</a></li><li><a href="https://reddit.com/r/docker" target="_blank" rel="noopener">Docker Subreddit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 &lt;em&gt;非&lt;/em&gt; 产品发布人员。此教程同样假定你有一个可以正常工作的 &lt;a href=&quot;https://docs.docker.com/engine/in
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="NodeJs" scheme="http://blog.ozairs.com/tags/NodeJs/"/>
    
  </entry>
  
</feed>
