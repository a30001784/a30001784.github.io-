<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>带你走进美丽的墨尔本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ozairs.com/"/>
  <updated>2019-04-01T02:32:33.417Z</updated>
  <id>http://blog.ozairs.com/</id>
  
  <author>
    <name>Mark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主流CI/CD工具比较：Jenkins vs Bamboo vsTeamcity</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%B8%BB%E6%B5%81CI-CD%E5%B7%A5%E5%85%B7%E6%AF%94%E8%BE%83%EF%BC%9AJenkins-vs-Bamboo-vsTeamcity/"/>
    <id>http://blog.ozairs.com/Jenkins/主流CI-CD工具比较：Jenkins-vs-Bamboo-vsTeamcity/</id>
    <published>2019-04-01T02:29:11.000Z</published>
    <updated>2019-04-01T02:32:33.417Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有看过1924年的奥运世界纪录？我知道你在这里可以获得一个很好的CI / CD工具，但请听我说。</p><p>如果将1924年的记录与2016年的记录进行比较，那些奥林匹克运动员甚至不会成为他们的国家队。这就是今天运动员的表现更好，更快，更强。</p><p>1924年夏季奥运会男子100米短跑结果</p><p><img src="/Jenkins/主流CI-CD工具比较：Jenkins-vs-Bamboo-vsTeamcity/1.png" alt="img"></p><p>2016年美国奥运选拔赛男子100米春季成绩。</p><p>大多数这种改进是更好的表现技巧和练习方案的结果。这是我们回到CI / CD的地方：部署软件的旧方式就像1924年试图在21世纪竞争的奥运选手。没有成功的机会。你会被留在尘土中。</p><p><a href="https://stackify.com/continuous-delivery-vs-continuous-deployment-vs-continuous-integration/" target="_blank" rel="noopener">持续集成和持续交付</a>是当今软件部署的最佳实践。<strong>这些技术可帮助您更快地部署更好的软件，减少错误并提供更快的反馈循环。</strong>这对公司，客户和开发人员来说是一个双赢的局面。所需要的只是一套工具来实现它。</p><p>我们将看看今天市场上的3种顶级CI / CD工具：Jenkins，TeamCity和Bamboo。在本文结束时，您应该有信心为您的团队选择一个工具。如果您已经使用其中一种工具并希望进行更改，那么本文将为您提供做出正确决策所需的洞察力。</p><p>在我们进入下降之前，让我们简要介绍一下每个工具的基础知识。</p><h3 id="Jenkins是什么？"><a href="#Jenkins是什么？" class="headerlink" title="Jenkins是什么？"></a>Jenkins是什么？</h3><p><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a>是当今市场上最受欢迎的开源CI / CD工具。Jenkins允许开发人员在将代码提交到源存储库后自动构建，集成和测试代码。这使开发人员能够快速捕获错误并最终部署得更快。</p><p>最初创建的是用于Java应用程序的构建自动化工具，它已经发展成为具有1400多个其他软件工具插件的多方面平台。据<a href="https://www.infoworld.com/article/3239666/devops/what-is-jenkins-the-ci-server-explained.html" target="_blank" rel="noopener">InfoWorld称</a>，这些插件将Jenkins扩展到五个领域：平台，UI管理，源代码管理和构建管理。</p><h3 id="什么是Bamboo？"><a href="#什么是Bamboo？" class="headerlink" title="什么是Bamboo？"></a>什么是Bamboo？</h3><p><a href="https://www.atlassian.com/software/bamboo" target="_blank" rel="noopener">Bamboo</a>是<a href="https://www.atlassian.com/" target="_blank" rel="noopener">Atlassian</a>的CI / CD服务器。与其他CI / CD服务器一样，Bamboo允许开发人员自动构建，集成和测试源代码，然后准备应用程序以进行部署。Bamboo还可以与Atlassian的其他工具（如Jira（项目管理）和Hipchat（团队沟通））无缝协作。</p><h3 id="什么是TeamCity？"><a href="#什么是TeamCity？" class="headerlink" title="什么是TeamCity？"></a>什么是TeamCity？</h3><p><a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">TeamCity</a>是另一个商业CI / CD服务器，这次来自<a href="https://www.jetbrains.com/" target="_blank" rel="noopener">JetBrains</a>公司。它以其极其简单的设置和漂亮的用户界面而闻名。它具有开箱即用的强大功能和不断增长的插件生态系统。</p><h3 id="CI-CD工具Throwdown"><a href="#CI-CD工具Throwdown" class="headerlink" title="CI / CD工具Throwdown"></a>CI / CD工具Throwdown</h3><p>女士们，先生们，为主要景点做好准备。现在是时候让这些CI / CD工具发出隆隆声了！我们将查看CI / CD最重要的属性，并了解这些工具如何叠加。到本节结束时，您将确切知道哪种CI / CD工具适合您。</p><p>在我们看看这些工具的不同之处之前，重要的是要指出它们是如何相似的。</p><p>Jenkins，TeamCity和Bamboo都是持续集成，自动构建，自动化测试和持续交付的绝佳工具。虽然工具之间的集成数量不同，但它们都提供了进一步扩展其功能的集成。这三者也提供了很好的支持和文档，但同样在深度和质量上也存在差异。</p><p>简而言之，我们比较这些工具的原因是它们是商业中最好的。</p><p>好的，足够的细节。让我们隆隆声！</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/Jenkins/主流CI-CD工具比较：Jenkins-vs-Bamboo-vsTeamcity/2.png" alt="CI / CD表的功能和优点"></h3><h3 id="开源与商业"><a href="#开源与商业" class="headerlink" title="开源与商业"></a>开源与商业</h3><p>Jenkins是一个由世界各地的开发人员支持的开源项目。Bamboo和TeamCity都是由其母公司开发和维护的商业工具。用户最大的不同之处在于Jenkins周围的社区规模与其他两个工具相比。</p><h3 id="易于设置和使用"><a href="#易于设置和使用" class="headerlink" title="易于设置和使用"></a>易于设置和使用</h3><p>TeamCity可以轻松设置和使用。它以其开箱即用的可用性而闻名，尤其是其安全的默认配置。它还拥有华丽的用户界面，使CI新手更容易陷入困境。Bamboo具有可比性且易于使用，但用户界面并不是那么漂亮，而<a href="https://www.g2crowd.com/compare/bamboo-vs-teamcity" target="_blank" rel="noopener">G2 Crowd</a>将TeamCity列为高于Bamboo的“易于安装”。</p><p>Jenkins在这一类别中没有TeamCity和Bamboo。Jenkins的UI是一个更古老的学校，但新的Blue Ocean界面是一个重大升级。尽管如此，开源软件本身具有较低的可用性和易于设置。</p><h3 id="开箱即用的功能"><a href="#开箱即用的功能" class="headerlink" title="开箱即用的功能"></a>开箱即用的功能</h3><p>TeamCity的自带<a href="https://www.jetbrains.com/teamcity/features/" target="_blank" rel="noopener">堆叠</a>开箱，具有优良的建设历史，源头控制，建立连锁的工具。Bamboo具有较少的开箱即用功能，但与Atlassian的其他工具堆本身集成。这使Bamboo感觉功能更丰富，而不具备自身功能。Jenkins是三者中功能最稀疏的工具，但它可以通过庞大的插件生态系统弥补它，我们将在下面讨论。</p><h3 id="集成和插件"><a href="#集成和插件" class="headerlink" title="集成和插件"></a>集成和插件</h3><p>在集成和插件方面，竞争甚至不是很接近。Jenkins拥有庞大的插件生态系统，可实现前所未有的自定义和可扩展性。Bamboo和TeamCity正在慢慢增长他们的生态系统，但按照这个速度，他们可能永远不会赶上。</p><h3 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h3><p>作为一个开源项目，Jenkins拥有一个庞大而有用的贡献者社区，可以为彼此提供支持。因此，Jenkins拥有大量文档，但您只需自己梳理文档即可学习或解决问题。另一方面，Bamboo和TeamCity提供其母公司以及不断增长的用户社区的专业支持。Bamboo和TeamCity用户可以找到来自企业的实际支持以及来自社区的众包支持。</p><h3 id="在云上运行？"><a href="#在云上运行？" class="headerlink" title="在云上运行？"></a>在云上运行？</h3><p>许多中小型软件团队专门在云基础架构上运行。因此，当Atlassian停止使用Bamboo云时，一些<a href="https://community.atlassian.com/t5/Questions/Bamboo-Cloud-end-of-life/qaq-p/450934" target="_blank" rel="noopener">Bamboo用户</a>感到困惑，迫使团队在内部运行它。他们用<a href="https://bitbucket.org/product/features/pipelines" target="_blank" rel="noopener">BitBucket Pipelines</a>取代了这项服务，但很多人认为它不是一个完美的替代品。Jenkins和TeamCity仍可在云服务器上运行。</p><h3 id="价钱"><a href="#价钱" class="headerlink" title="价钱"></a>价钱</h3><p>作为开源软件，Jenkins完全免费使用，无论您的规模如何。TeamCity提供了一个相当实用的免费版本，可为您提供100个构建配置和无限构建。之后，定价从每年299美元起。</p><p>Bamboo是最昂贵的工具。它的起价仅为10美元，但这个价格的体验非常有限。对于整个体验，您必须为一个远程代理一次性支付880美元的<a href="https://www.atlassian.com/licensing/bamboo" target="_blank" rel="noopener">Bamboo</a>费用。</p><h2 id="哪种CI-CD工具最适合您？"><a href="#哪种CI-CD工具最适合您？" class="headerlink" title="哪种CI / CD工具最适合您？"></a>哪种CI / CD工具最适合您？</h2><p>显然，这次失败的赢家是一个折腾。要选择正确的CI / CD工具，您需要仔细查看预算，内部资源以及学习和设置所需的时间。如果你有DIY的态度并想要最大的功能，那么Jenkins可能就是你的工具。如果您更喜欢更简单的用户体验以及与现有技术堆栈集成的工具，请查看Bamboo。为了获得漂亮的界面和出色的开箱即用功能，TeamCity是您的最佳选择。</p><p>请记住，您的CI / CD工具只是赢得软件开发竞赛所需的工具之一。<a href="https://stackify.com/software-deployment-tools/" target="_blank" rel="noopener">部署</a>和<a href="https://stackify.com/application-performance-management-tools/" target="_blank" rel="noopener">应用程序监视</a>是敏捷开发的同等重要元素。永远不要满足你的过程; 不断探索升级技术和实践的方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你有没有看过1924年的奥运世界纪录？我知道你在这里可以获得一个很好的CI / CD工具，但请听我说。&lt;/p&gt;
&lt;p&gt;如果将1924年的记录与2016年的记录进行比较，那些奥林匹克运动员甚至不会成为他们的国家队。这就是今天运动员的表现更好，更快，更强。&lt;/p&gt;
&lt;p&gt;192
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="CI" scheme="http://blog.ozairs.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Terraform简介</title>
    <link href="http://blog.ozairs.com/Terraform/Terraform%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.ozairs.com/Terraform/Terraform简介/</id>
    <published>2019-03-30T05:24:43.000Z</published>
    <updated>2019-03-30T06:36:19.919Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca#.b6sun4nkn" target="_blank" rel="noopener">Terraform</a>系列<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca#.b6sun4nkn" target="_blank" rel="noopener">综合指南的</a>第2部分。在第1部分中，我们解释了<a href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c#.63ls7fpkq" target="_blank" rel="noopener">为什么我们选择Terraform作为我们选择的IAC工具而不是Chef，Puppet，Ansible，SaltStack或CloudFormation</a>。在这篇文章中，我们将介绍如何使用Terraform定义和管理基础架构的基础知识。</p><p>该<a href="https://www.terraform.io/intro/getting-started/install.html" target="_blank" rel="noopener">官员Terraform入门文档</a>不会引入Terraform的各个要素（即资源，输入变量，输出变量等）的一个很好的工作，所以在本指南中，我们将重点放在如何把这些元素结合在一起创建一个相当现实的例子。特别是，我们将在集群中的AWS上配置多个服务器，并部署负载均衡器以在该集群中分配负载。您将在此示例中创建的基础结构是运行可扩展，高可用性Web服务和微服务的基本起点。</p><p>本指南面向AWS和Terraform新手，所以如果您以前没有使用过任何一个，请不要担心。我们将逐步指导您完成整个过程：</p><ol><li>设置您的AWS账户</li><li>安装Terraform</li><li>部署单个服务器</li><li>部署单个Web服务器</li><li>部署Web服务器集群</li><li>部署负载均衡器</li><li>清理</li></ol><p>您可以在以下<a href="https://github.com/gruntwork-io/intro-to-terraform" target="_blank" rel="noopener">网址</a>找到以下示例的完整示例代码：<a href="https://github.com/gruntwork-io/intro-to-terraform" target="_blank" rel="noopener">https</a>：<a href="https://github.com/gruntwork-io/intro-to-terraform" target="_blank" rel="noopener">//github.com/gruntwork-io/intro-to-terraform</a>。请注意，所有代码示例都是为Terraform 0.7.x编写的。</p><h3 id="设置您的AWS账户"><a href="#设置您的AWS账户" class="headerlink" title="设置您的AWS账户"></a>设置您的AWS账户</h3><p>Terraform可以为许多不同类型的云提供商提供基础架构，包括AWS，Azure，Google Cloud，DigitalOcean <a href="https://www.terraform.io/docs/providers/index.html" target="_blank" rel="noopener">等等</a>。在本教程中，我们选择了<a href="https://aws.amazon.com/" target="_blank" rel="noopener">Amazon Web Services（AWS），</a>因为：</p><ul><li>它提供了大量可靠且可扩展的云托管服务，包括<a href="https://aws.amazon.com/ec2/" target="_blank" rel="noopener">弹性计算云（EC2）</a>，<a href="https://aws.amazon.com/autoscaling/" target="_blank" rel="noopener">Auto Scaling组（ASG）</a>和<a href="https://aws.amazon.com/elasticloadbalancing/" target="_blank" rel="noopener">Elastic Load Balancing（ELB）</a>。如果您发现AWS术语令人困惑，请务必以<a href="https://www.expeditedssl.com/aws-in-plain-english" target="_blank" rel="noopener">简明英语</a>查看<a href="https://www.expeditedssl.com/aws-in-plain-english" target="_blank" rel="noopener">AWS</a>。</li><li>到目前为止，AWS是<a href="https://www.srgresearch.com/articles/aws-remains-dominant-despite-microsoft-and-google-growth-surges" target="_blank" rel="noopener">最受欢迎的云基础架构提供商</a>。</li><li>AWS提供了一个丰富的<a href="https://aws.amazon.com/free/" target="_blank" rel="noopener">免费套餐</a>，允许您<a href="https://aws.amazon.com/free/" target="_blank" rel="noopener">免费</a>运行所有这些示例。</li></ul><p>首次注册AWS时，您最初以<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_root-user.html" target="_blank" rel="noopener">root用户</a>身份登录。此用户帐户具有对所有内容的访问权限，因此从安全角度来看，我们建议<em>仅</em>使用它来创建权限更有限的其他用户帐户（请参阅<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html" target="_blank" rel="noopener">IAM最佳实践</a>）。要创建更有限的用户帐户，请转到<a href="https://console.aws.amazon.com/iam/home?region=us-east-1#home" target="_blank" rel="noopener">身份和访问管理（IAM）控制台</a>，单击“用户”，然后单击蓝色的“创建新用户”按钮。输入用户的名称，并确保选中“为每个用户生成访问密钥”：</p><p><img src="/Terraform/Terraform简介/1.png" alt="img"></p><p>单击“创建”按钮，您将能够看到该用户的安全凭证，其中包括访问密钥ID和秘密访问密钥。你必须立即保存这些，因为它们永远不会再显示。我们建议将它们存储在安全的地方（例如密钥管理器，如Keychain或1Password），这样您可以在本教程中稍后使用它们。</p><p><img src="/Terraform/Terraform简介/2.png" alt="img"></p><p>将凭据保存在安全的地方。切勿与任何人分享。别担心，上面截图中的内容是假的。</p><p>保存凭据后，单击“关闭”（两次），您将进入用户列表。单击刚刚创建的用户，然后选择“权限”选项卡。默认情况下，新的IAM用户无权在AWS账户中执行任何操作。为了能够将Terraform用于本教程中的示例，请添加AmazonEC2FullAccess权限（<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html" target="_blank" rel="noopener">在此处</a>了解有关<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_managed-vs-inline.html" target="_blank" rel="noopener">托管IAM策略的</a>更多信息）：</p><p><img src="/Terraform/Terraform简介/3.png" alt="img"></p><h3 id="安装Terraform"><a href="#安装Terraform" class="headerlink" title="安装Terraform"></a>安装Terraform</h3><p>按照<a href="https://www.terraform.io/intro/getting-started/install.html" target="_blank" rel="noopener">此处</a>的<a href="https://www.terraform.io/intro/getting-started/install.html" target="_blank" rel="noopener">说明</a>安装Terraform。完成后，您应该能够运行terraform命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform </span><br><span class="line">用法：terraform [--version] [ -  help] &lt;command&gt; [args]</span><br><span class="line">（......）</span><br></pre></td></tr></table></figure><p>为了使Terraform能够在您的AWS账户中进行更改，您需要为之前创建的用户设置AWS凭证作为环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导出AWS_ACCESS_KEY_ID =（您的访问密钥ID）</span><br><span class="line">导出AWS_SECRET_ACCESS_KEY =（您的密钥访问密钥）</span><br></pre></td></tr></table></figure><h3 id="部署单个服务器"><a href="#部署单个服务器" class="headerlink" title="部署单个服务器"></a>部署单个服务器</h3><p>Terraform代码使用扩展名为“.tf”的文件中名为<a href="https://www.terraform.io/docs/configuration/syntax.html" target="_blank" rel="noopener">HCL</a>的语言编写。它是一种声明性语言，因此您的目标是描述您想要的基础架构，Terraform将弄清楚如何创建它。Terraform可以在各种平台上创建基础架构，或称为<a href="https://www.terraform.io/docs/providers/" target="_blank" rel="noopener">提供商</a>，包括AWS，Azure，Google Cloud，DigitalOcean和许多其他平台。使用Terraform的第一步通常是配置您要使用的提供程序。创建一个名为“main.tf”的文件并将以下代码放入其中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提供者“aws”&#123; </span><br><span class="line">  region =“us-east-1” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这告诉Terraform您将使用<a href="https://www.terraform.io/docs/providers/aws/" target="_blank" rel="noopener">AWS提供商</a>并希望在“us-east-1”区域部署您的基础架构（AWS在全球范围内拥有数据中心，分为<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区域</a>，以及我们-east-1是美国弗吉尼亚州数据中心的名称。您可以为<a href="https://www.terraform.io/docs/providers/aws/index.html" target="_blank" rel="noopener">AWS提供程序</a>配置其他设置，但是对于此示例，由于您已将凭据配置为环境变量，因此您只需指定该区域。</p><p>对于每个提供程序，您可以创建许多不同类型的“资源”，例如服务器，数据库和负载平衡器。在我们部署整个服务器集群之前，让我们首先弄清楚如何部署一个运行简单“Hello，World”Web服务器的服务器。在AWS lingo中，服务器称为“EC2实例”。要部署EC2实例，请将以下代码添加到main.tf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_instance”“example”&#123; </span><br><span class="line">  ami =“ami-2d39803a” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个资源指定一个类型（在本例中为“aws_instance”），一个名称（在本例中为“example”）用作Terraform代码中的标识符，以及一组特定于该资源的配置参数。该<a href="https://www.terraform.io/docs/providers/aws/r/instance.html" target="_blank" rel="noopener">aws_instance资源文件</a>列出了它所支持的所有参数。最初，您只需要设置以下内容：</p><ul><li><strong>ami</strong>：要在EC2实例上运行的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html" target="_blank" rel="noopener">Amazon Machine Image</a>。上面的示例将此参数设置为us-east-1中<a href="https://aws.amazon.com/marketplace/pp/B00JV9TBA6?ref=cns_srchrow" target="_blank" rel="noopener">Ubuntu 14.04 AMI</a>的ID 。</li><li><strong>instance_type</strong>：要运行的EC2实例的类型。每个<a href="https://aws.amazon.com/ec2/instance-types/" target="_blank" rel="noopener">EC2实例类型</a>具有不同的CPU，内存，磁盘空间和网络规格。上面的示例使用“t2.micro”，它具有1个虚拟CPU，1GB内存，并且是AWS免费层的一部分。</li></ul><p>在终端中，进入创建main.tf的文件夹，然后运行“terraform plan”命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform计划</span><br><span class="line">在计划之前刷新Terraform内存状态...</span><br><span class="line">（......）</span><br><span class="line">+ aws_instance.example </span><br><span class="line">    ami：“ami-2d39803a” </span><br><span class="line">    availability_zone：“&lt;computed&gt;” </span><br><span class="line">    ebs_block_device。＃：“&lt;computed&gt;” </span><br><span class="line">    ephemeral_block_device。＃：“&lt;computed&gt;” </span><br><span class="line">    instance_state：“&lt;computed&gt;” </span><br><span class="line">    instance_type：“t2.micro” </span><br><span class="line">    key_name：“&lt;computed&gt;” </span><br><span class="line">    network_interface_id：“&lt;computed&gt;” </span><br><span class="line">    placement_group：“&lt;computed&gt;” </span><br><span class="line">    private_dns：“&lt;computed&gt;” </span><br><span class="line">    private_ip：“&lt;computed&gt;” </span><br><span class="line">    public_dns：“&lt;computed&gt;”</span><br><span class="line">    public_ip：“&lt;computed&gt;” </span><br><span class="line">    root_block_device。＃：“&lt;computed&gt;” </span><br><span class="line">    security_groups。＃：“&lt;computed&gt;”</span><br><span class="line">    source_dest_check：“true” </span><br><span class="line">    subnet_id：“&lt;computed&gt;” </span><br><span class="line">    租期：“&lt;computed&gt;” </span><br><span class="line">    vpc_security_group_ids。＃：“&lt;计算&gt;”</span><br><span class="line">计划：1添加，0改变，0破坏。</span><br></pre></td></tr></table></figure><p>plan命令可让您在实际执行之前查看Terraform将执行的操作。这是一种很好的方法，可以在将更改释放到世界之前检查您的更改。plan命令的输出有点像diff命令的输出：将创建带有加号（+）的资源，带有减号（ - ）的资源将被删除，带有波浪号的资源将被删除符号（〜）将被修改。在上面的输出中，您可以看到Terraform正计划创建单个EC2实例，而不是其他任何内容，这正是我们想要的。</p><p>要实际创建实例，请运行“terraform apply”命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform apply </span><br><span class="line">aws_instance.example：Creating ... </span><br><span class="line">  ami：“”=&gt;“ami-2d39803a” </span><br><span class="line">  availability_zone：“”=&gt;“&lt;computed&gt;” </span><br><span class="line">  ebs_block_device。＃：“”=&gt;“&lt;computed&gt;” </span><br><span class="line">  ephemeral_block_device。＃： “”=&gt;“&lt;计算&gt;”“ </span><br><span class="line">  instance_state：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">  instance_type：”“=&gt;”t2.micro“ </span><br><span class="line">  key_name：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">  network_interface_id：”“=&gt;”&lt; computed&gt;“ </span><br><span class="line">  placement_group：”“=&gt;”&lt;computed&gt;“ </span><br><span class="line">  private_dns：“”=&gt;“&lt;计算&gt;” </span><br><span class="line">  private_ip：“”=&gt;“&lt;计算&gt;”“ </span><br><span class="line">  public_dns：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">  public_ip：”“=&gt;”&lt;计算&gt;“</span><br><span class="line">  root_block_device。＃：“”=&gt;“&lt;计算&gt;”“ </span><br><span class="line">  security_groups。＃：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">  source_dest_check：”“=&gt;”true“ </span><br><span class="line">  subnet_id：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">  租期：”“ &gt;&gt; &lt;计算&gt;“ </span><br><span class="line">  vpc_security_group_ids。＃：”“=&gt;”&lt;计算&gt;“ </span><br><span class="line">aws_instance.example：仍在创建...（已过去10秒）</span><br><span class="line">aws_instance.example：仍在创建...（已过20秒）</span><br><span class="line">aws_instance.example：创作完成</span><br><span class="line">申请完成！资源：1添加，0更改，0销毁。</span><br></pre></td></tr></table></figure><p>恭喜，您刚刚部署了Terraform服务器！要验证这一点，您可以登录<a href="https://console.aws.amazon.com/ec2/v2/home" target="_blank" rel="noopener">EC2控制台</a>，您将看到如下内容：</p><p><img src="/Terraform/Terraform简介/4.png" alt="img"></p><p>这是有效的，但这不是最激动人心的例子。首先，Instance没有名称。要添加一个，您可以向EC2实例添加<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html" target="_blank" rel="noopener">标记</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_instance”“example”&#123; </span><br><span class="line">  ami =“ami-2d39803a” </span><br><span class="line">  instance_type =“t2.micro”</span><br><span class="line">  标签&#123; </span><br><span class="line">    Name =“terraform-example” </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行计划命令以查看这将执行的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform计划</span><br><span class="line">aws_instance.example：刷新状态...（ID：i-6a7c545b）</span><br><span class="line">（......）</span><br><span class="line">~aws_instance.example </span><br><span class="line">    tags。％：“0”=&gt;“1” </span><br><span class="line">    tags.Name：“”=&gt;“terraform-example”</span><br><span class="line">计划：0添加，1更改，0销毁。</span><br></pre></td></tr></table></figure><p>Terraform会跟踪它为这组模板创建的所有资源，因此它知道您的EC2实例已经存在（注意Terraform在运行计划命令时如何说“刷新状态…”），它可以显示两者之间的差异当前部署的内容以及Terraform代码中的内容（这是使用<a href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c#.z5vvdu1q9" target="_blank" rel="noopener">声明性语言而不是程序性语言</a>的优势<a href="https://blog.gruntwork.io/why-we-use-terraform-and-not-chef-puppet-ansible-saltstack-or-cloudformation-7989dad2865c#.z5vvdu1q9" target="_blank" rel="noopener">之一</a>）。上面的差异显示Terraform想要创建一个名为“Name”的单个标签，这正是我们想要的，所以你应该再次运行“apply”命令。刷新EC2控制台时，您会看到：</p><p><img src="/Terraform/Terraform简介/5.png" alt="img"></p><h3 id="部署单个Web服务器"><a href="#部署单个Web服务器" class="headerlink" title="部署单个Web服务器"></a>部署单个Web服务器</h3><p>下一步是在此实例上运行Web服务器。在一个真实的用例中，您可能会安装一个功能齐全的Web框架，如Ruby on Rails或Django，但为了保持这个简单的示例，我们将运行一个简单的Web服务器，它始终返回文本“Hello，World”使用从<a href="https://gist.github.com/willurd/5720255" target="_blank" rel="noopener">http静态服务器单行列表中</a>借来的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃！/ bin / bash </span><br><span class="line">echo“Hello，World”&gt; index.html </span><br><span class="line">nohup busybox httpd -f -p 8080＆</span><br></pre></td></tr></table></figure><p>这是一个bash脚本，它将文本“Hello，World”写入index.html，并使用<a href="https://busybox.net/" target="_blank" rel="noopener">busybox</a>（在Ubuntu上默认安装）在端口8080上运行Web服务器，以便在URL“/”处提供该文件。我们使用<a href="https://en.wikipedia.org/wiki/Nohup" target="_blank" rel="noopener">nohup</a>包装busybox命令，以确保即使在此脚本退出后Web服务器仍在运行，并在命令末尾添加“＆”，以便Web服务器在后台进程中运行，因此脚本实际上可以退出而不是被阻止永远是由Web服务器。</p><p>如何让EC2实例运行此脚本？通常，您可以使用像<a href="https://www.packer.io/" target="_blank" rel="noopener">Packer</a>这样的工具来创建安装了Web服务器的自定义AMI ，而不是使用空的Ubuntu AMI 。但同样，为了保持这个例子的简单，我们将上面的脚本作为EC2 Instance的<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" target="_blank" rel="noopener">用户数据的</a>一部分运行，AWS将在实例启动时执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_instance”“example”&#123; </span><br><span class="line">  ami =“ami-2d39803a” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">  </span><br><span class="line">  user_data = &lt;&lt;  -  EOF </span><br><span class="line">              ＃！/ bin / bash </span><br><span class="line">              echo“Hello，World”&gt; index.html </span><br><span class="line">              nohup busybox httpd -f  - p 8080＆</span><br><span class="line">              EOF</span><br><span class="line">  标签&#123; </span><br><span class="line">    Name =“terraform-example” </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“&lt;&lt; - EOF”和“EOF”是Terraform的heredoc语法，它允许您创建多行字符串而无需将“\ n”放在所有位置（<a href="https://www.terraform.io/docs/configuration/syntax.html" target="_blank" rel="noopener">在此处</a>了解有关<a href="https://www.terraform.io/docs/configuration/syntax.html" target="_blank" rel="noopener">Terraform语法的</a>更多信息）。</p><p>在此Web服务器工作之前，您需要再做一件事。默认情况下，AWS不允许来自EC2实例的任何传入或传出流量。要允许EC2实例在端口8080上接收流量，您需要创建一个<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html" target="_blank" rel="noopener">安全组</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_security_group”“instance”&#123; </span><br><span class="line">  name =“terraform-example-instance”</span><br><span class="line">  ingress &#123; </span><br><span class="line">    from_port = 8080 </span><br><span class="line">    to_port = 8080 </span><br><span class="line">    protocol =“tcp” </span><br><span class="line">    cidr_blocks = [“0.0.0.0/0”] </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个名为<a href="https://www.terraform.io/docs/providers/aws/r/security_group.html" target="_blank" rel="noopener">aws_security_group</a>的新资源（注意AWS提供程序的所有资源如何以“aws_”开头）并指定该组允许来自CIDR块0.0.0.0/0的端口8080上的传入TCP请求。<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR块</a>是指定IP地址范围的简明方法。例如，10.0.0.0/24的CIDR块表示10.0.0.0和10.0.0.255之间的所有IP地址。CIDR块0.0.0.0/0是包含所有可能IP地址的IP地址范围，因此上面的安全组允许来自任何IP的端口8080上的传入请求。</p><p>请注意，在上面的安全组中，我们复制并粘贴了端口8080.为了使代码保持<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">干燥</a>并使配置代码变得容易，Terraform允许您定义<a href="https://www.terraform.io/intro/getting-started/variables.html" target="_blank" rel="noopener">输入变量</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量“server_port”&#123; </span><br><span class="line">  description =“服务器将用于HTTP请求的端口” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以通过Terraform的<a href="https://www.terraform.io/docs/configuration/interpolation.html" target="_blank" rel="noopener">插值语法</a>在安全组中使用此变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">to_port =“$ &#123;var.server_port&#125;”</span><br></pre></td></tr></table></figure><p>您还可以在EC2实例的user_data中使用相同的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup busybox httpd -f -p“$ &#123;var.server_port&#125;”＆</span><br></pre></td></tr></table></figure><p>如果您现在运行计划或应用命令，Terraform将提示您输入server_port变量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform plan </span><br><span class="line">var.server_port </span><br><span class="line">  服务器将用于HTTP请求的端口</span><br><span class="line">输入值：8080</span><br></pre></td></tr></table></figure><p>为变量提供值的另一种方法是使用“-var”命令行选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform plan -var server_port =“8080”</span><br></pre></td></tr></table></figure><p>如果您不希望每次都手动输入端口，则可以将默认值指定为变量声明的一部分（请注意，仍可通过“-var”命令行选项覆盖此默认值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量“server_port”&#123; </span><br><span class="line">  description =“服务器将用于HTTP请求的端口” </span><br><span class="line">  default = 8080 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要做的事情是：您需要告诉EC2实例实际使用新的安全组。为此，您需要将安全组的ID传递到aws_instance资源的vpc_security_group_ids参数中。你怎么得到这个ID？</p><p>在Terraform中，每个资源都具有可以使用与插值相同的语法引用的属性。您可以在每个资源的文档中找到属性列表。例如，<a href="https://www.terraform.io/docs/providers/aws/r/security_group.html#attributes-reference" target="_blank" rel="noopener">aws_security_group属性</a>包括安全组的ID，您可以在EC2实例中引用该ID，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vpc_security_group_ids = [“$ &#123;aws_security_group.instance.id&#125;”]</span><br></pre></td></tr></table></figure><p>语法为“$ {TYPE.NAME.ATTRIBUTE}”。当一个资源引用另一个资源时，您将创建一个<a href="https://www.terraform.io/intro/getting-started/dependencies.html" target="_blank" rel="noopener">隐式依赖项</a>。Terraform解析这些依赖关系，从它们构建依赖关系图，并使用它来自动确定它应该以什么顺序创建资源（例如Terraform知道它需要在将其与EC2实例一起使用之前创建安全组）。实际上，Terraform将尽可能并行地创建尽可能多的资源，这意味着它可以非常快速地应用您的更改。这就是声明性语言的美妙之处：你只需指定你想要的东西，Terraform就会找出实现它的最有效方法。</p><p>如果运行计划命令，您将看到Terraform想要用具有新用户数据的新EC2实例（“ - / +”表示“替换”）替换原始EC2实例并添加安全组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform计划</span><br><span class="line">（......）</span><br><span class="line">-  / + aws_instance.example </span><br><span class="line">    ami：“ami-2d39803a”=&gt;“ami-2d39803a” </span><br><span class="line">    instance_state：“running”=&gt;“&lt;computed&gt;” </span><br><span class="line">    instance_type：“t2.micro”=&gt;“t2.micro” </span><br><span class="line">    security_groups。＃： “0”=&gt;“&lt;计算&gt;” </span><br><span class="line">    vpc_security_group_ids。＃：“1”=&gt;“&lt;计算&gt;”</span><br><span class="line">（......）</span><br><span class="line">+ aws_security_group.instance </span><br><span class="line">    描述：“由Terraform管理” </span><br><span class="line">    出口。＃：“&lt;计算&gt;” </span><br><span class="line">    入口。＃：“1” </span><br><span class="line">    ingress.516175195.cidr_blocks。＃：“1” </span><br><span class="line">    ingress.516175195.cidr_blocks.0：“0.0.0.0 / 0“ </span><br><span class="line">    ingress.516175195.from_port：”8080“ </span><br><span class="line">    ingress.516175195.protocol：”tcp“ </span><br><span class="line">    ingress.516175195.security_groups。＃：”0“ </span><br><span class="line">    ingress.516175195.self：”false“ </span><br><span class="line">    ingress.516175195.to_port：”8080“ </span><br><span class="line">    owner_id：“&lt;计算&gt;” </span><br><span class="line">    vpc_id：“&lt;计算&gt;”</span><br><span class="line">计划：2添加，0改变，1破坏。</span><br></pre></td></tr></table></figure><p>这正是我们想要的，所以再次运行apply命令，您将看到新的EC2实例部署：</p><p><img src="/Terraform/Terraform简介/6.png" alt="img"></p><p>在屏幕底部的描述面板中，您还将看到此EC2实例的公共IP地址。给它一两分钟启动，然后尝试在端口8080处卷曲此IP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl http：// &lt;EC2_INSTANCE_PUBLIC_IP&gt;：8080 </span><br><span class="line">Hello，World</span><br></pre></td></tr></table></figure><p>耶，一个工作的网络服务器！但是，必须手动在EC2控制台周围找到这个IP地址并不好玩。幸运的是，您可以通过指定<a href="https://www.terraform.io/intro/getting-started/outputs.html" target="_blank" rel="noopener">输出变量</a>来做得更好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出“public_ip”&#123; </span><br><span class="line">  value =“ $ &#123;aws_instance.example.public_ip &#125;” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次使用插值语法来引用aws_instance资源的public_ip属性。如果再次运行apply命令，Terraform将不会应用任何更改（因为您没有更改任何资源），但它会显示新输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform apply </span><br><span class="line">aws_security_group.instance：刷新状态...（ID：sg-db91dba1）</span><br><span class="line">aws_instance.example：刷新状态...（ID：i-61744350）</span><br><span class="line">申请完成！资源：0添加，0更改，0销毁。</span><br><span class="line">输出：</span><br><span class="line">public_ip = 54.174.13.5</span><br></pre></td></tr></table></figure><p>输入和输出变量是Terraform强大功能的重要组成部分，特别是与模块结合使用时，我们将在第4部分中讨论的主题，<a href="https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d" target="_blank" rel="noopener">如何使用Terraform模块创建可重用的基础架构</a>。</p><h3 id="部署Web服务器集群"><a href="#部署Web服务器集群" class="headerlink" title="部署Web服务器集群"></a>部署Web服务器集群</h3><p>运行单个服务器是一个良好的开端，但在现实世界中，单个服务器是单点故障。如果该服务器崩溃，或者由于流量太大而导致服务器不堪重负，则用户将无法再访问您的站点。解决方案是运行服务器群集，绕过服务器路由，并根据流量调整群集大小（有关详细信息，请查看<a href="https://www.airpair.com/aws/posts/building-a-scalable-web-app-on-amazon-web-services-p1" target="_blank" rel="noopener">在Amazon Web Services上构建可扩展Web应用程序的综合指南</a>）。</p><p>手动管理这样的集群是很多工作。幸运的是，您可以让AWS使用<a href="https://aws.amazon.com/autoscaling/" target="_blank" rel="noopener">Auto Scaling Group（ASG）来处理它</a>。ASG可以自动启动EC2实例集群，监控其运行状况，自动重启故障节点，并根据需求调整集群大小。</p><p>创建ASG的第一步是创建<a href="http://docs.aws.amazon.com/autoscaling/latest/userguide/LaunchConfiguration.html" target="_blank" rel="noopener">启动配置</a>，该<a href="http://docs.aws.amazon.com/autoscaling/latest/userguide/LaunchConfiguration.html" target="_blank" rel="noopener">配置</a>指定如何在ASG中配置每个EC2实例。从早期部署单个EC2实例开始，您已经确切地知道如何配置它，并且您可以在<a href="https://www.terraform.io/docs/providers/aws/r/launch_configuration.html" target="_blank" rel="noopener">aws_launch_configuration</a>资源中重用几乎完全相同的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_launch_configuration”“example”&#123; </span><br><span class="line">  image_id =“ami-2d39803a” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">  security_groups = [“$ &#123;aws_security_group.instance.id&#125;”]</span><br><span class="line">  user_data = &lt;&lt;  -  EOF </span><br><span class="line">              ＃！/ bin / bash </span><br><span class="line">              echo“Hello，World”&gt; index.html </span><br><span class="line">              nohup busybox httpd -f -p“$ &#123;var.server_port&#125;”＆</span><br><span class="line">              EOF</span><br><span class="line">  生命周期&#123; </span><br><span class="line">    create_before_destroy = true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一新添加的是生命周期块，这是使用ASG启动配置所必需的。您可以向任何Terraform资源添加<a href="https://www.terraform.io/docs/configuration/resources.html#lifecycle" target="_blank" rel="noopener">生命周期块</a>以自定义其生命周期行为。其中一个可用的生命周期设置是create_before_destroy，它告诉Terraform在销毁原始文件之前始终创建替换资源（例如，在替换EC2实例时，始终在删除旧实例之前创建新实例）。</p><p>create_before_destroy参数的捕获是，如果在资源X上将其设置为true，则还必须在X依赖的每个资源上将其设置为true。对于启动配置，这意味着您需要在安全组上将create_before_destroy设置为true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_security_group”“instance”&#123; </span><br><span class="line">  name =“terraform-example-instance”</span><br><span class="line">  ingress &#123; </span><br><span class="line">    from_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">    to_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">    protocol =“tcp” </span><br><span class="line">    cidr_blocks = [“0.0.0.0/0”] </span><br><span class="line">  &#125;</span><br><span class="line">  生命周期&#123; </span><br><span class="line">    create_before_destroy = true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，您可以使用<a href="https://www.terraform.io/docs/providers/aws/r/autoscaling_group.html" target="_blank" rel="noopener">aws_autoscaling_group资源</a>创建ASG ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_autoscaling_group”“example”&#123; </span><br><span class="line">  launch_configuration =“$ &#123;aws_launch_configuration.example.id&#125;”</span><br><span class="line">  min_size = 2 </span><br><span class="line">  max_size = 10</span><br><span class="line">  tag &#123; </span><br><span class="line">    key =“Name” </span><br><span class="line">    value =“terraform-asg-example” </span><br><span class="line">    propagate_at_launch = true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此ASG将运行2到10个EC2实例（初始启动默认为2），每个实例都标记为“terraform-example”。每个EC2实例的配置由您之前创建的启动配置决定，我们使用Terraform的插值语法进行参考。</p><p>要使此ASG正常工作，您需要再指定一个参数：availability_zones。此参数指定应部署EC2实例的<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">可用区</a>（AZ）。每个AZ代表一个独立的AWS数据中心，因此通过跨多个AZ部署实例，即使某些AZ发生故障，也可确保您的服务可以继续运行。您可以对AZ列表进行硬编码（例如将其设置为[“us-east-1a”，“us-east-1b”]），但每个AWS账户都可以访问一组略有不同的AZ，因此您可以使用<a href="https://www.terraform.io/docs/providers/aws/d/availability_zones.html" target="_blank" rel="noopener">aws_availability_zones数据源</a>获取您帐户的确切列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据“aws_availability_zones”“全部”&#123;&#125;</span><br></pre></td></tr></table></figure><p>甲<a href="https://www.terraform.io/docs/configuration/data-sources.html" target="_blank" rel="noopener">数据源</a>表示一块的只读信息被取出从提供者（在此情况下，AWS）每次运行Terraform时间。除可用区域外，还有数据源可查找<a href="https://www.terraform.io/docs/providers/aws/d/ami.html" target="_blank" rel="noopener">AMI ID</a>，<a href="https://www.terraform.io/docs/providers/aws/d/ip_ranges.html" target="_blank" rel="noopener">IP地址范围</a>和<a href="https://www.terraform.io/docs/providers/aws/d/caller_identity.html" target="_blank" rel="noopener">当前用户的身份</a>。将数据源添加到Terraform模板不会创建任何新内容; 它只是一种检索动态数据的方法。</p><p>要使用数据源，请使用标准插值语法引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_autoscaling_group”“example”&#123; </span><br><span class="line">  launch_configuration =“$ &#123;aws_launch_configuration.example.id&#125;” </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”]</span><br><span class="line">  min_size = 2 </span><br><span class="line">  max_size = 10</span><br><span class="line">  tag &#123; </span><br><span class="line">    key =“Name” </span><br><span class="line">    value =“terraform-asg-example” </span><br><span class="line">    propagate_at_launch = true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署负载均衡器"><a href="#部署负载均衡器" class="headerlink" title="部署负载均衡器"></a>部署负载均衡器</h3><p>在启动ASG之前，还有一个问题需要解决：现在您有许多实例，您需要一个负载均衡器来分配所有实例的流量。创建高可用性和可伸缩性的负载均衡器需要大量工作。您可以再次使用<a href="https://aws.amazon.com/elasticloadbalancing/" target="_blank" rel="noopener">Elastic Load Balancer（ELB）</a>让AWS为您处理。要使用Terraform创建ELB，请使用<a href="https://www.terraform.io/docs/providers/aws/r/elb.html" target="_blank" rel="noopener">aws_elb资源</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_elb”“example”&#123; </span><br><span class="line">  name =“terraform-asg-example” </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会创建一个ELB，可以在您帐户中的所有AZ中使用。当然，在你告诉ELB如何路由请求之前，上面的定义并不多。为此，您添加一个或多个“侦听器”，指定ELB应侦听的端口以及应将请求路由到的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_elb”“example”&#123; </span><br><span class="line">  name =“terraform-asg-example” </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”]</span><br><span class="line">  listener &#123; </span><br><span class="line">    lb_port = 80 </span><br><span class="line">    lb_protocol =“http” </span><br><span class="line">    instance_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">    instance_protocol =“http” </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们告诉ELB在端口80（HTTP的默认端口）上接收HTTP请求，并将它们路由到ASG中Instances使用的端口。请注意，默认情况下，ELB不允许任何传入或传出流量（就像EC2实例一样），因此您需要添加一个安全组以明确允许端口80上的传入请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_security_group”“elb”&#123; </span><br><span class="line">  name =“terraform-example-elb”</span><br><span class="line">  ingress &#123; </span><br><span class="line">    from_port = 80 </span><br><span class="line">    to_port = 80 </span><br><span class="line">    protocol =“tcp” </span><br><span class="line">    cidr_blocks = [“0.0.0.0/0”] </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，您需要通过添加security_groups参数告诉ELB使用此安全组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_elb”“example”&#123; </span><br><span class="line">  name =“terraform-asg-example” </span><br><span class="line">  security_groups = [“$ &#123;aws_security_group.elb.id&#125;”] </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”]</span><br><span class="line">  listener &#123; </span><br><span class="line">    lb_port = 80 </span><br><span class="line">    lb_protocol =“http” </span><br><span class="line">    instance_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">    instance_protocol =“http” </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ELB还有另外一个漂亮的技巧：它可以定期检查你的EC2实例的运行状况，如果一个实例不健康，它会自动停止将流量路由到它。让我们添加一个HTTP运行状况检查，其中ELB将每隔30秒向每个EC2实例的“/”URL发送一个HTTP请求，并且只有在实例响应200 OK时才将其标记为正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_elb”“example”&#123; </span><br><span class="line">  name =“terraform-asg-example” </span><br><span class="line">  security_groups = [“$ &#123;aws_security_group.elb.id&#125;”] </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”]</span><br><span class="line">  health_check &#123; </span><br><span class="line">    healthy_threshold = 2 </span><br><span class="line">    unhealthy_threshold = 2 </span><br><span class="line">    timeout = 3 </span><br><span class="line">    interval = 30 </span><br><span class="line">    target =“HTTP：$ &#123;var.server_port&#125; /” </span><br><span class="line">  &#125;</span><br><span class="line">  listener &#123; </span><br><span class="line">    lb_port = 80 </span><br><span class="line">    lb_protocol =“http” </span><br><span class="line">    instance_port =“$ &#123;var.server_port&#125;” </span><br><span class="line">    instance_protocol =“http” </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要允许这些运行状况检查请求，您需要修改ELB的安全组以允许出站请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_security_group”“elb”&#123; </span><br><span class="line">  name =“terraform-example-elb”</span><br><span class="line">  出口&#123; </span><br><span class="line">    from_port = 0 </span><br><span class="line">    to_port = 0 </span><br><span class="line">    protocol =“ -  1” </span><br><span class="line">    cidr_blocks = [“0.0.0.0/0”] </span><br><span class="line">  &#125;</span><br><span class="line">  ingress &#123; </span><br><span class="line">    from_port = 80 </span><br><span class="line">    to_port = 80 </span><br><span class="line">    protocol =“tcp” </span><br><span class="line">    cidr_blocks = [“0.0.0.0/0”] </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ELB如何知道向哪些EC2实例发送请求？您可以使用ELB的实例参数将EC2实例的静态列表附加到ELB，但是使用ASG，实例将一直动态启动和终止，因此无法工作。相反，您可以使用aws_autoscaling_group资源的load_balancers参数告诉ASG在该实例启动时注册ELB中的每个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_autoscaling_group”“example”&#123; </span><br><span class="line">  launch_configuration =“$ &#123;aws_launch_configuration.example.id&#125;” </span><br><span class="line">  availability_zones = [“$ &#123;data.aws_availability_zones.all.names&#125;”]</span><br><span class="line">  min_size = 2 </span><br><span class="line">  max_size = 10</span><br><span class="line">  load_balancers = [“$ &#123;aws_elb.example.name&#125;”] </span><br><span class="line">  health_check_type =“ELB”</span><br><span class="line">  tag &#123; </span><br><span class="line">    key =“Name” </span><br><span class="line">    value =“terraform-asg-example” </span><br><span class="line">    propagate_at_launch = true </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，我们还将ASG的health_check_type配置为“ELB”。这告诉ASG使用ELB的运行状况检查来确定实例是否健康，并在ELB将其报告为不健康时自动重启实例。</p><p>在部署负载均衡器之前要做的最后一件事：让我们将其DNS名称添加为输出，以便更容易测试事情是否正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出“elb_dns_name”&#123; </span><br><span class="line">  value =“$ &#123;aws_elb.example.dns_name&#125;” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行plan命令以验证您的更改，如果一切正常，请运行apply。应用完成后，您应该看到elb_dns_name输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">elb_dns_name = terraform-asg-example-123.us-east-1.elb.amazonaws.com</span><br></pre></td></tr></table></figure><p>复制此URL。实例启动并在ELB中显示为健康状态需要几分钟。在此期间，您可以检查已部署的内容。打开<a href="https://console.aws.amazon.com/ec2/autoscaling/home" target="_blank" rel="noopener">EC2控制台</a>的<a href="https://console.aws.amazon.com/ec2/autoscaling/home" target="_blank" rel="noopener">ASG部分</a>，您应该看到已创建ASG：</p><p><img src="/Terraform/Terraform简介/7.png" alt="img"></p><p>如果切换到Instances选项卡，您将在启动过程中看到两个实例：</p><p><img src="/Terraform/Terraform简介/8.png" alt="img"></p><p>最后，如果切换到Load Balancers选项卡，您将看到您的ELB：</p><p><img src="/Terraform/Terraform简介/9.png" alt="img"></p><p>等待“状态”指示符说“服务中有2个实例中的2个”。这通常需要1-2分钟。看到之后，测试先前复制的elb_dns_name输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl http：// &lt;elb_dns_name&gt; </span><br><span class="line">Hello，World</span><br></pre></td></tr></table></figure><p>成功！ELB将流量路由到您的EC2实例。每次点击URL时，它都会选择不同的实例来处理请求。您现在拥有一个完全可用的Web服务器集群！提醒一下，上面示例的完整示例代码位于：<a href="https://github.com/gruntwork-io/intro-to-terraform" target="_blank" rel="noopener">https</a>：<a href="https://github.com/gruntwork-io/intro-to-terraform" target="_blank" rel="noopener">//github.com/gruntwork-io/intro-to-terraform</a>。</p><p>此时，您可以看到群集如何响应启动新实例或关闭旧实例。例如，转到Instances选项卡，通过选中其复选框，选择顶部的“Actions”按钮，然后将“Instance State”设置为“Terminate”来终止其中一个Instances。继续测试ELB URL和你即使在终止实例时，也应该为每个请求获得“200 OK”，因为ELB将自动检测到Instance已关闭并停止路由到它。更有趣的是，在实例关闭后的短时间内，ASG将检测到正在运行的实例少于2个，并自动启动一个新实例来替换它（自我修复！）。您还可以通过更改min_size和max_size参数或向Terraform代码添加desired_size参数来查看ASG如何调整自身大小。</p><p>当然，ASG还有许多其他方面，我们在这里没有涉及。对于实际部署，您需要将IAM角色附加到EC2实例，设置机制以使用零停机时间更新ASG中的EC2实例，并配置自动扩展策略以调整ASG的大小以响应负载。对于完全预组装，经过实战考验，文档化，生产就绪的ASG版本，以及其他类型的基础架构（如Docker集群，关系数据库，VPC等），您可能需要查看<a href="https://blog.gruntwork.io/gruntwork-infrastructure-packages-7434dc77d0b1#.luxpdx7n6" target="_blank" rel="noopener">Gruntwork基础架构包裹</a>。</p><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>当您尝试使用Terraform时，最好删除您创建的所有资源，以便AWS不会向您收取费用。由于Terraform会跟踪您创建的资源，因此清理工作变得轻而易举。您需要做的就是运行destroy命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">terraform destroy </span><br><span class="line">你真的想破坏吗？</span><br><span class="line">  Terraform将删除您的所有托管基础架构。</span><br><span class="line">  没有撤消。只接受&apos;是&apos;确认。</span><br><span class="line">输入一个值：</span><br></pre></td></tr></table></figure><p>输入“yes”并按Enter键后，Terraform将使用尽可能多的并行性构建依赖关系图并按正确的顺序删除所有资源。大约一分钟后，您的AWS账户应该再次清理。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>您现在已经掌握了如何使用Terraform的基本知识。声明性语言可以很容易地准确描述您要创建的基础结构。plan命令允许您在部署之前验证更改并捕获错误。变量，插值和依赖性允许您保持代码干燥和高效。</p><p>但是，我们只是触及了表面。在本系列的第3部分“ <a href="https://blog.gruntwork.io/how-to-manage-terraform-state-28f5697e68fa" target="_blank" rel="noopener">如何管理Terraform状态”中</a>，我们将展示Terraform如何跟踪它已经创建的基础架构，以及对如何构建Terraform代码所产生的深远影响。在本系列的第4部分中，我们将展示<a href="https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d" target="_blank" rel="noopener">如何使用Terraform模块创建可重用的基础架构</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是&lt;a href=&quot;https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca#.b6sun4nkn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Terraform
      
    
    </summary>
    
      <category term="Terraform" scheme="http://blog.ozairs.com/categories/Terraform/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker Swarm架构、特性与基本实践</title>
    <link href="http://blog.ozairs.com/Docker/Docker-Swarm%E6%9E%B6%E6%9E%84%E3%80%81%E7%89%B9%E6%80%A7%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%AE%9E%E8%B7%B5/"/>
    <id>http://blog.ozairs.com/Docker/Docker-Swarm架构、特性与基本实践/</id>
    <published>2019-03-30T04:57:09.000Z</published>
    <updated>2019-03-30T05:02:08.209Z</updated>
    
    <content type="html"><![CDATA[<p>Docker集群管理和编排的特性是通过SwarmKit进行构建的， 其中Swarm mode是Docker Engine内置支持的一种默认实现。Docker 1.12以及更新的版本，都支持Swarm mode，我们可以基于Docker Engine来构建Swarm集群，然后就可以将我们的应用服务（Application Service）部署到Swarm集群中。创建Swarm集群的方式很简单，先初始化一个Swarm集群，然后将其他的Node加入到该集群即可。本文主要基于Docker Swarm官网文档，学习总结。</p><p><strong>基本特性</strong></p><p>Docker Swarm具有如下基本特性：</p><ul><li>集群管理集成进Docker Engine</li></ul><p>使用内置的集群管理功能，我们可以直接通过Docker CLI命令来创建Swarm集群，然后去部署应用服务，而不再需要其它外部的软件来创建和管理一个Swarm集群。</p><ul><li>去中心化设计</li></ul><p>Swarm集群中包含Manager和Worker两类Node，我们可以直接基于Docker Engine来部署任何类型的Node。而且，在Swarm集群运行期间，我们既可以对其作出任何改变，实现对集群的扩容和缩容等，如添加Manager Node，如删除Worker Node，而做这些操作不需要暂停或重启当前的Swarm集群服务。</p><ul><li>声明式服务模型（Declarative Service Model）</li></ul><p>在我们实现的应用栈中，Docker Engine使用了一种声明的方式，让我们可以定义我们所期望的各种服务的状态，例如，我们创建了一个应用服务栈：一个Web前端服务、一个后端数据库服务、Web前端服务又依赖于一个消息队列服务。</p><ul><li>服务扩容缩容</li></ul><p>对于我们部署的每一个应用服务，我们可以通过命令行的方式，设置启动多少个Docker容器去运行它。已经部署完成的应用，如果有扩容或缩容的需求，只需要通过命令行指定需要几个Docker容器即可，Swarm集群运行时便能自动地、灵活地进行调整。</p><ul><li>协调预期状态与实际状态的一致性</li></ul><p>Swarm集群Manager Node会不断地监控集群的状态，协调集群状态使得我们预期状态和实际状态保持一致。例如我们启动了一个应用服务，指定服务副本为10，则会启动10个Docker容器去运行，如果某个Worker Node上面运行的2个Docker容器挂掉了，则Swarm Manager会选择集群中其它可用的Worker Node，并创建2个服务副本，使实际运行的Docker容器数仍然保持与预期的10个一致。</p><ul><li>多主机网络</li></ul><p>我们可以为待部署应用服务指定一个Overlay网络，当应用服务初始化或者进行更新时，Swarm Manager在给定的Overlay网络中为Docker容器自动地分配IP地址，实际是一个虚拟IP地址（VIP）。</p><ul><li>服务发现</li></ul><p>Swarm Manager会给集群中每一个服务分配一个唯一的DNS名称，对运行中的Docker容器进行负载均衡。我们可以通过Swarm内置的DNS Server，查询Swarm集群中运行的Docker容器状态。</p><ul><li>负载均衡</li></ul><p>在Swarm内部，可以指定如何在各个Node之间分发服务容器（Service Container），实现负载均衡。如果想要使用Swarm集群外部的负载均衡器，可以将服务容器的端口暴露到外部。</p><ul><li>安全策略</li></ul><p>在Swarm集群内部的Node，强制使用基于TLS的双向认证，并且在单个Node上以及在集群中的Node之间，都进行安全的加密通信。我们可以选择使用自签名的根证书，或者使用自定义的根CA（Root CA）证书。</p><ul><li>滚动更新（Rolling Update）</li></ul><p>对于服务需要更新的场景，我们可以在多个Node上进行增量部署更新，Swarm Manager支持通过使用Docker CLI设置一个delay时间间隔，实现多个服务在多个Node上依次进行部署。这样可以非常灵活地控制，如果有一个服务更新失败，则暂停后面的更新操作，重新回滚到更新之前的版本。</p><p><strong>基本架构</strong></p><p>Docker Swarm提供了基本的集群能力，能够使多个Docker Engine组合成一个group，提供多容器服务。Swarm使用标准的Docker API，启动容器可以直接使用docker run命令。Swarm更核心的则是关注如何选择一个主机并在其上启动容器，最终运行服务。<br>Docker Swarm基本架构，如下图所示<br><img src="/Docker/Docker-Swarm架构、特性与基本实践/1.png" alt=""></p><p>如上图所示，Swarm Node表示加入Swarm集群中的一个Docker Engine实例，基于该Docker Engine可以创建并管理多个Docker容器。其中，最开始创建Swarm集群的时候，Swarm Manager便是集群中的第一个Swarm Node。在所有的Node中，又根据其职能划分为Manager Node和Worker Node，具体分别如下所示：</p><ul><li>Manager Node</li></ul><p>Manager Node负责调度Task，一个Task表示要在Swarm集群中的某个Node上启动Docker容器，一个或多个Docker容器运行在Swarm集群中的某个Worker Node上。同时，Manager Node还负责编排容器和集群管理功能（或者更准确地说，是具有Manager管理职能的Node），维护集群的状态。需要注意的是，默认情况下，Manager Node也作为一个Worker Node来执行Task。Swarm支持配置Manager只作为一个专用的管理Node，后面我们会详细说明。</p><ul><li>Worker Node</li></ul><p>Worker Node接收由Manager Node调度并指派的Task，启动一个Docker容器来运行指定的服务，并且Worker Node需要向Manager Node汇报被指派的Task的执行状态。</p><p><strong>构建Swarm集群</strong></p><p>我们实践Swarm集群，包括三个Node，对应的主机名和IP地址分别如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`manager  192.168.1.107``worker1  192.168.1.108``worker2  192.168.1.109`</span><br></pre></td></tr></table></figure><p>首先，需要保证各个Node上，docker daemon进程已经正常启动，如果没有则执行如下命令启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`systemctl start docker`</span><br></pre></td></tr></table></figure><p>接下来就可以创建Swarm集群，创建Swarm的命令，格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm init --advertise-addr &lt;MANAGER-IP&gt;`</span><br></pre></td></tr></table></figure><p>我们在准备好的manager Node上，登录到该Node，创建一个Swarm，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm init --advertise-addr 192.168.1.107`</span><br></pre></td></tr></table></figure><p>上面<code>--advertise-addr</code>选项指定Manager Node会publish它的地址为192.168.1.107，后续Worker Node加入到该Swarm集群，必须要能够访问到Manager的该IP地址。可以看到，上述命令执行结果，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Swarm initialized: current node (5pe2p4dlxku6z2a6jnvxc4ve6) is now a manager.` `To add a worker to this swarm, run the following command:` `    ``docker swarm join \``    ``--token SWMTKN-1-4dm09nzp3xic15uebqja69o2552b75pcg7or0g9t2eld9ehqt3-1kb79trnv6fbydvl9vif3fsch \``    ``192.168.1.107:2377` `To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.`</span><br></pre></td></tr></table></figure><p>该结果中给出了后续操作引导信息，告诉我们如何将一个Worker Node加入到Swarm集群中。也可以通过如下命令，来获取该提示信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm ``join``-token worker`</span><br></pre></td></tr></table></figure><p>在任何时候，如果我们需要向已经创建的Swarm集群中增加Worker Node，只要新增一个主机（物理机、云主机等都可以），并在其上安装好Docker Engine并启动，然后执行上述docker swarm join命令，就可以加入到Swarm集群中。<br>这时，我们也可以查看当前Manager Node的基本信息，执行docker info命令，输出信息中可以看到，包含如下关于Swarm的状态信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Swarm: active`` ``NodeID: qc42f6myqfpoevfkrzmx08n0r`` ``Is Manager: true`` ``ClusterID: qi4i0vh7lgb60qxy3mdygb27f`` ``Managers: 1`` ``Nodes: 1`</span><br></pre></td></tr></table></figure><p>可以看出，目前Swarm集群只有Manager一个Node，而且状态是active。也可以在Manager Node上执行docker node ls命令查看Node状态，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS``qc42f6myqfpoevfkrzmx08n0r *  manager   Ready   Active        Leader`</span><br></pre></td></tr></table></figure><p>接下来，我们可以根据上面提示信息，我们分别在worker1、worker2两个Worker Node 上，执行命令将Worker Node加入到Swarm集群中，命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm ``join` `\``    ``--token SWMTKN-1-4dm09nzp3xic15uebqja69o2552b75pcg7or0g9t2eld9ehqt3-1kb79trnv6fbydvl9vif3fsch \``    ``192.168.1.107:2377`</span><br></pre></td></tr></table></figure><p>如果成功，可以看到成功加入Swarm集群的信息。这时，也可以在Manager Node上，查看Swarm集群的信息，示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Swarm: active`` ``NodeID: qc42f6myqfpoevfkrzmx08n0r`` ``Is Manager: true`` ``ClusterID: qi4i0vh7lgb60qxy3mdygb27f`` ``Managers: 1`` ``Nodes: 3`</span><br></pre></td></tr></table></figure><p>想要查看Swarm集群中全部Node的详细状态信息，可以执行如下所示命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node ``ls`</span><br></pre></td></tr></table></figure><p>Swarm集群Node的状态信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS``oibbiiwrgwjkw0ni38ydrfsre    worker1   Ready   Active       ``oocli2uzdt2hy6o50g5z6j7dq    worker2   Ready   Active       ``qc42f6myqfpoevfkrzmx08n0r *  manager   Ready   Active        Leader`</span><br></pre></td></tr></table></figure><p>上面信息中，AVAILABILITY表示Swarm Scheduler是否可以向集群中的某个Node指派Task，对应有如下三种状态：</p><ul><li>Active：集群中该Node可以被指派Task</li><li>Pause：集群中该Node不可以被指派新的Task，但是其他已经存在的Task保持运行</li><li>Drain：集群中该Node不可以被指派新的Task，Swarm Scheduler停掉已经存在的Task，并将它们调度到可用的Node上</li></ul><p>查看某一个Node的状态信息，可以在该Node上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node inspect self`</span><br></pre></td></tr></table></figure><p>我们在Manager Node上执行上述命令，查看的状态信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`[``    ``&#123;``        ``&quot;ID&quot;: &quot;qc42f6myqfpoevfkrzmx08n0r&quot;,``        ``&quot;Version&quot;: &#123;``            ``&quot;Index&quot;: 9``        ``&#125;,``        ``&quot;CreatedAt&quot;: &quot;2017-03-12T15:25:51.725341879Z&quot;,``        ``&quot;UpdatedAt&quot;: &quot;2017-03-12T15:25:51.84308356Z&quot;,``        ``&quot;Spec&quot;: &#123;``            ``&quot;Role&quot;: &quot;manager&quot;,``            ``&quot;Availability&quot;: &quot;active&quot;``        ``&#125;,``        ``&quot;Description&quot;: &#123;``            ``&quot;Hostname&quot;: &quot;manager&quot;,``            ``&quot;Platform&quot;: &#123;``                ``&quot;Architecture&quot;: &quot;x86_64&quot;,``                ``&quot;OS&quot;: &quot;linux&quot;``            ``&#125;,``            ``&quot;Resources&quot;: &#123;``                ``&quot;NanoCPUs&quot;: 1000000000,``                ``&quot;MemoryBytes&quot;: 1912082432``            ``&#125;,``            ``&quot;Engine&quot;: &#123;``                ``&quot;EngineVersion&quot;: &quot;17.03.0-ce&quot;,``                ``&quot;Plugins&quot;: [``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Network&quot;,``                        ``&quot;Name&quot;: &quot;bridge&quot;``                    ``&#125;,``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Network&quot;,``                        ``&quot;Name&quot;: &quot;host&quot;``                    ``&#125;,``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Network&quot;,``                        ``&quot;Name&quot;: &quot;macvlan&quot;``                    ``&#125;,``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Network&quot;,``                        ``&quot;Name&quot;: &quot;null&quot;``                    ``&#125;,``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Network&quot;,``                        ``&quot;Name&quot;: &quot;overlay&quot;``                    ``&#125;,``                    ``&#123;``                        ``&quot;Type&quot;: &quot;Volume&quot;,``                        ``&quot;Name&quot;: &quot;local&quot;``                    ``&#125;``                ``]``            ``&#125;``        ``&#125;,``        ``&quot;Status&quot;: &#123;``            ``&quot;State&quot;: &quot;ready&quot;,``            ``&quot;Addr&quot;: &quot;127.0.0.1&quot;``        ``&#125;,``        ``&quot;ManagerStatus&quot;: &#123;``            ``&quot;Leader&quot;: true,``            ``&quot;Reachability&quot;: &quot;reachable&quot;,``            ``&quot;Addr&quot;: &quot;192.168.1.107:2377&quot;``        ``&#125;``    ``&#125;``]`</span><br></pre></td></tr></table></figure><p><strong>管理Swarm Node</strong></p><p>Swarm支持设置一组Manager Node，通过支持多Manager Node实现HA。那么这些Manager Node之间的状态的一致性就非常重要了，多Manager Node的Warm集群架构，如下图所示：</p><p><img src="/Docker/Docker-Swarm架构、特性与基本实践/2.png" alt=""><br>通过上图可以看到，Swarm使用了Raft协议来保证多个Manager之间状态的一致性。基于Raft协议，Manager Node具有一定的容错功能，假设Swarm集群中有个N个Manager Node，那么整个集群可以容忍最多有(N-1)/2个节点失效。如果是一个三Manager Node的Swarm集群，则最多只能容忍一个Manager Node挂掉。<br>下面，我们按照对Node的不同操作，通过命令的方式来详细说明：</p><p><strong>（1）Node状态变更管理</strong></p><p>前面我们已经提到过，Node的AVAILABILITY有三种状态：Active、Pause、Drain，对某个Node进行变更，可以将其AVAILABILITY值通过Docker CLI修改为对应的状态即可，下面是常见的变更操作：</p><ul><li>设置Manager Node只具有管理功能</li><li>对服务进行停机维护，可以修改AVAILABILITY为Drain状态</li><li>暂停一个Node，然后该Node就不再接收新的Task</li><li>恢复一个不可用或者暂停的Node</li></ul><p>例如，将Manager Node的AVAILABILITY值修改为Drain状态，使其只具备管理功能，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node update --availability drain manager`</span><br></pre></td></tr></table></figure><p>这样，Manager Node不能被指派Task，也就是不能部署实际的Docker容器来运行服务，而只是作为管理Node的角色。</p><p><strong>（2）给Node添加标签元数据</strong></p><p>每个Node的主机配置情况可能不同，比如有的适合运行CPU密集型应用，有的适合运行IO密集型应用，Swarm支持给每个Node添加标签元数据，这样可以根据Node的标签，来选择性地调度某个服务部署到期望的一组Node上。<br>给SWarm集群中的某个Worker Node添加标签，执行如下命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node update --label-add 键名称=值`</span><br></pre></td></tr></table></figure><p>例如，worker1主机在名称为bjidc这个数据中心，执行如下命令添加标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node update --label-add datacenter=bjidc`</span><br></pre></td></tr></table></figure><p><strong>（3）Node提权/降权</strong></p><p>改变Node的角色，Worker Node可以变为Manager Node，这样实际Worker Node有工作Node变成了管理Node，对应提权操作，例如将worker1和worker2都升级为Manager Node，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node promote worker1 worker2`</span><br></pre></td></tr></table></figure><p>对上面已提权的worker1和worker2执行降权，需要执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker node demote worker1 worker2`</span><br></pre></td></tr></table></figure><p><strong>（4）退出Swarm集群</strong></p><p>如果Manager想要退出Swarm集群， 在Manager Node上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm node leave`</span><br></pre></td></tr></table></figure><p>就可以退出集群，如果集群中还存在其它的Worker Node，还希望Manager退出集群，则加上一个强制选项，命令行如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm node leave --force`</span><br></pre></td></tr></table></figure><p>同样，如果Worker想要退出Swarm集群，在Worker Node上，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker swarm node leave`</span><br></pre></td></tr></table></figure><p>即使Manager已经退出SWarm集群，执行上述命令也可以使得Worker Node退出集群，然后又可以加入到其它新建的Swarm集群中。</p><p><strong>管理服务</strong></p><p>在Swarm集群上部署服务，必须在Manager Node上进行操作。先说明一下Service、Task、Container（容器）这个三个概念的关系，如下图（出自Docker官网）非常清晰地描述了这个三个概念的含义：<br><img src="/Docker/Docker-Swarm架构、特性与基本实践/3.png" alt=""><br>在Swarm mode下使用Docker，可以实现部署运行服务、服务扩容缩容、删除服务、滚动更新等功能，下面我们详细说明。</p><p><strong>（1）创建服务</strong></p><p>创建Docker服务，可以使用docker service create命令实现，例如，我们要创建如下两个服务，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service create --replicas 1 --name myapp alpine ``ping` `shiyanjun.cn``docker service create --replicas 2 --name myredis redis`</span><br></pre></td></tr></table></figure><p>第一个命令行，从Docker镜像alpine创建了一个名称为myapp的服务，其中指定服务副本数为1，也就是启动一个Docker容器来运行该服务。第二个命令行， 创建一个Redis服务，服务副本数为2，那么会启动两个Docker容器来运行myredis服务。查看当前，已经部署启动的全部应用服务，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service ``ls`</span><br></pre></td></tr></table></figure><p>执行结果，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID            NAME     MODE        REPLICAS  IMAGE``kilpacb9uy4q  myapp    replicated  1/1       alpine:latest``vf1kcgtd5byc  myredis  replicated  2/2       redis`</span><br></pre></td></tr></table></figure><p>也可以查询指定服务的详细信息，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service ``ps` `myredis`</span><br></pre></td></tr></table></figure><p>查看结果信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID            NAME       IMAGE  NODE     DESIRED STATE  CURRENT STATE           ERROR  PORTS``0p3r9zm2uxpl  myredis.1  redis  manager  Running        Running 48 seconds ago         ``ty3undmoielo  myredis.2  redis  worker1  Running        Running 44 seconds ago`</span><br></pre></td></tr></table></figure><p>上面信息中，在manager和worker1这两个Node上部署了myredis这个应用服务，也包含了它们对应的当前状态信息。此时，也可以通过执行docker ps命令，在Manager Node上查看当前启动的Docker容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES``07f93f82a407        redis:latest        &quot;docker-entrypoint...&quot;   7 minutes ago       Up 7 minutes        6379/tcp            myredis.1.0p3r9zm2uxple5i1e2mqgnl3r`</span><br></pre></td></tr></table></figure><p>在Worker1上查看当前启动的Docker容器，也就是我们的另一个myredis实例在该Node上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES``41c31e96cccb        redis:latest        &quot;docker-entrypoint...&quot;   8 minutes ago       Up 8 minutes        6379/tcp            myredis.2.ty3undmoielo18g7pnvh0nutz`</span><br></pre></td></tr></table></figure><p>创建服务时，我们可以对运行时服务容器进行配置，例如如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service create --name helloworld \``  ``--``env` `MYVAR=myvalue \``  ``--workdir ``/tmp` `\``  ``--user my_user \``  ``alpine ``ping` `docker.com`</span><br></pre></td></tr></table></figure><p>上面，通过<code>--env</code>选项来设置环境变量，通过<code>--workdir</code>选项来设置工作目录，通过<code>--user</code>选项来设置用户信息。</p><p><strong>（2）扩容缩容服务</strong></p><p>Docker Swarm支持服务的扩容缩容，Swarm通过<code>--mode</code>选项设置服务类型，提供了两种模式：一种是replicated，我们可以指定服务Task的个数（也就是需要创建几个冗余副本），这也是Swarm默认使用的服务类型；另一种是global，这样会在Swarm集群的每个Node上都创建一个服务。如下图所示（出自Docker官网），是一个包含replicated和global模式的Swarm集群：</p><p><img src="/Docker/Docker-Swarm架构、特性与基本实践/4.png" alt=""></p><p>上图中，黄色表示的replicated模式下的Service Replicas，灰色表示global模式下Service的分布。<br>服务扩容缩容，在Manager Node上执行命令的格式，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service scale 服务ID=服务Task总数`</span><br></pre></td></tr></table></figure><p>例如，将前面我们部署的2个副本的myredis服务，扩容到3个副本，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service scale myredis=3`</span><br></pre></td></tr></table></figure><p>通过命令docker service ls 查看，扩容操作结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID            NAME     MODE        REPLICAS  IMAGE``kilpacb9uy4q  myapp    replicated  1/1       alpine:latest``vf1kcgtd5byc  myredis  replicated  3/3       redis`</span><br></pre></td></tr></table></figure><p>进一步通过docker service ps myredis查看一下myredis的各个副本的状态信息，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`ID            NAME       IMAGE  NODE     DESIRED STATE  CURRENT STATE                   ERROR  PORTS``0p3r9zm2uxpl  myredis.1  redis  manager  Running        Running 14 minutes ago                 ``ty3undmoielo  myredis.2  redis  worker1  Running        Running 14 minutes ago                 ``zxsvynsgqmpk  myredis.3  redis  worker2  Running        Running less than a second ago`</span><br></pre></td></tr></table></figure><p>可以看到，我们目前3个Node的Swarm集群，每个Node上都有一个myredis应用服务的副本，可见也实现了很好的负载均衡。<br>缩容服务，只需要将副本数小于当前应用服务拥有的副本数即可实现，大于指定缩容副本数的副本会被删除。</p><p><strong>（3）删除服务</strong></p><p>删除服务，只需要在Manager Node上执行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service ``rm` `服务ID`</span><br></pre></td></tr></table></figure><p>例如，删除myredis应用服务，执行docker service rm myredis，则应用服务myredis的全部副本都会被删除。</p><p><strong>（4）滚动更新</strong></p><p>服务的滚动更新，这里我参考官网文档的例子说明。在Manager Node上执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service create \``  ``--replicas 3 \``  ``--name redis \``  ``--update-delay 10s \``  ``redis:3.0.6`</span><br></pre></td></tr></table></figure><p>上面通过指定<code>--update-delay</code>选项，表示需要进行更新的服务，每次成功部署一个，延迟10秒钟，然后再更新下一个服务。如果某个服务更新失败，则Swarm的调度器就会暂停本次服务的部署更新。<br>另外，也可以更新已经部署的服务所在容器中使用的Image的版本，例如执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service update --image redis:3.0.7 redis`</span><br></pre></td></tr></table></figure><p>将Redis服务对应的Image版本有3.0.6更新为3.0.7，同样，如果更新失败，则暂停本次更新。</p><p><strong>（5）添加Overlay网络</strong></p><p>在Swarm集群中可以使用Overlay网络来连接到一个或多个服务。具体添加Overlay网络，首先，我们需要创建在Manager Node上创建一个Overlay网络，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker network create --driver overlay my-network`</span><br></pre></td></tr></table></figure><p>创建完Overlay网络my-network以后，Swarm集群中所有的Manager Node都可以访问该网络。然后，我们在创建服务的时候，只需要指定使用的网络为已存在的Overlay网络即可，如下命令所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`docker service create \``  ``--replicas 3 \``  ``--network my-network \``  ``--name myweb \``  ``nginx`</span><br></pre></td></tr></table></figure><p>这样，如果Swarm集群中其他Node上的Docker容器也使用my-network这个网络，那么处于该Overlay网络中的所有容器之间，通过网络可以连通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker集群管理和编排的特性是通过SwarmKit进行构建的， 其中Swarm mode是Docker Engine内置支持的一种默认实现。Docker 1.12以及更新的版本，都支持Swarm mode，我们可以基于Docker Engine来构建Swarm集群，然后
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="docker swarm" scheme="http://blog.ozairs.com/tags/docker-swarm/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们使用Terraform而不是Chef，Puppet，Ansible，SaltStack或CloudFormation</title>
    <link href="http://blog.ozairs.com/Terraform/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8Terraform%E8%80%8C%E4%B8%8D%E6%98%AFChef%EF%BC%8CPuppet%EF%BC%8CAnsible%EF%BC%8CSaltStack%E6%88%96CloudFormation/"/>
    <id>http://blog.ozairs.com/Terraform/为什么我们使用Terraform而不是Chef，Puppet，Ansible，SaltStack或CloudFormation/</id>
    <published>2019-03-29T21:59:47.000Z</published>
    <updated>2019-03-29T22:04:21.895Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/Terraform/为什么我们使用Terraform而不是Chef，Puppet，Ansible，SaltStack或CloudFormation/1.png" alt=""></p><p>这是<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca" target="_blank" rel="noopener">Terraform系列综合指南的</a>第1部分。在本系列的介绍中，我们讨论了<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-terraform-b3d32832baca" target="_blank" rel="noopener">为什么每家公司都应该使用基础架构代码（IAC）</a>。在这篇文章中，我们将讨论为什么我们选择Terraform作为我们选择的IAC工具。</p><p>如果您在互联网上搜索“基础架构即代码”，那么很容易想出一个最受欢迎的工具列表：</p><ul><li><a href="https://www.chef.io/" target="_blank" rel="noopener">Chef</a></li><li><a href="https://puppet.com/" target="_blank" rel="noopener">Puppet</a></li><li><a href="https://www.ansible.com/" target="_blank" rel="noopener">Ansible</a></li><li><a href="https://saltstack.com/" target="_blank" rel="noopener">SaltStack</a></li><li><a href="https://aws.amazon.com/cloudformation/" target="_blank" rel="noopener">CloudFormation</a></li><li><a href="https://www.terraform.io/" target="_blank" rel="noopener">Terraform</a></li></ul><p>什么不容易找出你应该使用哪一个。所有这些工具都可用于将基础架构作为代码进行管理。所有这些都是开源的，由大型贡献者社区支持，并与许多不同的云提供商合作（除了CloudFormation，它是闭源和仅AWS）。所有这些都提供企业支持。所有这些都有很好的文档记录，包括官方文档和社区资源，如博客文章和StackOverflow问题。那你怎么决定？</p><p>更难以理解的是，您在这些工具之间在线找到的大多数比较只是列出每个工具的一般属性，并使其听起来像您可以同样成功地使用它们。虽然这在技术上是正确的，但它没有帮助。这有点像告诉编程新手，你可以用PHP，C或汇编建立一个网站同样成功 - 这个声明在技术上是正确的，但是省略了大量的信息，这些信息在做出正确的决定时非常有用。</p><p>在这篇文章中，我们将深入探讨为什么我们选择Terraform而不是其他IAC工具的一些非常具体的原因。与所有技术决策一样，这是一个权衡和优先级的问题，虽然您的特定优先级可能与我们的不同，但我们希望分享我们的思维过程将帮助您做出自己的决定。以下是我们考虑的主要权衡因素：</p><ul><li>配置管理与业务流程</li><li>可变基础设施与不可变基础设施</li><li>程序性与陈述性</li><li>客户端/服务器架构与仅客户端架构</li></ul><h3 id="配置管理与业务流程"><a href="#配置管理与业务流程" class="headerlink" title="配置管理与业务流程"></a>配置管理与业务流程</h3><p>Chef，Puppet，Ansible和SaltStack都是“配置管理”工具，这意味着它们旨在安装和管理现有服务器上的软件。CloudFormation和Terraform是“业务流程工具”，这意味着它们旨在自行配置服务器，将这些服务器配置为其他工具。这两个类别并不相互排斥，因为大多数配置管理工具都可以进行一定程度的配置，大多数编排工具可以进行某种程度的配置管理。但是，对配置管理或编排的关注意味着某些工具将更适合某些类型的任务。</p><p>特别是，我们发现如果您使用<a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a>或<a href="https://www.packer.io/" target="_blank" rel="noopener">Packer</a>，您的绝大多数配置管理需求已经得到了解决。使用Docker和Packer，您可以创建已安装和配置服务器所需的所有软件的映像（例如容器或虚拟机映像）（有关Docker的优缺点的详细信息，<a href="http://www.ybrikman.com/writing/2015/05/19/docker-osx-dev/" target="_blank" rel="noopener">请参阅此处</a>）。拥有这样的图像后，您只需要一台服务器即可运行它。如果您需要做的就是配置一堆服务器，那么像Terraform这样的编排工具通常比配置管理工具更合适（这里是一个<a href="https://github.com/brikis98/infrastructure-as-code-talk" target="_blank" rel="noopener">如何使用Terraform在AWS上部署Docker</a>的示例）。</p><h3 id="可变基础设施与不可变基础设施"><a href="#可变基础设施与不可变基础设施" class="headerlink" title="可变基础设施与不可变基础设施"></a>可变基础设施与不可变基础设施</h3><p>Chef，Puppet，Ansible和SaltStack等配置管理工具通常默认为可变基础架构范例。例如，如果您告诉Chef安装新版本的OpenSSL，它将在现有服务器上运行软件更新，并且更改将在原地进行。随着时间的推移，当您应用越来越多的更新时，每个服务器都会构建一个独特的更改历史记录。这通常会导致称为<em>配置漂移</em>的现象，其中每个服务器与所有其他服务器略有不同，导致难以诊断且几乎不可能再现的细微配置错误。</p><p>如果您正在使用Terraform等编排工具来部署Docker或Packer创建的机器映像，那么每个“更改”实际上都是新服务器的部署（就像函数式编程中变量的每次“更改”实际返回一样）新变量）。例如，要部署新版本的OpenSSL，您可以使用Packer或Docker创建新映像，并安装新版本的OpenSSL，将该映像部署到一组全新的服务器上，然后取消部署旧服务器。这种方法降低了配置偏移错误的可能性，使您更容易确切知道服务器上运行的软件，并允许您随时轻松部署任何以前版本的软件。当然，也可以强制配置管理工具进行不可变部署，</p><h3 id="程序性与陈述性"><a href="#程序性与陈述性" class="headerlink" title="程序性与陈述性"></a>程序性与陈述性</h3><p>Chef和Ansible鼓励一种程序风格，您可以编写代码，逐步指定如何实现某些所需的最终状态。Terraform，CloudFormation，SaltStack和Puppet都鼓励更具说明性的风格，您可以编写指定所需最终状态的代码，IAC工具本身负责确定如何实现该状态。</p><p>例如，假设您要部署10台服务器（AWS术语中的“EC2 Instances”）来运行应用程序的v1。以下是使用过程方法执行此操作的Ansible模板的简化示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  ec2：</span><br><span class="line">    count：10 </span><br><span class="line">    image：ami-v1     </span><br><span class="line">    instance_type：t2.micro</span><br></pre></td></tr></table></figure><p>以下是使用声明方法执行相同操作的Terraform模板的简化示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">资源“aws_instance”“example”&#123; </span><br><span class="line">  count = 10 </span><br><span class="line">  ami =“ami-v1” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在在表面上，这两种方法可能看起来相似，当您最初使用Ansible或Terraform执行它们时，它们将产生类似的结果。有趣的是，当您想要进行更改时会发生什么。</p><p>例如，假设流量已经增加，并且您希望将服务器数量增加到15.使用Ansible，您之前编写的过程代码不再有用; 如果您刚刚将服务器数量更新为15并重新启动该代码，那么它将部署15台新服务器，总共提供25台服务器！因此，您必须了解已部署的内容并编写一个全新的过程脚本来添加5个新服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  ec2：</span><br><span class="line">    count：5 </span><br><span class="line">    image：ami-v1     </span><br><span class="line">    instance_type：t2.micro</span><br></pre></td></tr></table></figure><p>使用声明性代码，因为你所做的就是声明你想要的结束状态，而Terraform计算出如何到达那个结束状态，Terraform也会知道它过去创建的任何状态。因此，要部署另外5台服务器，您只需返回相同的Terraform模板并将计数从10更新为15：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource “aws_instance”“example”&#123; </span><br><span class="line">  count = 15 </span><br><span class="line">  ami =“ami-v1” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你执行了这个模板，Terraform会意识到它已经创建了10个服务器，因此它需要做的只是创建5个新服务器。实际上，在运行此模板之前，您可以使用Terraform的“计划”命令来预览它将进行的更改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; terraform计划</span><br><span class="line">+ aws_instance.example.11 </span><br><span class="line">    ami：“ami-v1” </span><br><span class="line">    instance_type：“t2.micro”</span><br><span class="line">+ aws_instance.example.12 </span><br><span class="line">    ami：“ami-v1” </span><br><span class="line">    instance_type：“t2.micro”</span><br><span class="line">+ aws_instance.example.13 </span><br><span class="line">    ami：“ami-v1” </span><br><span class="line">    instance_type：“t2.micro”</span><br><span class="line">+ aws_instance.example.14 </span><br><span class="line">    ami：“ami-v1” </span><br><span class="line">    instance_type：“t2.micro”</span><br><span class="line">+ aws_instance.example.15 </span><br><span class="line">    ami：“ami-v1” </span><br><span class="line">    instance_type：“t2.micro”</span><br><span class="line">计划：5添加，0改变，0破坏。</span><br></pre></td></tr></table></figure><p>现在，当您想要部署v2服务时会发生什么？使用过程方法，您之前的两个Ansible模板都没有用，所以您必须编写另一个模板来跟踪之前部署的10个服务器（或者现在是15个？）并仔细更新每个模板到新版本。使用Terraform的声明式方法，您可以再次返回完全相同的模板，只需将ami版本号更改为v2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Resource “aws_instance”“example”&#123; </span><br><span class="line">  count = 15 </span><br><span class="line">  ami =“ami-v2” </span><br><span class="line">  instance_type =“t2.micro” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，上述例子是简化的。Ansible允许您在部署新的EC2实例之前使用标签来搜索现有的EC2实例（例如，使用instance_tags和count_tag参数），但是必须根据每个资源的情况为Ansible管理的每个资源手动找出这种逻辑。过去的历史，可能会令人惊讶地复杂化（例如，不仅通过标签，还可以通过图像版本，可用区域等查找现有实例）。这突出了程序IAC工具的两个主要问题：</p><ol><li>处理过程代码时，代码中<em>未</em>完全捕获基础结构的状态。阅读我们上面创建的三个Ansible模板并不足以了解已部署的内容。您还必须知道我们应用这些模板的<em>顺序</em>。如果我们以不同的顺序应用它们，我们最终可能会使用不同的基础结构，而这不是您在代码库本身中可以看到的。换句话说，要推理Ansible或Chef代码库，您必须知道所发生的每个更改的完整历史记录。</li><li>过程代码的可重用性本质上是有限的，因为您必须手动考虑代码库的当前状态。由于该状态不断变化，因此一周前使用的代码可能不再可用，因为它旨在修改不再存在的基础架构状态。结果，程序代码库随着时间的推移趋于变大和变得复杂。</li></ol><p>另一方面，使用Terraform中使用的声明式方法，代码始终代表基础架构的最新状态。一目了然，您可以分辨当前部署的内容及其配置方式，而无需担心历史记录或时间安排。这也使得创建可重用代码变得容易，因为您不必手动考虑当前的世界状态。相反，您只需专注于描述您想要的状态，Terraform会自动确定如何从一个状态到另一个状态。因此，Terraform代码库往往保持小巧且易于理解。</p><p>当然，声明性语言也有缺点。如果无法使用完整的编程语言，您的表达能力就会受到限制。例如，某些类型的基础架构更改（例如滚动，零停机部署）很难用纯粹的声明性术语表达。同样，如果没有“逻辑”（例如if语句，循环）的能力，创建通用的，可重用的代码可能会很棘手（特别是在CloudFormation中）。幸运的是，Terraform提供了许多强大的原语 - 例如<a href="https://www.terraform.io/intro/getting-started/variables.html" target="_blank" rel="noopener">输入变量</a>，<a href="https://www.terraform.io/intro/getting-started/outputs.html" target="_blank" rel="noopener">输出变量</a>，<a href="https://www.terraform.io/docs/modules/usage.html" target="_blank" rel="noopener">模块</a>，<a href="https://www.terraform.io/docs/configuration/resources.html#create_before_destroy" target="_blank" rel="noopener">create_before_destroy</a>，<a href="https://www.terraform.io/docs/configuration/resources.html#using-variables-with-count" target="_blank" rel="noopener">count</a>和<a href="https://www.terraform.io/docs/configuration/interpolation.html" target="_blank" rel="noopener">插值函数 </a> - 即使在声明性语言中，也可以创建干净，可配置的模块化代码。我们将在第4部分，<a href="https://blog.gruntwork.io/how-to-create-reusable-infrastructure-with-terraform-modules-25526d65f73d" target="_blank" rel="noopener">如何使用Terraform模块创建可重用的基础架构</a>和第5部分，<a href="https://blog.gruntwork.io/terraform-tips-tricks-loops-if-statements-and-gotchas-f739bbae55f9" target="_blank" rel="noopener">Terraform提示和技巧：循环，if语句和陷阱中</a>更多地讨论这些工具。</p><h3 id="客户端-服务器架构与仅客户端架构"><a href="#客户端-服务器架构与仅客户端架构" class="headerlink" title="客户端/服务器架构与仅客户端架构"></a>客户端/服务器架构与仅客户端架构</h3><p>Chef，Puppet和SaltStack默认都使用客户端/服务器架构。客户端可以是Web UI或CLI工具，用于发出命令（例如“部署X”）。这些命令转到服务器，服务器负责执行命令并存储系统状态。要执行这些命令，服务器会与代理进行通信，代理必须在您要配置的每台服务器上运行。这有许多缺点：</p><ul><li>您必须在每台服务器上安装和运行额外的软件。</li><li>您必须部署额外的服务器（甚至是服务器集群以实现高可用性），仅用于配置管理。</li><li>您不仅需要安装这些额外的软件和硬件，而且还必须对其进行维护，升级，备份，监控以及在发生中断时进行恢复。</li><li>由于客户端，服务器和代理都需要通过网络进行通信，因此必须为它们打开额外的端口，并配置它们相互进行身份验证的方式，所有这些都会增加攻击者的表面积。</li><li>所有这些额外的移动部件都会在您的基础架构中引入大量新的故障模式。当您在凌晨3点收到错误报告时，您必须弄清楚它是否是您的应用程序代码，IAC代码，配置管理客户端软件，配置管理代理软件或配置管理服务器软件中的错误，或所有这些配置管理部件用于通信的端口，或者它们彼此进行身份验证的方式，或者……</li></ul><p>CloudFormation，Ansible和Terraform使用仅客户端架构。实际上，CloudFormation也是客户端/服务器，但AWS透明地处理所有服务器细节，作为最终用户，您只需要考虑客户端代码。Ansible客户端通过SSH直接连接到您的服务器。Terraform使用云提供商API来配置基础架构，因此除了您已经使用云提供商之外，没有新的身份验证机制，也不需要直接访问您的服务器。我们发现这是易用性，安全性和可维护性方面的最佳选择。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>总而言之，下面的表格显示了最流行的IAC工具如何叠加：</p><p><img src="/Terraform/为什么我们使用Terraform而不是Chef，Puppet，Ansible，SaltStack或CloudFormation/2.png" alt="img"></p><p>比较流行的基础架构作为代码工具。点击图像查看大图。请注意，此表显示了使用每个工具的“惯用”方式。</p><p>在Gruntwork，我们想要的是一个开源的，与云无关的编排工具，它支持不可变基础架构，声明性语言和仅客户端架构。从上表中可以看出，Terraform是唯一符合我们所有标准的工具。</p><p>当然，Terraform并不完美。它比名单上的所有其他工具更年轻，更不成熟：虽然Puppet于2005年推出，2009年是Chef，2011年是SaltStack和CloudFormation，2012年是Ansible，Terraform仅在2年前推出，2014年.Terraform仍然是pre 1.0.0（最新版本为0.7.4），因此无法保证稳定或向后兼容的API。错误相对常见（例如，标签“bug” 存在超过<a href="https://github.com/hashicorp/terraform/issues?q=is%3Aopen+is%3Aissue+label%3Abug" target="_blank" rel="noopener">800个未解决的问题</a>），尽管绝大多数都是无害的最终一致性问题，当您重新运行Terraform时这些问题就会消失。Terraform如何存储状态也存在一些问题，尽管我们将在第3部分：<a href="https://blog.gruntwork.io/how-to-manage-terraform-state-28f5697e68fa" target="_blank" rel="noopener">如何管理Terraform状态中</a>讨论这些问题的有效解决方案。</p><p>尽管有它的缺点，我们发现Terraform的优势远远超过它的弱点，并且没有其他IAC工具几乎符合我们的标准。如果Terraform听起来像是符合您标准的东西，请转到第2部分：<a href="https://blog.gruntwork.io/an-introduction-to-terraform-f17df9c6d180" target="_blank" rel="noopener">Terraform简介</a>，了解更多信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/Terraform/为什么我们使用Terraform而不是Chef，Puppet，Ansible，SaltStack或CloudFormation/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是&lt;a href=&quot;https://blog.gruntw
      
    
    </summary>
    
      <category term="Terraform" scheme="http://blog.ozairs.com/categories/Terraform/"/>
    
    
      <category term="Iac" scheme="http://blog.ozairs.com/tags/Iac/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins Pipeline进行持续集成</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%BD%BF%E7%94%A8Jenkins-Pipeline%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>http://blog.ozairs.com/Jenkins/使用Jenkins-Pipeline进行持续集成/</id>
    <published>2019-03-29T06:16:10.000Z</published>
    <updated>2019-03-29T06:18:18.570Z</updated>
    
    <content type="html"><![CDATA[<p>本文<a href="http://syndicode.co/2016/06/02/continuous-integration-and-delivery-with-github-gitflow-and-jenkins/" target="_blank" rel="noopener">与Github，Gitflow和Jenkins持续集成和交付</a>的内容有关。但这次我将扩展与Jenkins持续集成的主题，并深入探讨Jenkins Pipelines的细节。在这里，您将找到有关与Jenkins Pipeline持续集成的所有信息！</p><p>好的，确定你知道这一切，但基本条款永远不会让情况更糟。我们将从他们开始。</p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><p><strong>Jenkins</strong>是一个开源的持续集成（CI）工具，可以通过自动化帮助协调开发过程（构建，测试和部署）。换句话说，Jenkins是帮助开发团队实现其流程工业化的领先工具之一。这是开发人员的队友，当您在特定分支（主控和开发）上推送代码时，您可以要求将代码投入生产（或升级）。</p><p>正如您所知，<strong>CI（持续集成）</strong>是将所有开发人员工作副本每天多次合并到共享主线的做法。</p><p>Jenkins很有用，因为它将自由式作业编排成CI管道。</p><p><strong>Pipeline（Jenkins Pipeline）</strong>是一套插件，支持在Jenkins中实现和集成连续交付管道。持续交付管道是您将软件从版本控制直至用户和客户的过程的自动表达。</p><p>Pipeline为Jenkins添加了一套功能强大的自动化工具。设置管道项目意味着编写一个脚本，该脚本将按顺序应用我们想要完成的流程的一些步骤。</p><p><strong>Jenkinsfile</strong>是一个文本文件，包含Jenkins管道的定义，并被检入源代码管理。</p><p><strong>构建作业</strong>是由Jenkins控制和监视的可运行任务。作业示例包括编译源代码，运行测试，配置测试环境，部署，归档，发布构建作业（如报告）以及执行任意脚本。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="Jenkins管道功能"><a href="#Jenkins管道功能" class="headerlink" title="Jenkins管道功能"></a>Jenkins管道功能</h4><ul><li><strong>代码</strong>：管道在代码中实现，通常检查到源代码控制中，使团队能够编辑，审查和迭代其交付管道。</li><li><strong>持久</strong>：管道可以在Jenkins主计划的计划内和计划外重启中存活。</li><li><strong>Pausable</strong>：在继续管道运行之前，管道可以选择停止并等待人工输入或批准。</li><li><strong>功能多样</strong>：管道支持复杂的实际连续交付要求，包括并行分叉/连接，循环和执行工作的能力。</li><li><strong>可扩展</strong>：Pipeline插件支持其DSL（特定于域的语言）的自定义扩展以及与其他插件集成的多个选项。</li></ul><h4 id="Jenkins管道条款"><a href="#Jenkins管道条款" class="headerlink" title="Jenkins管道条款"></a>Jenkins管道条款</h4><p><strong>步骤</strong>  - 单个任务; 从根本上说步Jenkins<em>是什么</em>做的。</p><p><strong>节点</strong>。Pipeline执行的大多数<em>工作</em>是在一个或多个声明的<strong>节点步骤</strong>的上下文中完成的。节点选择管道将在何处执行。限制节点步骤内的工作有两个作用：</p><ol><li>通过向Jenkins队列添加项来计划要运行的块中包含的步骤。只要执行程序在节点上空闲，步骤就会运行。</li><li>创建工作空间（特定于该特定管道的目录），可以对从源控件检出的文件进行工作。</li></ol><p><strong>阶段</strong>是定义整个管道的概念上不同的子集的步骤，例如：“构建”，“测试”和“部署”，许多插件使用它来可视化或呈现Jenkins管道状态/进度。</p><p><strong>声明性和脚本化管道</strong></p><p>Jenkins Pipeline正在使用具有两种不同语法的域特定语言（DSL）：</p><ul><li>Declarative Pipeline<br>在Pipeline子系统之上提供了更简化和固定的语法。</li><li>Scripted Pipeline<br>遵循使用Groovy构建的更强制的编程模型。</li></ul><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>Jenkinsfile用于替换当前使用的三个Jenkins构建作业：</p><ul><li>主要集成分支的<strong>多</strong>分支：开发，发布，修补程序和主服务器。</li><li><strong>合并</strong>自动测试GitLab合并请求的请求。</li><li><strong>参数化为</strong>按需测试。</li></ul><p><strong>使用Jenkinsfile可以解决的问题</strong></p><ul><li>将CI / CD管道定义为代码，使其自我记录，可重现和版本化。</li><li>对任何类型的构建作业都有单一的构建步骤定义，无论是多分支，合并请求还是参数化。</li><li>远离构建步骤的手动配置。</li><li>使管道易于扩展。例如，将新的静态分析工具报告添加到所有已配置的构建作业中应该不复杂。</li></ul><h3 id="将您的代码投入生产"><a href="#将您的代码投入生产" class="headerlink" title="将您的代码投入生产"></a>将您的代码投入生产</h3><h4 id="定义管道"><a href="#定义管道" class="headerlink" title="定义管道"></a>定义管道</h4><ol><li>设置/配置构建环境。</li><li>看看你的代码。</li><li>构建代码。确保您不使用任何特定于环境的构建过程设置可以独立于环境。</li><li>执行质量控制。此步骤包含两个主要任务：运行测试和执行代码质量检查。</li><li>在Continuous Integration环境中部署代码。</li><li>运行功能测试。</li><li>在测试环境中部署代码。</li><li>在用户接受环境中部署代码。</li><li>在生产环境中部署代码。</li></ol><p>触发作业的一种常见方法是将更改提交到存储库。这意味着当开发人员完成开发任务并将其更改推送到项目的存储库时（例如，如果您使用Git，则执行Git push命令），该作业将自动触发。一个简单的方法是通过<a href="https://wiki.jenkins-ci.org/display/JENKINS/GitHub+Plugin" target="_blank" rel="noopener">GitHub Jenkins插件</a>。</p><h4 id="Jenkins部署的最佳实践"><a href="#Jenkins部署的最佳实践" class="headerlink" title="Jenkins部署的最佳实践"></a>Jenkins部署的最佳实践</h4><ul><li>Jenkins不会将默认配置作为其默认配置的一部分执行任何安全检查，因此请始终确保对Jenkins服务器上的用户进行身份验证并强制实施访问控制。<strong>保护您的Jenkins服务器</strong>。</li><li>在包含多个配置作业的用户的大型复杂集成环境中，应确保它们不在主服务器上运行构建，并且可以无限制地访问JENKINS_HOME目录。<strong>小心的主机</strong>。</li><li>为确保在需要时可以<strong>使用</strong>所有配置和活动日志，请<strong>使用备份配置</strong>。</li><li>Jenkins需要磁盘空间来执行构建，存储数据日志和保存存档。要保持Jenkins的正常运行，请确保<strong>为Jenkins保留10％或更多的磁盘空间，</strong>以防止出现碎片。</li><li>Jenkins 2.0版本提供了代码管道，新的安装体验和一些UI改进。用它。（您可以在文章末尾添加“管道作为代码”链接找到更多相关信息）。</li></ul><h4 id="Jenkins-Pipeline插件的最佳实践："><a href="#Jenkins-Pipeline插件的最佳实践：" class="headerlink" title="Jenkins Pipeline插件的最佳实践："></a>Jenkins Pipeline插件的最佳实践：</h4><ol><li>不要使用像Build Pipeline插件或Buildflow插件这样的旧插件。相反，使用真正的Jenkins Pipeline插件套件。</li><li>将您的管道开发为代码。使用该功能将Jenkins文件存储在SCM中然后版本中，并像测试其他软件一样进行测试。</li><li>管道中的任何非设置工作都应在阶段块中进行。</li><li>Pipeline提供了一种简单的语法，用于将管道分支为并行步骤。用它！</li><li>Pipeline有一个简单的机制来超时管道的任何给定步骤。作为最佳实践，您应该始终计划输入周围的超时。</li><li>使用env全局变量设置环境变量。</li></ol><h3 id="有用的资源"><a href="#有用的资源" class="headerlink" title="有用的资源"></a>有用的资源</h3><ul><li><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins官方网站</a></li><li>包含片段，提示和技巧的<a href="https://github.com/jenkinsci/pipeline-examples" target="_blank" rel="noopener">存储库</a>以及Jenkins管道插件的脚本示例</li><li>Jenkins Pipeline <a href="https://jenkins.io/doc/book/pipeline/getting-started/" target="_blank" rel="noopener">入门</a></li><li>管道<a href="https://jenkins.io/doc/book/pipeline/syntax/" target="_blank" rel="noopener">语法</a></li><li><a href="http://www.baeldung.com/jenkins-pipelines" target="_blank" rel="noopener">Jenkins简介2</a></li><li><a href="https://jenkins.io/solutions/pipeline/" target="_blank" rel="noopener">管道作为代码</a></li><li><a href="https://vetlugin.wordpress.com/2017/01/31/guide-jenkins-pipeline-merge-requests/" target="_blank" rel="noopener">处理Jenkins管道中的合并请求</a></li><li><a href="https://dzone.com/refcardz/declarative-pipeline-with-jenkins" target="_blank" rel="noopener">Jenkins的声明性管道</a></li><li><a href="https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment" target="_blank" rel="noopener">实用的持续部署</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文&lt;a href=&quot;http://syndicode.co/2016/06/02/continuous-integration-and-delivery-with-github-gitflow-and-jenkins/&quot; target=&quot;_blank&quot; rel=&quot;noop
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用凭据文件向AWS进行身份验证</title>
    <link href="http://blog.ozairs.com/AWS/%E4%BD%BF%E7%94%A8%E5%87%AD%E6%8D%AE%E6%96%87%E4%BB%B6%E5%90%91AWS%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    <id>http://blog.ozairs.com/AWS/使用凭据文件向AWS进行身份验证/</id>
    <published>2019-03-29T03:44:36.000Z</published>
    <updated>2019-03-29T03:45:28.772Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799" target="_blank" rel="noopener">在命令行上对AWS进行身份验证</a>的<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799" target="_blank" rel="noopener">综合指南的</a>第1部分。在本<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799" target="_blank" rel="noopener">系列</a>的<a href="https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799" target="_blank" rel="noopener">介绍中</a>，我们介绍了AWS身份验证的基础知识，包括IAM用户，IAM角色和访问密钥。在这篇文章中，我们将介绍在命令行上对AWS进行身份验证的第一个选项：凭据文件。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>您可以将AWS Access密钥存储在（或在Windows上）的<em>凭据文件</em>中。通常，您创建此文件的方式是<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" target="_blank" rel="noopener">安装AWS CLI</a>并运行命令：<code>~/.aws/credentials`</code>%UserProfile%.aws\credentials<code></code>aws configure`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ aws configure </span><br><span class="line">AWS Access密钥ID：AKIAIOSFODNN7EXAMPLE </span><br><span class="line">AWS秘密访问密钥：wJalrXUtnFEMI / K7MDENG / bPxRfiCYEXAMPLEKEY </span><br><span class="line">默认区域名称[无]：us-west-2 </span><br><span class="line">默认输出格式[无]：json</span><br></pre></td></tr></table></figure><p>AWS会提示您输入您的访问密钥ID和秘密访问密钥，并将其存储在<code>~/.aws/credentials</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[默认] </span><br><span class="line">aws_access_key_id = AKIAIOSFODNN7EXAMPLE </span><br><span class="line">aws_secret_access_key = wJalrXUtnFEMI / K7MDENG / bPxRfiCYEXAMPLEKEY</span><br></pre></td></tr></table></figure><p>它还存储您输入的其他设置<code>~/.aws/config</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[default] </span><br><span class="line">region = us-west-2 </span><br><span class="line">output = json</span><br></pre></td></tr></table></figure><p>存在这些文件后，您可以运行与AWS通信的任何CLI或SDK工具，它将自动查找并使用此凭据文件和设置。</p><h3 id="使用多组访问密钥"><a href="#使用多组访问密钥" class="headerlink" title="使用多组访问密钥"></a>使用多组访问密钥</h3><p>如果您有多组访问密钥（例如，对于不同AWS账户中的多个IAM用户），您可以在凭证文件中为每个用户创建单独的<em>命名配置</em> 文件<code>~/.aws/credentials</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[默认] </span><br><span class="line">aws_access_key_id = AKIAIOSFODNN7EXAMPLE </span><br><span class="line">aws_secret_access_key = wJalrXUtnFEMI / K7MDENG / bPxRfiCYEXAMPLEKEY</span><br><span class="line">[user2] </span><br><span class="line">aws_access_key_id = AKIAI44QH8DHBEXAMPLE </span><br><span class="line">aws_secret_access_key = je7MtGbClwBF / 2Zp9Utk / h3yCo8nvbEXAMPLEKEY</span><br></pre></td></tr></table></figure><p>同样，您可以在配置文件中拥有多个命名配置文件<code>~/.aws/config</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[default] </span><br><span class="line">region = us-west-2 </span><br><span class="line">output = json</span><br><span class="line">[profile user2] </span><br><span class="line">region = us-east-1 </span><br><span class="line">output = text</span><br></pre></td></tr></table></figure><p>请注意，<code>default</code>默认情况下，您可能会使用所调用的命名配置文件。要告诉CLI工具使用除<code>default</code>配置文件之外的其他内容，您必须执行以下操作之一：</p><ol><li>设置<code>AWS_PROFILE</code>环境变量。例如，在Linux中，你会运行<code>export AWS_PROFILE=user2</code>。之后，您可以运行任何AWS CLI工具（例如<code>terraform apply</code>），它应该使用您的命名配置文件。</li><li>某些工具允许您将配置文件指定为命令行参数或代码中的参数。例如，<code>aws</code>CLI允许您指定<code>--profile</code>：<code>aws ec2 describe-instances --profile user2</code>。在Terraform中，您可以<code>profile</code>在<code>provider</code>块中设置参数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提供者“aws”&#123; </span><br><span class="line">  profile =“user2” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用IAM角色"><a href="#使用IAM角色" class="headerlink" title="使用IAM角色"></a>使用IAM角色</h3><p>如果您想假设IAM角色 - 例如，您在<code>security</code>帐户中有一个IAM用户并想在您的<code>dev</code>帐户中承担IAM角色- 您有两个选择。第一个选项取决于您正在使用的CLI工具。某些CLI工具允许您通过命令行参数或代码指定要承担的IAM角色。例如，使用Terraform，您可以<code>assume_role</code>在<code>provider</code>配置中指定设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">provider“aws”&#123; </span><br><span class="line">  assume_role &#123; </span><br><span class="line">    role_arn =“arn：aws：iam :: 123456789012：role / dev-full-access” </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个选项是<code>role_arn</code>在Config File中指定参数<code>~/.aws/config</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile dev-full-access] </span><br><span class="line">role_arn = arn：aws：iam :: 123456789012：role / dev-full-access</span><br></pre></td></tr></table></figure><p>使用任一选项，您指定的值<code>role_arn</code>是开发帐户中IAM角色的<a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" target="_blank" rel="noopener">Amazon资源名称（ARN）</a>，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARN：AWS：IAM :: &lt;ACCOUNT_ID&gt;：角色/ &lt;ROLE_NAME&gt;</span><br></pre></td></tr></table></figure><p>下次运行使用<code>dev-full-access</code>命名配置文件的任何CLI命令时，AWS SDK将自动采用指定的IAM角色<code>role_arn</code>。</p><h3 id="与MFA合作"><a href="#与MFA合作" class="headerlink" title="与MFA合作"></a>与MFA合作</h3><p>如果您正在使用<code>aws</code>CLI，则使用带有凭据配置文件的MFA非常简单。您只需将其添加<code>mfa_serial</code>到您的配置文件中<code>~/.aws/config</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile with-mfa] </span><br><span class="line">mfa_serial = arn：aws：iam :: 123456789012：mfa / jon-doe</span><br></pre></td></tr></table></figure><p>该<code>mfa_serial</code>参数应设置为MFA设备的ARN，您可以从AWS Web Console 的<a href="https://console.aws.amazon.com/iam/home?#/users" target="_blank" rel="noopener">IAM用户页面</a>获取该ARN 。它应该是这样的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARN：AWS：IAM :: &lt;ACCOUNT_ID&gt;：MFA / &lt;USERNAME&gt;</span><br></pre></td></tr></table></figure><p>添加<code>mfa_serial</code>参数后，下次<code>aws</code>使用该命名配置文件运行CLI时，它将提示您输入MFA令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ aws s3 ls --profile with-mfa</span><br><span class="line">输入MFA代码：</span><br></pre></td></tr></table></figure><p>但是如果你运行的东西不是<code>aws</code>，比如<code>terraform</code>或者<code>packer</code>怎么办？在这种情况下，事情变得有点毛茸茸，因为大多数其他工具<em>不会</em>自动提示您输入MFA令牌。相反，您必须在该工具之外执行MFA身份验证过程，这是一个<a href="https://aws.amazon.com/premiumsupport/knowledge-center/authenticate-mfa-cli/" target="_blank" rel="noopener">单调乏味的过程</a>。</p><p>首先，使用普通（永久）AWS Access Keys配置凭证文件（例如，通过运行<code>aws configure</code>）。接下来，您运行该<code>aws sts get-session-token</code>命令，将其传递给您的MFA设备的ARN以及来自Google身份验证器应用程序或您的密钥卡的MFA令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aws sts get-session-token \ </span><br><span class="line">  --serial-number arn：aws：iam :: 123456789012：mfa / jon-doe \ </span><br><span class="line">  --token-code 123456 \ </span><br><span class="line">  --duration-seconds 43200</span><br></pre></td></tr></table></figure><p>这将返回一个包含<em>临时访问密钥</em>的JSON blob （请注意<code>--duration-seconds</code>前面命令中的参数，该参数指定这些临时访问密钥何时到期）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  “Credentials”：&#123; </span><br><span class="line">    “SecretAccessKey”：“secret-access-key”，</span><br><span class="line">    “SessionToken”：“temporary-session-token”，</span><br><span class="line">    “Expiration”：“expiration-date-time”，</span><br><span class="line">    “AccessKeyId”：“access-key -id“ </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您需要获取这些临时访问密钥并将其复制到凭证文件中的命名配置文件中<code>~/.aws/credentials</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[with-mfa] </span><br><span class="line">aws_access_key_id = &lt;Access-key-as-in-returned-output&gt; </span><br><span class="line">aws_secret_access_key = &lt;Secret-access-key-as-in-returned-output&gt; </span><br><span class="line">aws_session_token = &lt;Session-Token-as-in-returned-输出&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是临时接入键，可以设置不仅<code>aws_access_key_id</code>和<code>aws_secret_access_key</code>你的证书文件，同时也<code>aws_session_token</code>。</p><p>现在，您可以使用此命名配置文件运行其他CLI工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导出AWS_PROFILE = with-mfa </span><br><span class="line">terraform apply</span><br></pre></td></tr></table></figure><p>请注意，临时访问密钥在一段时间（通常为12小时）后过期，因此您必须反复执行此操作。不好玩。</p><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>基本身份验证很容易。</li><li>使用IAM角色很容易。</li><li>命名配置文件可以轻松管理多组凭据和设置。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>您的访问密钥以明文形式存储在磁盘上。<strong>这不安全。</strong></li><li>您始终使用永久访问密钥进行身份验证，而不是使用已轮换的临时访问密钥。</li><li>使用MFA很复杂且容易出错。</li><li>您的凭据永远位于磁盘上，如果您忘记指定其他命令，则默认的命名配置文件将用于所有命令，这很容易出错。</li><li>在您的代码中指定命名配置文件（例如，在您的Terraform代码中）很有诱惑力，以确保使用正确的凭据，但这需要您的所有团队成员为您的命名配置文件使用相同的名称，这可能很难强制执行。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>尽管许多AWS教程都使用凭证文件，但我们通常建议不要使用凭证文件，因为以明文形式将永久AWS凭证存储在磁盘上并不安全。更糟糕的是，使用凭据文件时，MFA的使用非常复杂，大多数用户都不会为此烦恼。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是&lt;a href=&quot;https://blog.gruntwork.io/a-comprehensive-guide-to-authenticating-to-aws-on-the-command-line-63656a686799&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="Credential" scheme="http://blog.ozairs.com/tags/Credential/"/>
    
  </entry>
  
  <entry>
    <title>【DevOps进阶之路Day1】精通Jenkins Pipeline PartI</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%B2%BE%E9%80%9AJenkins-Pipeline-PartI/"/>
    <id>http://blog.ozairs.com/Jenkins/精通Jenkins-Pipeline-PartI/</id>
    <published>2019-03-28T11:48:43.000Z</published>
    <updated>2019-03-28T12:00:08.126Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/Jenkins/精通Jenkins-Pipeline-PartI/1.png" alt="jenkins的图像结果"></p><p>詹金斯</p><p>使用过水电工Travis-CI的朋友们，应该很多都试过翘胡子Jenkins。不过笔者猜应该大多数的朋友都是使用Jenkins的自由风格项目。</p><p>虽然Free Style项目可以让你客制化任何的Shell Script来执行你想要的脚本进行测试，但其脚本会依赖Jenkins节点上的环境来执行，Jenkins节点上的任何环境改变都可能影响到你的build job的状况，譬如说，系统套件的升级，工具路径的修改，不同的Job间互相的影响…等等。</p><p>此时，最好的做法是将每个Build Job都用VM或Container做隔离，确保每次执行建置的工作环境都是一样的。</p><p>Travis CI的做法是，为了避免给个建筑互相影响，会为每一个建置都开一台全新的GCE Instance，即使你的测试是在Container mode下执行，都会是全新的VM环境。</p><p>然而Travis CI采用YAML格式的设定档格式，这种做法虽然容易使用，但伴随而来的缺点就是动态性不足，你无法轻易的将某个Step产生出来的结果，做出一些逻辑判断，然后再把不同的操作逻辑丢到另外一台机器上平行执行。</p><p>在Jenkins上的选择相对得多，为了解决日渐庞大复杂的Build Flow，2016年四月Jenkins释出了Pipeline plugin，提供所谓的流水线建设功能来让建设工作变得容易扩大。而这个Pipeline Plugin是基于一种语言 - Apache Groovy开发的。</p><p>这系列文章不是要教读者一步一步如何使用Jenkins Pipeline，而是跟读者们解释Jenkins Pipeline的底层机制，在开发时，可以避免去踩到这些相关（你以为可以，但却不行）的陷阱。</p><h3 id="Apache-Groovy"><a href="#Apache-Groovy" class="headerlink" title="Apache Groovy"></a>Apache Groovy</h3><p>可能很多人对Apache Groovy很陌生，Apache Groovy是一位名叫James Strachan的Java开发者于2003年开发出的一套Java语法相容的新语言，在当时纳入了如Ruby，Perl，Python，Smalltalk ，功能语言等语言的特性，可以被静态编译，也可以被动态执行.Groovy可被编译为JVM字节码在JVM上执行，除此之外，Groovy也可使用Java原生套件，你可以一部分用Java写，一部分使用Groovy去调用Java的类。</p><p>在Groovy里的Closure也可以像函数式语言一样，使用Curry（部分申请）。</p><p>2007年约为Rails火红的年代，Groovy的设计在JAX 2007得到创新奖，2008年时的Grails（Groovy web framework）也在JAX 2008年得到创新奖。</p><p>后来设计Groovy和Grails的这家公司G2One被SpringSource收购，而2009年时VMware又收购了SpringSource。</p><p>一直谈Groovy的背景，可能很多人还是很难想像Groovy的程式码长什么样子，我们就来看几个范例：</p><p>很像Java的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  AGroovyBean &#123; </span><br><span class="line">  String color </span><br><span class="line">&#125; </span><br><span class="line">def bean = new AGroovyBean（）; </span><br><span class="line">bean.color =“baby blue” </span><br><span class="line">bean.setColor（“baby blue”）</span><br></pre></td></tr></table></figure><p>很像Ruby + Perl的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//相当于：取（2.pills）.of（氯喹）。之后（6.hours）6小时后服用2.pill的氯喹</span><br></pre></td></tr></table></figure><p>同Perl与Ruby，在Groovy里面的函数调用的圆括号是可以省略的，Closure也有多种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run = &#123;println it&#125; </span><br><span class="line">def run = &#123; - &gt; println it&#125; </span><br><span class="line">def run = &#123;a  - &gt; println a&#125;</span><br></pre></td></tr></table></figure><p>上面三种写法都是一样的。</p><p>此外Groovy本身针对DSL提供一些特别的语言功能，让你可以写出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">withDocker（“mysql：5.7”）&#123; </span><br><span class="line">    sh“....” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样的程式码，他在Pipeline里实际上的语意与下列程式码相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.withDocker（“mysql：5.7”，&#123; - &gt; </span><br><span class="line">    this.sh（“...”）</span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="管道DSL"><a href="#管道DSL" class="headerlink" title="管道DSL"></a>管道DSL</h3><p>回到Jenkins Pipeline，为什么Jenkins管道使用Groovy设计呢？主要是因为整个Jenkins生态系都是使用Java开发而成，而Java却不适合拿来设计Build Job的DSL（Domain Specific Language），Groovy既相容Java ，JVM就被Jenkins作者拿来设计Pipeline Plugin了。</p><p>编程语言有了DSL的强大功能，你就可以使用这样简化的语法，针对你的Build Pipeline写出一个以程序语言为基础的设定档案。</p><p>譬如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">节点（“ec2”）&#123; </span><br><span class="line">    sh“echo Hello World” </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的范例就是一个最简单的Scripted Pipeline，纯Groovy的写法，意思是找到一台label为<code>ec2</code>的机器，然后在这台机器上面执行shell命令：“echo Hello World”。</p><p>这边要稍微说明一下，Jenkins Pipeline的语法分为两种，Scripted Pipeline与Declarative Pipeline。</p><p>这两种语法官方网站上并没有详细解释底层机制的不同，由笔者解释的话，<code>Scripted Pipeline</code>就是原生的Groovy Script，会在Jenkins里面的Groovy Shell执行。</p><p>而<code>Declarative Pipeline</code>相对复杂一些，<code>pipeline</code>这个关键字在<code>Jenkinsfile</code>里面是一个步骤（实际上是方法），这个步骤（方法）会将后面整个封闭的代码，对…就是程式码，带入到Pipeline Model Plugin的核心，用一套Groovy写成的Pipeline Model Parser来重新剖析程式码，转为AST后，再经过Groovy的AST Transformer来重新建构整个Pipeline的逻辑。</p><p>也因此你常用的Declarative Pipeline里面，<code>pipeline { }</code>所包起来的部分并不是纯Groovy Syntax，他利用客制化的剖析器（Parser）来达成一些语意上的限制。</p><h3 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h3><p>在Groovy里面，万物皆为类，既使是脚本文件，也都被无形的类包装起来。</p><p>举例来说，你开一个纯文字档案叫<code>test.groovy</code>，然后在里面写入一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println this.getClass（）</span><br></pre></td></tr></table></figure><p>结果会印出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">班级考试</span><br></pre></td></tr></table></figure><p>发现什么了吗？也就是说，当Jenkins在执行你的<code>Jenkinsfile</code>的时候，你在<code>Jenkinsfile</code>里就是在类的某个方法里面执行，而你的档案名称就变成你的类名。怎么证明呢？</p><p>如果你尝试把Call Stack dump出来会看到什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StackTraceElement [] cause = Thread.currentThread（）。getStackTrace（）; </span><br><span class="line">打印原因</span><br></pre></td></tr></table></figure><p>结果是：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*xr_89aKHzfC7BkcnzOq5JQ.png" alt="img"></p><p>注意到上面，，<code>test.run</code>其实意味着我们脚本里面写的程式码，是被包装在一个叫做run的方法里面执行的。</p><p>Groovy会编译你的程式码，转换为一个继承<code>groovy.lang.Script</code>的类别，这个类别包含了一个抽象化的方法（方法）叫做<code>run</code>。</p><p>当这个脚本被编译时，脚本体会变成这个运行方法的一部分，而其他的方法定义会转为这个类实现的一部分。</p><p>这个Stack Call往上追，你会看到<code>GroovyShell.run</code>，这是什么东西呢？</p><p><code>GroovyShell</code> 提供了一个介面，让你可以在Groovy里面动态建立一个执行环境，然后在这个沙盒里面执行程式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def binding = new Binding（）               </span><br><span class="line">def shell = new GroovyShell（binding）binding.setVariable（      </span><br><span class="line">&apos;x&apos;，1）                </span><br><span class="line">binding.setVariable（&apos;y&apos;，3）</span><br><span class="line">shell.evaluate&apos;z = 2 * x + y&apos;assert                  </span><br><span class="line">binding。 getVariable（&apos;z&apos;）== 5</span><br></pre></td></tr></table></figure><p><code>Binding</code>就是用来连结目前的执行环境与沙盒执行环境的类别，而Jenkins就是利用Binding来将Jenkins的环境资讯注入到<code>Jenkinsfile</code>执行的。</p><p>而这个脚本基类可以被客制化，DSL的设计师可以将这个基类改为自己特制的类来提供一些特别功能。</p><p>举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEF配置=新CompilerConfiguration（）config.scriptBaseClass = &apos;MyBaseClass&apos;高清壳=新GroovyShell（this.class.classLoader，配置）shell.evaluate “” “ </span><br><span class="line">     的setName &apos;朱迪思&apos; </span><br><span class="line">     迎接（） </span><br><span class="line">”“”</span><br></pre></td></tr></table></figure><p>而你可以实作一个类叫做<code>MyBaseClass</code>来来提供<code>setName</code>与<code>greet</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">抽象类MyBaseClass扩展Script &#123; </span><br><span class="line">     String name </span><br><span class="line">     public void greet（）&#123; </span><br><span class="line">         println“Hello，$ name！” </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这边我想读者已经很清楚了，为什么Jenkinsfile里面会有<code>sh</code>，<code>pipeline</code>，<code>echo</code>这些特有的函数可以用？</p><p>其实，你当使用<code>pipeline {}</code>的时候，他实际上就是等于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.pipeline（&#123; - &gt; </span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><p>今天的Jenkins实作细节就先到这边，下集待续。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/Jenkins/精通Jenkins-Pipeline-PartI/1.png&quot; alt=&quot;jenkins的图像结果&quot;&gt;
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>如何遵循尽职调查法，做更多有效的工作</title>
    <link href="http://blog.ozairs.com/%E8%AF%84%E8%AE%BA/%E5%A6%82%E4%BD%95%E9%81%B5%E5%BE%AA%E5%B0%BD%E8%81%8C%E8%B0%83%E6%9F%A5%E6%B3%95%EF%BC%8C%E5%81%9A%E6%9B%B4%E5%A4%9A%E6%9C%89%E6%95%88%E7%9A%84%E5%B7%A5%E4%BD%9C/"/>
    <id>http://blog.ozairs.com/评论/如何遵循尽职调查法，做更多有效的工作/</id>
    <published>2019-03-26T02:56:31.000Z</published>
    <updated>2019-03-26T03:09:34.360Z</updated>
    
    <content type="html"><![CDATA[<p>【译文】</p><p>ç什么容易谈到apitalizing是人们如何成功往往会获得成功。它也是成功故事的一部分，经常被遗漏，因为如果没有被误解，几乎不可能谈论它。</p><p>成功的人不努力工作（这个词，“难”，有错误的含义）。成功人士不会继续向死胡同努力。他们也不会强迫什么是不可行的，无效的，或者根本就是不锻炼。他们在看到最多结果的地方一直工作，他们能够经常工作的原因 - 通常比同龄人更多 - 是因为工作对他们来说有点自然。如果没有，他们就会筋疲力尽，被烧毁，而且结果很少。</p><p>传统智慧告诉你不要放弃<em>，</em>无论如何。但人们总是告诉你，当你停止努力让事情发生时，好事往往会发生。最受欢迎的关系建议是，当我们停止寻找他们时，我们的合作伙伴会出现。对于许多夫妻来说，他们想要怀孕的那一刻就是他们怀孕的那一刻。</p><p>当你试图强迫幸福时，它就会让你失望。如果不这样做，它往往会自行发生。你最终在生活中所做的工作几乎从来都不是A计划; 这是计划B，当你放弃那些不自然的事情时，你就开始做了。当你试着不去思考像白象这样的东西时 - 你可以专注于它。你试图避免的东西越多，你到处都看得越多。你试图抓住充满干燥沙子的拳头越多，它越快滑过你的手指。</p><blockquote><p>有些事情是我们无法控制的，它们会将我们重新定向到比我们最初为自己选择的结果更大的结果。</p></blockquote><p>人们通常不希望将他们在生活中的成功归因于机会，命运或预先存在的条件，因为当然，这些并不是唯一的因素。但是，根本不承认它们是剥夺他人的重要见解。成功不仅仅是因为很多人努力工作而使某人“努力”。你可以说服务行业的人比拥有他们工作的机构的人工作更加困难。他们看到不同的结果，因为他们的能量是针对不同的事情。当我们不得不强迫自己去做时，工作变得艰难，当它本身无趣或没有吸引力时，我们必须强迫自己。</p><p>当我们承诺做一些我们倾向于擅长或有自然兴趣的事情时，我们会立即开始一个快速加强的反馈循环。当我们付出努力并立即获得积极成果时，我们的能量得到加强。当我们看到结果并且相信那些结果时，我们会变得纪律严明。出于这个原因，有些人认为我们最喜欢的东西往往只是我们擅长的东西。</p><p>当您忘记时间并完全沉浸在任务中时，“ 心流”就是最佳性能状态。这通常是我们生产出我们生活中最好的作品，而那些每天都能做到的人往往会为自己的长期成功做出令人难以置信的成功。但自然实现心流状态几乎是不可能的，你必须强迫自己去做。</p><p>任何成功的人都会告诉你 - 尽管他们确实做了很多工作 - 但几乎总是有一些无助的元素在起作用。这项工作是学习如何出现，脱离自己的头脑，让它发生，而不会让你产生怀疑和焦虑。</p><hr><p>牛逼最省力的他律是比生产力黑客更多。这不是一个快速，简单的成功计划。这是我们生活中不变的，经常令人沮丧的一部分。这是我们的自然法则如何治理的一个要素，它在某种程度上是一种比我们更大的力量，一种我们想要理解并对我们有利的工作。</p><p>大自然遵循蓝图。当我们不干扰治疗时，我们的身体会自愈。我们的生活往往以同样的方式运作。当我们谈论生活中“无法控制”的东西时，它几乎总是消极的，如票据或损失或疾病。但它也是相反的。有些事情是我们无法控制的，它们会将我们重新定向到比我们最初为自己选择的结果更大的结果。</p><p>我们每个人都有一套完全独特的优点和缺点，好奇心，激情，沮丧和伤口。这些交叉往往是我们生活中最肥沃的繁殖地。我们经常回顾并且可以看到这些看似随机的因素中的每一个都在我们最终结束的地方发挥了作用。它们不是随机的; 他们绘制了我们根本上是谁的蓝图。</p><blockquote><p>您需要清楚地了解最终目标，然后将其分解为更小的步骤。这不是魔术。这就是我们取得进步的方式。</p></blockquote><p>我们的选择是我们是否激活了潜在的潜力。我们的身体和生活就像能量系统。当我们用压力阻塞他们时，他们开始出现故障。这就像我们心灵河底的一个错误 - 水仍然在顶部涟漪。我们需要清楚地了解我们的最终目标，然后将其分解为更小的步骤。这不是魔术。这就是我们取得进步的方式。</p><p>但是，以一种破坏和窘迫的方式强迫事情会让他们失望。想要的东西让你处于没有它的能量之中。过度依赖于结果会使你如此着迷于完美和你自己的时间，最终破坏真正重要的东西，这是最终的结果。我们怀念成功不是世界给予我们的事实; 这是我们为世界提供的东西，然后从中获益。</p><p>成功始于我们。我们的兴趣，技能和激情; 我们的创伤和不满; 我们肩膀上的筹码和心中的梦想都不是随意的。它们交叉的地方是我们的呼唤，它对我们每个人来说都是完全独特的。我们不必强迫它。我们没有必要竞争它。我们只需要回应它，开始向它展示，然后，像我们手掌中的沙子，学会放松我们的抓地力，并让它成为现实。</p><p>【原文】</p><p>Capitalizing on what comes easily is how successful people tend to get ahead. It’s also part of the success story that’s often left out because it’s almost impossible to talk about without it becoming misconstrued.</p><p>Successful people don’t work hard (that word, “hard,” has the wrong connotation). Successful people don’t keep throwing effort at dead ends. They also don’t force what’s nonviable, ineffective, or just simply not working out. They work consistently where they see the most results, and the reason they are able to work so often—usually much more than their peers—is because the work comes somewhat naturally to them. If it didn’t, they’d be exhausted, burned out, and left with minimal results.</p><p>Conventional wisdom tells you not to give up—ever<em>,</em> no matter what. But people tell you all the time that good things tend to happen when you stop trying so hard to make them happen. The most popular relationship advice is that our partners will show up when we stop looking for them. For many couples, the moment they stop trying to get pregnant is the moment they conceive.</p><p>When you try to force happiness, it eludes you. If you don’t, it tends to happen on its own. The work you end up doing in your life is almost never Plan A; it’s Plan B, which is what you started doing when you gave up on what didn’t come naturally. When you try not to think about something—like a white elephant—it’s all you can focus on. The more you try to avoid something, the more you see it everywhere. The more you try to grip a fist full of dry sand, the faster it slips through your fingers.</p><blockquote><p>There are things out of our control that sort of redirect us to outcomes greater than we would have initially chosen for ourselves.</p></blockquote><p>People generally don’t want to misattribute their successes in life to chance, fate, or pre-existing conditions because, of course, those aren’t the only factors at play. But to not acknowledge them at all is to deprive others of vital insight. Success is more than just how “hard” someone works because a lot of people work hard. You could argue that people in the service industry work a whole lot harder than the people who own the establishment they’re working in. They see different results because their energy is directed toward different things. Work becomes hard when we have to force ourselves to do it, and we have to force ourselves when it’s inherently uninteresting or unappealing.</p><p>When we commit to doing something we are inclined to be good at or have a natural interest in, we start an immediate feedback loop that strengthens quickly. When we put effort toward something and immediately receive positive results, our energy is reinforced. We become disciplined when we see results and when we trust those results. For this very reason, some people suggest that the things we enjoy most are often just the things we are good at.</p><p>“<a href="https://whatis.techtarget.com/definition/flow" target="_blank" rel="noopener">Flow</a>” is that peak performance state when you lose track of time and become fully immersed in your task. This is often when we produce the best work of our lives, and those who can do it every day often position themselves for incredible long-term success. But it’s almost impossible to achieve a flow state doing something you have to force yourself to do.</p><p>Any successful person will tell you that—although they have certainly worked a lot—there is almost always an element of effortlessness at play. The work is learning how to show up, get out of your own head, and allow it to happen without your doubts and anxieties stopping you.</p><hr><p>The law of least effort is more than a productivity hack. It’s not a quick, easy success scheme. It’s a constant, often frustrating, part of our lives. It’s an element of how our natural laws are governed, and it’s in some ways a force greater than we are, one that we want to understand and have work in our favor.</p><p>Nature follows a blueprint. Our bodies heal themselves when we don’t interfere with the healing. Our lives tend to function the same way. When we talk about what we “can’t control” in life, it’s almost always negative—like bills or loss or illness. But it works the opposite way too. There are things out of our control that sort of redirect us to outcomes greater than we would have initially chosen for ourselves.</p><p>Within each of us is a completely unique set of strengths and weaknesses, curiosities, passions, distastes, and wounds. Where these intersect tends to be the most fertile breeding ground of our lives. We often look back and can see that each of these seemingly random factors played a role in where we ultimately ended up. They weren’t random; they mapped a blueprint of who we fundamentally are.</p><blockquote><p>You need to clearly understand the end goal and then break it down into smaller steps. This isn’t magic. This is how we make progress.</p></blockquote><p>Our choice is whether we activate the latent potential. Our bodies and our lives are like energy systems. When we clog them with stress, they start to malfunction. It’s like a fault at the bottom of the river of our psyches—the water still ripples at the top. We need to clearly understand our end goals and then break them down into smaller steps. This isn’t magic. This is how we make progress.</p><p>But forcing things in a way that wreaks havoc and distress holds them back. Wanting something puts you in the energy of not having it. Being overly attached to an outcome makes you so obsessed with perfection and your own timing that you end up sabotaging what really matters, which is the end result. We miss the fact that success is not something the world gives us; it’s something we offer the world and then reap the benefits of doing so.</p><p>Success starts with us. Our interests, skills, and passions; our trauma and our grievances; the chips on our shoulders and the dreams in our hearts are not random. The place where they intersect is our calling, and it is wholly and completely unique to each of us. We don’t have to force it. We don’t have to compete for it. We simply have to respond to it, start showing up to it, and then, like the sand in our palms, learn to loosen our grip, and allow it to be.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;【译文】&lt;/p&gt;
&lt;p&gt;ç什么容易谈到apitalizing是人们如何成功往往会获得成功。它也是成功故事的一部分，经常被遗漏，因为如果没有被误解，几乎不可能谈论它。&lt;/p&gt;
&lt;p&gt;成功的人不努力工作（这个词，“难”，有错误的含义）。成功人士不会继续向死胡同努力。他们也不会强
      
    
    </summary>
    
      <category term="评论" scheme="http://blog.ozairs.com/categories/%E8%AF%84%E8%AE%BA/"/>
    
    
      <category term="励志" scheme="http://blog.ozairs.com/tags/%E5%8A%B1%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动化部署</title>
    <link href="http://blog.ozairs.com/Jenkins/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/Jenkins/Jenkins自动化部署/</id>
    <published>2019-03-25T10:13:57.000Z</published>
    <updated>2019-03-25T11:48:37.525Z</updated>
    
    <content type="html"><![CDATA[<p>一、 Pipeline平台部署</p><ol><li><a href="https://www.cnblogs.com/shenh/p/8963688.html" target="_blank" rel="noopener">jenkins + pipeline构建自动化部署</a></li></ol><p><a href="https://www.cnblogs.com/shenh/p/8963688.html" target="_blank" rel="noopener">https://www.cnblogs.com/shenh/p/8963688.html</a></p><ol start="2"><li><p><a href="https://zhuanlan.zhihu.com/p/51533506" target="_blank" rel="noopener">Jenkins pipeline脚本编写实践分享（一）上篇</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/59160884" target="_blank" rel="noopener">Jenkins pipeline脚本编写实践分享（二）</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/41604558" target="_blank" rel="noopener">jenkins学习之pipeline</a></p></li><li><a href="https://www.xncoding.com/2017/03/22/fullstack/jenkins02.html" target="_blank" rel="noopener">Jenkins持续集成 - 管道详解</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、 Pipeline平台部署&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/shenh/p/8963688.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jenkins + pipeline构建自动
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Chef入门与实战</title>
    <link href="http://blog.ozairs.com/DevOps/Chef%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Chef入门与实战/</id>
    <published>2019-03-24T06:51:16.000Z</published>
    <updated>2019-03-24T07:21:08.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Chef-专用名词"><a href="#一、Chef-专用名词" class="headerlink" title="一、Chef 专用名词"></a>一、Chef 专用名词</h3><pre><code>1. package2. service3. file</code></pre><p>​    </p><h3 id="二、Chef命令汇总"><a href="#二、Chef命令汇总" class="headerlink" title="二、Chef命令汇总"></a>二、Chef命令汇总</h3><ol><li>执行Recipe： chef-client –local-mode hello.rb</li><li>创建Cookbook： chef generate cookbook cookbookname</li><li>创建Recipe： chef generate recipe cookbook/apacher server</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Chef-专用名词&quot;&gt;&lt;a href=&quot;#一、Chef-专用名词&quot; class=&quot;headerlink&quot; title=&quot;一、Chef 专用名词&quot;&gt;&lt;/a&gt;一、Chef 专用名词&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. package
2. service
3. f
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Chef" scheme="http://blog.ozairs.com/tags/Chef/"/>
    
  </entry>
  
  <entry>
    <title>Docker 实战应用</title>
    <link href="http://blog.ozairs.com/Docker/Docker-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Docker/Docker-实战应用/</id>
    <published>2019-03-23T08:39:20.000Z</published>
    <updated>2019-03-25T11:49:30.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Docker平台部署"><a href="#一、Docker平台部署" class="headerlink" title="一、Docker平台部署"></a>一、Docker平台部署</h3><p>Amazon ECS 的 Docker 基本知识</p><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/docker-basics.html#install_docker</a></p><h3 id="二、ECS中Dokcer的配置"><a href="#二、ECS中Dokcer的配置" class="headerlink" title="二、ECS中Dokcer的配置"></a>二、ECS中Dokcer的配置</h3><ol><li><p>Environment设置Entry Point</p><p>sh, -c, while true; do echo $(date)&gt; /shared-data/index_html; sleep 5; done</p></li><li><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/ecs-cli-tutorial-fargate.html" target="_blank" rel="noopener">使用 Amazon ECS CLI 创建包含 Fargate 任务的集群</a></p></li><li><p><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/ecs-cd-pipeline.html" target="_blank" rel="noopener">教程：CodePipeline 持续部署</a></p></li></ol><h3 id="三、使用Jenkins配合Github-hook持续集成"><a href="#三、使用Jenkins配合Github-hook持续集成" class="headerlink" title="三、使用Jenkins配合Github hook持续集成"></a>三、使用Jenkins配合Github hook持续集成</h3><ol><li><a href="http://callmedadaxin.github.io/2018/07/20/jenkins-github-hook" target="_blank" rel="noopener">使用Jenkins配合Github hook持续集成</a></li><li><a href="http://callmedadaxin.github.io/2018/07/20/jenkins-github-hook/" target="_blank" rel="noopener">使用Jenkins和Amazon ECS设置构建管道</a></li><li><a href="https://aws.amazon.com/cn/blogs/china/how-to-implement-the-continuous-integrated-continuous-deployment-solution-on-amazon-ecs-using-aws-codepipelineaws-codebuild-and-aws-cloudformation" target="_blank" rel="noopener">如何使用AWS CodePipeline，AWS CodeBuild与AWS CloudFormation实现Amazon ECS上的持续集成持续部署解决方案</a></li><li><a href="https://www.cnblogs.com/DFX339/p/8351780.html" target="_blank" rel="noopener">Docker使用jenkins部署java项目到远程linux</a></li><li><a href="https://zhuanlan.zhihu.com/p/39289273" target="_blank" rel="noopener">jenkins+docker+git构建java自动化部署</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Docker平台部署&quot;&gt;&lt;a href=&quot;#一、Docker平台部署&quot; class=&quot;headerlink&quot; title=&quot;一、Docker平台部署&quot;&gt;&lt;/a&gt;一、Docker平台部署&lt;/h3&gt;&lt;p&gt;Amazon ECS 的 Docker 基本知识&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>AWS 实战部署</title>
    <link href="http://blog.ozairs.com/AWS/AWS-%E5%AE%9E%E6%88%98%E9%83%A8%E7%BD%B2/"/>
    <id>http://blog.ozairs.com/AWS/AWS-实战部署/</id>
    <published>2019-03-22T11:30:34.000Z</published>
    <updated>2019-03-22T11:33:28.244Z</updated>
    
    <content type="html"><![CDATA[<p>如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon ECS 首次运行向导或 Amazon ECS 命令行界面 (CLI) 启动首个集群的准备。</p><p>注意</p><p>因为 Amazon ECS 使用 Amazon EC2 的许多组件，所以，您可以将 Amazon EC2 控制台用于这些步骤中的许多步骤。</p><p>要开始设置 Amazon ECS，请完成以下任务。如果您已完成以下任何步骤，可以将其跳过并继续安装自定义 AWS CLI。</p><ol><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#sign-up-for-aws" target="_blank" rel="noopener">注册 AWS</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-user" target="_blank" rel="noopener">创建 IAM 用户</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-an-iam-role" target="_blank" rel="noopener">创建 IAM 角色</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-key-pair" target="_blank" rel="noopener">创建密钥对</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-vpc" target="_blank" rel="noopener">创建 Virtual Private Cloud</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#install_aws_cli" target="_blank" rel="noopener">安装 AWS CLI</a></li></ol><h2 id="注册-AWS"><a href="#注册-AWS" class="headerlink" title="注册 AWS"></a>注册 AWS</h2><p>当您注册 AWS 时，您的 AWS 账户会自动注册所有服务，包括 Amazon EC2 和 Amazon ECS。您只需为使用的服务付费。</p><p>如果您已有 AWS 账户，请跳到下一个任务。如果您还没有 AWS 账户，请使用以下步骤创建。</p><p><strong>创建 AWS 账户</strong></p><ol><li><p>打开 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html" target="_blank" rel="noopener">https://aws.amazon.com/</a>，然后选择 <strong>Create an AWS Account (创建 AWS 账户)</strong>。</p><p>注意</p><p>如果您之前曾使用 AWS 账户根用户 凭证登录 AWS 管理控制台，请选择 <strong>Sign in to a different account (登录其他账户)</strong>。如果您之前曾使用 IAM 凭证登录控制台，请选择 <strong>Sign-in using root account credentials (使用根账户凭证登录)</strong>。然后选择 <strong>Create a new AWS account (创建新的 AWS 账户)</strong>。</p></li><li><p>按照联机说明操作。</p><p>在注册时，您将接到一通电话，要求您使用电话键盘输入一个验证码。</p></li></ol><p>请记下您的 AWS 账号，因为在下一个任务中您会用到它。</p><h2 id="创建-IAM-用户"><a href="#创建-IAM-用户" class="headerlink" title="创建 IAM 用户"></a>创建 IAM 用户</h2><p>AWS 中的服务（如 Amazon EC2 和 Amazon ECS）要求您在访问时提供凭证，以便服务可以确定您是否有权限访问其资源。控制台要求您的密码。您可以为您的 AWS 账户创建访问密钥以访问命令行界面或 API。但是，我们不建议您使用 AWS 账户的凭证访问 AWS，而建议您改用 AWS Identity and Access Management (IAM)。创建 IAM 用户，然后将该用户添加到具有管理权限的 IAM 组或授予此用户管理权限。然后，您就可以使用专门的 URL 和该 IAM 用户的凭证来访问 AWS。</p><p>如果您已注册 AWS 但尚未为自己创建一个 IAM 用户，则可以使用 IAM 控制台自行创建。</p><p><strong>为您自己创建一个 IAM 用户并将该用户添加到管理员组</strong></p><ol><li><p>使用 AWS 账户电子邮件地址和密码，以 <em>AWS 账户根用户</em> 身份登录到 IAM 控制台 (<a href="https://console.aws.amazon.com/iam/" target="_blank" rel="noopener">https://console.aws.amazon.com/iam/</a>)。</p><p>注意</p><p>强烈建议您遵守以下使用 <strong>Administrator</strong> IAM 用户的最佳实践，妥善保存根用户凭证。只在执行少数<a href="https://docs.aws.amazon.com/general/latest/gr/aws_tasks-that-require-root.html" target="_blank" rel="noopener">账户和服务管理任务</a>时才作为根用户登录。</p></li><li><p>在控制台的导航窗格中，选择 <strong>Users (用户)</strong>，然后选择 <strong>Add user (添加用户)</strong>。</p></li><li><p>对于 <strong>User name (用户名)</strong>，键入 <strong>Administrator</strong>。</p></li><li><p>选中 <strong>AWS 管理控制台 access (AWS 管理控制台访问)</strong> 旁边的复选框，选择 <strong>Custom password (自定义密码)</strong>，然后在文本框中键入新用户的密码。您可以选择 <strong>Require password reset</strong> (需要重置密码) 以强制用户在下次登录时创建新密码。</p></li><li><p>选择<strong>下一步: 权限</strong>。</p></li><li><p>在<strong>设置权限</strong>页面上，选择<strong>将用户添加到组</strong>。</p></li><li><p>选择 <strong>Create group</strong>。</p></li><li><p>在 <strong>Create group (创建组)</strong> 对话框中，对于 <strong>Group name (组名称)</strong>，键入 <strong>Administrators</strong>。</p></li><li><p>对于 <strong>Filter policies (筛选策略)</strong>，选中 <strong>AWS managed - job function (AWS 托管 - 工作职能)</strong> 的复选框。</p></li><li><p>在策略列表中，选中 <strong>AdministratorAccess</strong> 的复选框。然后选择 <strong>Create group</strong>。</p></li><li><p>返回到组列表中，选中您的新组所对应的复选框。如有必要，选择 <strong>Refresh</strong> 以在列表中查看该组。</p></li><li><p>选择 <strong>Next: Tags (下一步: 标签)</strong> 通过以键值对的形式附加标签来向用户添加元数据。</p></li><li><p>选择 <strong>Next: Review</strong> 以查看要添加到新用户的组成员资格的列表。如果您已准备好继续，请选择 <strong>Create user</strong>。</p></li></ol><p>您可使用此相同的流程创建更多的组和用户，并允许您的用户访问 AWS 账户资源。要了解有关使用策略限制用户对特定 AWS 资源的权限的信息，请参阅<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html" target="_blank" rel="noopener">访问管理</a>和<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_examples.html" target="_blank" rel="noopener">示例策略</a>。</p><p>要以该新 IAM 用户的身份登录，请从 AWS 控制台注销，然后使用以下 URL，其中 <em>your_aws_account_id</em> 是您不带连字符的 AWS 账号（例如，如果您的 AWS 账号是 <code>1234-5678-9012</code>，则您的 AWS 账户 ID 是 <code>123456789012</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_aws_account_id.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>输入您刚创建的 IAM 用户名和密码。登录后，导航栏显示 <em>your_user_name</em> @ <em>your_aws_account_id</em>。</p><p>如果您不希望您的登录页面 URL 包含 AWS 账户 ID，可以创建账户别名。从 IAM 控制面板中，选择 <strong>Create Account Alias (创建账户别名)</strong>，然后输入一个别名，例如您的公司名称。要在创建账户别名后登录，请使用以下 URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your_account_alias.signin.aws.amazon.com/console/</span><br></pre></td></tr></table></figure><p>要为您的账户验证 IAM 用户的登录链接，请打开 IAM 控制台并在控制面板的 <strong>IAM users sign-in link (IAM 用户登录链接)</strong> 下进行检查。</p><p>有关 IAM 的更多信息，请参阅 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/" target="_blank" rel="noopener">AWS Identity and Access Management 用户指南</a>。</p><h2 id="创建-IAM-角色"><a href="#创建-IAM-角色" class="headerlink" title="创建 IAM 角色"></a>创建 IAM 角色</h2><p>在 Amazon ECS 容器代理可以代表您调用 Amazon ECS API 操作之前，它需要服务的 IAM 策略和角色，以便了解属于您的代理。</p><p>对于使用 EC2 启动类型的任务，您可以创建一个 IAM 角色，该角色可让代理知道应向哪个账户注册容器实例。当您使用 Amazon 通过此角色提供的经 Amazon ECS 优化的 AMI 启动容器实例时，代理会自动将容器实例注册到 <code>default</code> 集群中。此角色称为 Amazon ECS 容器实例 IAM 角色。有关更多信息，请参阅<a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/instance_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 容器实例 IAM 角色</a>。</p><p>Amazon ECS 容器代理还会代表您调用 Amazon EC2 和 Elastic Load Balancing API，以便在负载均衡器中注册和取消注册容器实例。您必须在启动服务前为其创建一个 IAM 角色，然后才能将负载均衡器附加到 Amazon ECS 服务。此要求适用于您计划用于负载均衡器的任意 Amazon ECS 服务。此角色称为 Amazon ECS 服务计划程序 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/service_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 服务计划程序 IAM 角色</a>。</p><p>对于使用 Fargate 启动类型的任务，您可以创建一个 IAM 角色，该角色允许代理从 Amazon ECR 中提取容器映像或者使用 awslogs 日志驱动程序，该驱动程序是当前唯一受支持的此启动类型的日志记录选项。此角色称为 Amazon ECS 任务执行 IAM 角色。有关更多信息，请参阅 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/task_execution_IAM_role.html" target="_blank" rel="noopener">Amazon ECS 任务执行 IAM 角色</a>。</p><p>注意</p><p>在 Amazon ECS 控制台首次运行体验中，将自动为您创建这些 IAM 角色，因此，如果您打算使用控制台，则可以继续下一个部分。如果您不打算使用控制台，而是计划使用 AWS CLI，则需要手动创建这些 IAM 角色。</p><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>对于 Amazon ECS，密钥对只有在您打算使用 EC2 启动类型时才需要。</p><p>AWS 使用公有密钥密码术来保护实例的登录信息。 Linux 实例（例如 Amazon ECS 容器实例）没有用于 SSH 访问的密码。您使用密钥对安全地登录到实例。您可以在启动容器实例时指定密钥对的名称，然后提供私有密钥（使用 SSH 登录时）。</p><p>如果您尚未创建密钥对，则可以通过 Amazon EC2 控制台自行创建。如果您计划在多个区域启动实例，则需要在每个区域中创建密钥对。有关区域的更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p><strong>创建密钥对</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中，选择密钥对所在的区域。您可以选择向您提供的任何区域，无需理会您身处的位置。但是，密钥对特定于区域。例如，如果您计划在美国东部（俄亥俄）区域中启动容器实例，则必须在美国东部（俄亥俄）区域中为实例创建密钥对。</p><p><img src="/AWS/AWS-实战部署/1.png" alt="                         选择一个区域                     "></p></li><li><p>在导航窗格中的 <strong>NETWORK &amp; SECURITY</strong> 下，选择 <strong>Key Pairs</strong>。</p><p>提示</p><p>导航窗格位于控制台的左侧。如果您看不到窗格，它可能被最小化了；请选择箭头展开该窗格。您可能必须向下滚动才能看到 <strong>Key Pairs</strong> 链接。</p><p><img src="/AWS/AWS-实战部署/2.png" alt="                         打开密钥对页                     "></p></li><li><p>选择 <strong>Create Key Pair</strong>。</p></li><li><p>在 <strong>Create Key Pair</strong> 对话框的 <strong>Key pair name</strong> 字段中输入新密钥对的名称，然后选择 <strong>Create</strong>。使用一个容易记住的名称 (如您的 IAM 用户名) 后跟 <code>-key-pair</code> 加区域名称。例如，<em>me</em>-key-pair-<em>useast2</em>。</p></li><li><p>您的浏览器会自动下载私有密钥文件。基本文件名是您为密钥对指定的名称，文件扩展名为 <code>.pem</code>。将私有密钥文件保存在安全位置。</p><p>重要</p><p>这是您保存私有密钥文件的唯一机会。启动实例时，提供密钥对的名称；每次连接到实例时，提供相应的私有密钥。</p></li><li><p>如果您在 macOS 或 Linux 计算机上使用 SSH 客户端连接到您的 Linux 实例，请使用以下命令设置您私有密钥文件的权限，以确保只有您可以读取它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 your_user_name-key-pair-region_name.pem</span><br></pre></td></tr></table></figure></li></ol><p>有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html" target="_blank" rel="noopener">Amazon EC2 密钥对</a>。</p><p><strong>使用密钥对连接到实例</strong></p><p>要从运行 macOS 或 Linux 的计算机连接到 Linux 实例，需要使用 <code>-i</code> 选项对 SSH 客户端指定 <code>.pem</code> 文件和私有密钥的路径。若要从运行 Windows 的计算机连接到 Linux 实例，可以使用 MindTerm 或 PuTTY。如果您计划使用 PuTTY，则需要安装它并遵循以下过程将 <code>.pem</code> 文件转换为 <code>.ppk</code> 文件。</p><p><strong>（可选）准备使用 PuTTY 从 Windows 连接到 Linux 实例</strong></p><ol><li><p>从 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a> 下载并安装 PuTTY。请务必安装整个套件。</p></li><li><p>启动 PuTTYgen（例如，在<strong>开始</strong>菜单中，依次单击<strong>所有程序 &gt; PuTTY &gt; PuTTYgen</strong> ）。</p></li><li><p>在 <strong>Type of key to generate</strong> 下，选择 <strong>RSA</strong>。</p><p><img src="/AWS/AWS-实战部署/3.png" alt="                         PuTTYgen 中的 SSH-2 RSA 密钥                     "></p></li><li><p>选择 <strong>Load</strong>。默认情况下，PuTTYgen 仅显示扩展名为 <code>.ppk</code> 的文件。要找到您的 <code>.pem</code> 文件，请选择显示所有类型的文件的选项。</p><p><img src="/AWS/AWS-实战部署/4.png" alt="                         选择所有文件类型                     "></p></li><li><p>选择您在上一个过程中创建的私有密钥文件，然后选择 <strong>Open</strong>。选择 <strong>OK</strong> 关闭确认对话框。</p></li><li><p>选择 <strong>Save private key (保存私有密钥)</strong>。PuTTYgen 会显示一条警告，提示将在未提供口令的情况下保存密钥。选择<strong>是</strong>。</p></li><li><p>为密钥指定密钥对所用的相同名称。PuTTY 会自动添加 <code>.ppk</code> 文件扩展名。</p></li></ol><h2 id="创建-Virtual-Private-Cloud"><a href="#创建-Virtual-Private-Cloud" class="headerlink" title="创建 Virtual Private Cloud"></a>创建 Virtual Private Cloud</h2><p>Amazon Virtual Private Cloud (Amazon VPC) 允许您在已定义的虚拟网络内启动 AWS 资源。强烈建议您在 VPC 中启动您的容器实例。</p><p>注意</p><p>Amazon ECS 控制台首次运行体验会为您的集群创建 VPC，因此，如果您打算使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您有默认 VPC，也可以跳过此部分并进入下一个任务，即 <a href="https://docs.aws.amazon.com/zh_cn/AmazonECS/latest/developerguide/get-set-up-for-amazon-ecs.html#create-a-base-security-group" target="_blank" rel="noopener">创建安全组</a>。要确定您是否具有默认 VPC，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的 <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html#console-updates" target="_blank" rel="noopener">Amazon EC2 控制台中支持的平台</a>。否则，您可以使用以下步骤在账户中创建非默认 VPC。</p><p>重要</p><p>如果您的账户在某个区域中支持 Amazon EC2 Classic，则您在该区域没有默认 VPC。</p><p><strong>创建非默认 VPC</strong></p><ol><li>打开 Amazon VPC 控制台 <a href="https://console.aws.amazon.com/vpc/" target="_blank" rel="noopener">https://console.aws.amazon.com/vpc/</a>。</li><li>从导航栏中，为 VPC 选择区域。VPC 特定于某一区域，因此您应选择已创建密钥对的区域。</li><li>在 VPC 控制面板上，选择 <strong>Launch VPC Wizard (启动 VPC 向导)</strong>。</li><li>在 <strong>Step 1: Select a VPC Configuration</strong> 页面上，确保选中 <strong>VPC with a Single Public Subnet</strong>，然后选择 <strong>Select</strong>。</li><li>在 <strong>Step 2: VPC with a Single Public Subnet (步骤 2: 带有单个公有子网的 VPC)</strong> 页面上，在 <strong>VPC name (VPC 名称)</strong> 字段中为您的 VPC 输入友好名称。保留其他默认配置设置，然后选择 <strong>Create VPC</strong>。在确认页面上，请选择 <strong>OK</strong>。</li></ol><p>有关 Amazon VPC 的更多信息，请参阅 <em>Amazon VPC 用户指南</em> 中的 <a href="https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/" target="_blank" rel="noopener">Amazon VPC 是什么？</a>。</p><h2 id="创建安全组"><a href="#创建安全组" class="headerlink" title="创建安全组"></a>创建安全组</h2><p>安全组用作相关容器实例的防火墙，可在容器实例级别控制入站和出站流量。您可以向安全组添加规则，以便使用 SSH 从您的 IP 地址连接到容器实例。您还可以添加允许来自任意位置的入站和出站 HTTP 和 HTTPS 访问的规则。向任务所需的开放端口添加任意规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。</p><p>注意</p><p>Amazon ECS 控制台首次运行时会为您的实例创建安全组并根据您使用的任务定义创建负载均衡器，因此，如果要使用 Amazon ECS 控制台，则可以跳到下一个部分。</p><p>如果您计划在多个区域中启动容器实例，则需要在每个区域中创建安全组。有关更多信息，请参阅 <em>Amazon EC2 用户指南（适用于 Linux 实例）</em> 中的<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html" target="_blank" rel="noopener">区域和可用区</a>。</p><p>提示</p><p>您需要本地计算机的公有 IP 地址，可以使用服务获得该地址。例如，我们提供以下服务：<a href="http://checkip./" target="_blank" rel="noopener">http://checkip.amazonaws.com/</a> 或 <a href="https://checkip./" target="_blank" rel="noopener">https://checkip.amazonaws.com/</a>。要查找另一项可提供您的 IP 地址的服务，请使用搜索短语“what is my IP address”。 如果您通过 Internet 服务提供商 (ISP) 连接或者在不使用静态 IP 地址的情况下从防火墙后面连接，则必须找出客户端计算机使用的 IP 地址范围。</p><p><strong>为您的 VPC 创建具有最小特权的</strong></p><ol><li><p>打开 Amazon EC2 控制台 <a href="https://console.aws.amazon.com/ec2/" target="_blank" rel="noopener">https://console.aws.amazon.com/ec2/</a>。</p></li><li><p>从导航栏中选择安全组的区域。安全组特定于某一区域，因此您应选择已创建密钥对的区域。</p></li><li><p>在导航窗格中，选择 <strong>Security Groups</strong>，然后选择 <strong>Create Security Group</strong>。</p></li><li><p>输入新安全组的名称和描述。选择一个您容易记住的名称，例如 <em>ecs-instances-default-cluster</em>。</p></li><li><p>在 <strong>VPC</strong> 列表中，确保选择了您的默认 VPC。它标有星号 (*)。</p><p>注意</p><p>如果您的账户支持 Amazon EC2 Classic，请选择您在上一个任务中创建的 VPC。</p></li><li><p>Amazon ECS 容器实例不需要打开任何入站端口。但您可能需要添加 SSH 规则，以便登录容器实例并使用 Docker 命令检查任务。如果您希望容器实例托管运行 Web 服务器的任务，也可以添加适用于 HTTP 和 HTTPS 的规则。容器实例需要外部网络访问来与 Amazon ECS 服务终端节点通信。完成以下步骤可添加这些可选的安全组规则。</p><p>在 <strong>Inbound</strong> 选项卡上，创建以下规则 (为每个新规则选择 <strong>Add Rule</strong>)，然后选择 <strong>Create</strong>：</p><ul><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTP</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>HTTPS</strong>，确保 <strong>Source</strong> 设置为 <strong>Anywhere</strong> (<code>0.0.0.0/0</code>)。</p></li><li><p>从 <strong>Type</strong> 列表中选择 <strong>SSH</strong>。在 <strong>Source</strong> 字段中，确保选中 <strong>Custom IP</strong>，然后采用 CIDR 表示法指定您计算机或网络的公有 IP 地址。要采用 CIDR 表示法指定单个 IP 地址，请添加路由前缀 <code>/32</code>。例如，如果您的 IP 地址是 <code>203.0.113.25</code>，请指定 <code>203.0.113.25/32</code>。如果您的公司要分配同一范围内的地址，请指定整个范围，例如 <code>203.0.113.0/24</code>。</p><p>重要</p><p>出于安全原因，我们不建议您允许从所有 IP 地址 (<code>0.0.0.0/0</code>) 对您的实例进行 SSH 访问（以测试为目的的短暂访问除外）。</p></li></ul></li></ol><h2 id="安装-AWS-CLI"><a href="#安装-AWS-CLI" class="headerlink" title="安装 AWS CLI"></a>安装 AWS CLI</h2><p>可以在 AWS 管理控制台中手动管理 Amazon ECS 的所有操作。但是，您可以在本地桌面上安装 AWS CLI 或开发人员工具包并生成脚本，以便在 Amazon ECS 中自动执行常见管理任务。</p><p>要对 Amazon ECS 使用 AWS CLI，请安装最新版本的 AWS CLI。有关安装 AWS CLI 或升级到最新版本的信息，请参阅 <em>AWS Command Line Interface 用户指南</em> 中的<a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html" target="_blank" rel="noopener">安装 AWS 命令行界面</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果您已注册 Amazon Web Services (AWS) 并已在使用 Amazon Elastic Compute Cloud (Amazon EC2)，您与使用 Amazon ECS 已近在咫尺。这两个服务的设置过程相似。以下指南将帮助您做好使用 Amazon E
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="ECS" scheme="http://blog.ozairs.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>Splunk入门手册</title>
    <link href="http://blog.ozairs.com/Big-Data/Splunk%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://blog.ozairs.com/Big-Data/Splunk入门手册/</id>
    <published>2019-03-22T04:07:41.000Z</published>
    <updated>2019-03-22T04:20:08.795Z</updated>
    
    <content type="html"><![CDATA[<p>一、关于搜索不同时间段的记录</p><p>*earliest=-24h@h latest=-12h@h</p><p>二、关于搜索不同目录的记录</p><p>*source=”/var/log/ansible.log” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、关于搜索不同时间段的记录&lt;/p&gt;
&lt;p&gt;*earliest=-24h@h latest=-12h@h&lt;/p&gt;
&lt;p&gt;二、关于搜索不同目录的记录&lt;/p&gt;
&lt;p&gt;*source=”/var/log/ansible.log” &lt;/p&gt;

      
    
    </summary>
    
      <category term="Big Data" scheme="http://blog.ozairs.com/categories/Big-Data/"/>
    
    
      <category term="Splunk" scheme="http://blog.ozairs.com/tags/Splunk/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes实战应用</title>
    <link href="http://blog.ozairs.com/Kubernetes/Kubernetes%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.ozairs.com/Kubernetes/Kubernetes实战应用/</id>
    <published>2019-03-20T22:35:07.000Z</published>
    <updated>2019-03-22T02:45:54.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、平台构建"><a href="#一、平台构建" class="headerlink" title="一、平台构建"></a>一、平台构建</h3><p>1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Service Mesh</p><p><a href="https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md" target="_blank" rel="noopener">https://github.com/rootsongjc/kubernetes-vagrant-centos-cluster/blob/master/README-cn.md</a></p><h3 id="二、集群部署命令"><a href="#二、集群部署命令" class="headerlink" title="二、集群部署命令"></a>二、集群部署命令</h3><ol><li><p>运营应用：kubectl run helloworld –image=karthequian/helloworld –port=80</p></li><li><p>查看部署，资源，pods</p><p>kubectl get deployments</p><p>kubectl get rs</p><p>kuebectl get pods</p></li><li><p>部署服务</p><p>kubectl expose deployment helloworld –type=NodePort</p></li><li><p>通过文件方式部署服务和Deployment</p><p>kubectl create -f deploy-all.yml</p></li><li><p>查看服务</p><p>kubectl get services</p></li><li><p>扩展集群服务器</p><p>kubectl scale –replicas=3 deploy/helloworld</p></li><li><p>启动应用</p><p>minikube service helloworld</p></li><li><p>查看所有部署服务</p><p>minikube get all</p></li><li><p>将部署服务导出到YAML文件</p><p>kubectl get deploy/helloworld -o yaml</p></li><li><p>查看服务器集群状态： kubectl cluster-info</p></li><li><p>定位故障</p><p>kubectl describe deploy/depolyname</p><p>kubectl describe po/podname</p><p>kubectl log podname</p><p>登陆到服务节点：kubectl exec -it podname /bin/bash</p><p>如果单节点存在多个Container，登陆到某个服务节点：<code>kubectl exec -it -c containername podname /bin/bash</code></p><p>查看所有服务进程：<code>ps -ef</code></p></li></ol><h3 id="三、图形化管理工具"><a href="#三、图形化管理工具" class="headerlink" title="三、图形化管理工具"></a>三、图形化管理工具</h3><ol><li><p>查看minikube 插件</p><p><code>minikube addons list</code></p><p><code>minikube addon enable heapester</code></p></li></ol><h3 id="四、如何配置数据"><a href="#四、如何配置数据" class="headerlink" title="四、如何配置数据"></a>四、如何配置数据</h3><ol><li><p>To create a configmap for this literal type <code>kubectl create configmap logger --from-literal=log_level=debug</code></p></li><li><p>To see all your configmaps: <code>kubectl get configmaps</code></p></li><li><p>To read the value in the logger configmap: <code>kubectl get configmap/logger -o yaml</code></p></li><li><p>To edit the value, we can run <code>kubectl edit configmap/logger</code></p></li></ol><p>`</p><h3 id="五、如何配置应用密钥"><a href="#五、如何配置应用密钥" class="headerlink" title="五、如何配置应用密钥"></a>五、如何配置应用密钥</h3><ol><li><p>To create a secret: <code>kubectl create secret generic apikey --from-literal=api_key=123456789</code></p></li><li><p>Notice that we can’t read the value of the secret directly:<br><code>kubectl get secret apikey -o yaml</code></p></li><li><p>Understand how to add a secret to a deployment</p><p>​         Adding a secret to a deployment is similar to what we did for configmaps. You can add a secret to the env portion, and start up the deployment with:<br><code>kubectl create -f secretreader-deployment.yaml</code></p></li></ol><h3 id="六、如何创建任务"><a href="#六、如何创建任务" class="headerlink" title="六、如何创建任务"></a>六、如何创建任务</h3><h3 id="How-to-run-jobs"><a href="#How-to-run-jobs" class="headerlink" title="How to run jobs"></a>How to run jobs</h3><p>Jobs are a construct that run a pod once, and then stop. However, unlike pods in deployments, the output of the job is kept around until you decide to remove it.</p><p>Running a job is similar to running a deployment, and we can create this by <code>kubectl create -f simplejob.yaml</code></p><p>To see the output of the job: <code>kubectl get jobs</code></p><p>You can find the pod that ran by doing a <code>kubectl get pods --all-pods</code>, and then get the logs from it as well.</p><h3 id="How-to-run-cron-jobs"><a href="#How-to-run-cron-jobs" class="headerlink" title="How to run cron jobs"></a>How to run cron jobs</h3><p>Cron jobs are like jobs, but they run periodically.</p><p>Start your cron by running <code>kubectl create -f cronjob.yaml</code></p><p>We can use the cronjob api to view your cronjobs: <code>kubectl get cronjobs</code>. It adds the last schedule date</p><h3 id="七、如何创建DaemonSet"><a href="#七、如何创建DaemonSet" class="headerlink" title="七、如何创建DaemonSet"></a>七、如何创建DaemonSet</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、平台构建&quot;&gt;&lt;a href=&quot;#一、平台构建&quot; class=&quot;headerlink&quot; title=&quot;一、平台构建&quot;&gt;&lt;/a&gt;一、平台构建&lt;/h3&gt;&lt;p&gt;1、使用Vagrant和VirtualBox在本地搭建分布式的Kubernetes集群和Istio Serv
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Istio - Kubernetes和云原生系统的服务网格</title>
    <link href="http://blog.ozairs.com/Kubernetes/Istio-Kubernetes%E5%92%8C%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC/"/>
    <id>http://blog.ozairs.com/Kubernetes/Istio-Kubernetes和云原生系统的服务网格/</id>
    <published>2019-03-20T21:17:38.000Z</published>
    <updated>2019-03-20T21:19:23.004Z</updated>
    
    <content type="html"><![CDATA[<p>微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改进授权和安全性，管理路由，收集指标等的能力。点击上面的视频观看剧集并获取所有详细信息。</p><iframe width="987" height="555" src="https://www.youtube.com/embed/rL_p8KIUgwE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong>编辑成绩单</strong><br><em>对于那些喜欢阅读的人，我们已经通过我们的编辑运行成绩单，以获得更顺畅的阅读体验。</em></p><p>如果您在过去几年中一直在微服务领域工作，那么服务网格的概念对您来说可能并不陌生。对于我们其他人来说，它有点诞生于微服务空间带来的一些需求，特别是对可见性，流量路由，身份验证，安全性和指标收集的一些需求。问题源于这样一个事实，即在云空间内，特别是微服务空间，当我们将服务转移到容器中时，这是一种非常常见的模型，我们失去了一些我们能够用来获得经典可见性的仪器单片应用。</p><p>例如，在单一应用程序中，应用程序内的内部服务将通过内部消息传递进行通信，并且这些消息通信范例通常通过应用程序本身内的交互来管理。您基本上可以监视在不同资源之间传递的消息的内存空间。当我们突然去微服务时，不再容易完成。当我们去容器时，我们突然失去了将一些额外服务添加到我们的基础虚拟机中以收集该信息的能力。</p><p>嗯，这就是服务网格概念发挥作用的地方。让我们在所有微服务之间放置一些东西，然后捕获它们之间的所有流量。这会产生一些问题。特别是在分布式系统中，我突然想知道如何管理实际监控和计量我的服务的所有那些交互式小组件。</p><p>随之而来的是Kubernetes，突然之间游戏发生了巨大的变化。并不是我们无法实现这些服务功能，而是现在我们可以直接在各个服务容器本身旁边注入该功能。这通过一种称为服务注入的技术或有效地将另一个容器添加到我们的环境中来完成 然后最重要的是，由于我们通常关注网络流量，我们再次谈到微服务是这种通信的主要模型，我们实际上可以开始在pod中绑定服务，我们实际上是重定向本地流量现在。</p><p>通过这样做，我们解决了微服务所带来的一些问题。特别是监视资源之间通信的能力。这是Google实际带入Istio领域的事情之一，能够有效地捕获这些数据，有效地扩展了容器引擎（cAdvisor引擎）的概念，用于人们在应用程序空间中使用的容器运行时。基本上，然后能够查看应用程序数据流，然后集中该度量数据并可能监视通信。</p><p>一旦我完成了这一切 - 一旦我在那个级别注入了自己 - 我正在看着来回流动的数据包我可以做一些非常有趣的事情。我可以添加身份验证，因此这是IBM为这一组合做出的贡献之一。在路由之上是能够对这些不同服务之间的连接进行排序。路由是我可以控制的另一件事; 任何帧被发送而不是只是说好我将永远转发到负载均衡器，它将分配给n个资源，负载均衡器成为我沟通的一部分。现在我可以确定我实际上要将这些帧发送到哪个目标非常强大。</p><p>由于我有这种控制水平，我甚至可以做一些有趣的事情，比如注入错误。因此，当我开始将我的应用程序分发给这些微服务时，如果出现问题，我很难弄清楚我的应用程序将如何表现。我如何在任何一个特定的微服务中实际强制失败，以检查我的应用程序在遇到这种故障时如何保持弹性？好吧，我现在可以开始注入它作为我的QA或开发过程的一部分，甚至包括生产级别的注入。我可以继续创建故障以确保我的系统继续正常运行，如果不是，我实际上可以提醒它。</p><p>所以这些是微服务网格的一些交互 - 服务网格 - 空间实际提供，而Istio通过可注入代理提供这一点。基本上，我将采用代理引擎，在这种情况下，Istio空间正在使用Envoy代理。Envoy最初由Lyft开发，现在是CNCF的一个开源项目。实际上，Isto也是CNCF的一部分，对于那些没有听说过的人来说，它是Cloud Native Computing Foundation，它是Linux Foundation空间中的一个子基础。</p><p>所以这个服务功能真的是Istio提供的。Istio提供此Envoy代理功能，可以在Kubernetes空间中注入每个容器，或者如果要使用非Kubernetes模型，则将其插入转发路径。使用像Docker这样的容器甚至是虚拟机; 您实际上可以将此代理添加为虚拟机中的进程，并通过该方式注入流量。所以我们可以使用微服务…我们也可以使用大型服务，单片服务，我们可以使用这个服务网格将它们连接在一起。</p><p>但是有了Istio，我们就会获得身份验证，所以因为所有流量都通过这些Envoy代理，我实际上可以验证和结束通信。我可以监控和计量流量，以了解延迟发生的情况; 看看我在路径基础上获得了什么样的吞吐量。我可以将它发送到中央跟踪服务开放跟踪，例如，Jaeger项目是在那里使用的相当常见的项目之一。我也可以像我说的那样开始研究路由。我可以重定向流量并在Kubernetes空间内，例如，我可以使用标签来实际定义我的端点在哪里以及应该在哪里提供服务。</p><p>这一切都非常强大，但现在我也有中央控制权。这是这个Istio带来的最后一件事 - 中央证书控制。这对TLS身份验证很重要。使用名为Mixer的工具收集中心指标，实际上将所有指标数据收集在一起，然后集中配置控制，这实际上是为什么Envoy被选为代理。因为使用Envoy，我现在有一个中央控制器，可以将配置分发到该网格内的所有分布式代理。Envoy以非常有效的方式实现这一点，因为它实际上不需要重新配置重启; 它可以进行热重新配置 - 一个非常强大的功能！</p><p>因此，服务网格是微服务空间的重要组成部分。它真正改变了微服务如何拼接在一起，如何对它们进行计量/监控，甚至通过从具有安全性的集中控制平面注入故障来改善这些服务的性能和弹性。所以在这一大捆绑中有很多东西，但那真的是Istio的能力。更一般地说，它是云本机引擎中更大的服务网格空间的一部分，它真正接管了当今应用程序的构建方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微服务，尤其是基于云原生的基于容器的微服务，彻底改变了应用程序的构建和部署方式。这种转变受到基于容器的微服务提供的许多积极因素的驱动（例如速度，可移植性……）。但是，传统的监控工具并不适用于这些新系统。服务网格概念（特别是服务网格的Isto实现）带来了重新获得系统可见性，改
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Istio" scheme="http://blog.ozairs.com/tags/Istio/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Ant简介以及两者的区别</title>
    <link href="http://blog.ozairs.com/DevOps/Maven%E5%92%8CAnt%E7%AE%80%E4%BB%8B%E4%BB%A5%E5%8F%8A%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://blog.ozairs.com/DevOps/Maven和Ant简介以及两者的区别/</id>
    <published>2019-03-20T20:59:39.000Z</published>
    <updated>2019-03-20T21:02:59.763Z</updated>
    
    <content type="html"><![CDATA[<p>一．Maven简介<br>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。<br>目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代工具）不能满足绝大多数开发人员的需要。通过检查 Ant 构建文件，很难发现项目的相关性信息和其它信息（如开发人员/拥有者、版本或站点主页）。<br>Maven 除了以程序构建能力为特色之外，还提供 Ant 所缺少的高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目，而使用 Ant 则需要十几行。事实上，由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目现在使用 Maven，而且公司项目采用 Maven 的比例在持续增长。<br>Maven这个单词来自于意第绪语，意为知识的积累，最早在Jakata Turbine项目中它开始被用来试图简化构建过程。当时有很多项目，它们的Ant build文件仅有细微的差别，而JAR文件都由CVS来维护。于是Maven创始者开始了Maven这个项目，该项目的清晰定义包括，一种很方便的发布项目信息的方式，以及一种在多个项目中共享JAR的方式.<br>二．Maven常用命令<br>mvn archetype：create 创建Maven项目<br>mvn compile 编译源代码<br>mvn deploy 发布项目<br>mvn test-compile 编译测试源代码<br>mvn test 运行应用程序中的单元测试<br>mvn site 生成项目相关信息的网站<br>mvn clean 清除项目目录中的生成结果<br>mvn package 根据项目生成的jar<br>mvn install 在本地Repository中安装jar<br>mvn eclipse:eclipse 生成eclipse项目文件<br>mvnjetty:run 启动jetty服务<br>mvntomcat:run 启动tomcat服务</p><pre><code>Ant</code></pre><p>Ant简介<br>Ant是一种基于Java的build工具。理论上来说，它有些类似于（Unix）C中的make ，但没有make的缺陷。目前的最新版本为：Ant 1.9.1<br>既然我们已经有了make, gnumake, nmake, jam以及其他的build工具为什么还要要一种新的build工具呢？因为Ant的原作者在多种(硬件)平台上开发软件时，无法忍受这些工具的限制和不便。类似于make的工具本质上是基于shell（语言）的：他们计算依赖关系，然后执行命令（这些命令与你在命令行敲的命令没太大区别）。这就意味着你可以很容易地通过使用OS特有的或编写新的（命令）程序扩展该工具；然而，这也意味着你将自己限制在了特定的OS，或特定的OS类型上，如Unix。<br>Ant就不同了。与基于shell命令的扩展模式不同，Ant用Java的类来扩展。（用户）不必编写shell命令，配置文件是基于XML的，通过调用target树，就可执行各种task。每个task由实现了一个特定Task接口的对象来运行。<br>当一个代码项目大了以后，每次重新编译，打包，测试等都会变得非常复杂而且重复，因此c语言中有make脚本来帮助这些工作的批量完成。在Java 中应用是平台无关性的，当然不会用平台相关的make脚本来完成这些批处理任务了，ANT本身就是这样一个流程脚本引擎，用于自动化调用程序完成项目的编译，打包，测试等。除了基于JAVA是平台无关的外，脚本的格式是基于XML的，比make脚本来说还要好维护一些。<br>每个ant脚本（缺省叫build.xml）中设置了一系列任务(target)：比如对于一个一般的项目可能需要有以下任务。</p><ul><li>任务1：usage 打印本脚本的帮助信息（缺省）</li><li>任务2：clean &lt;– init 清空初始化环境</li><li>任务3：javadoc &lt;– build &lt;– init 生成JAVADOC</li><li>任务4：jar &lt;– build &lt;– init 生成JAR</li><li>任务5：all &lt;– jar + javadoc &lt;– build &lt;– init 完成以上所有任务：jar javadoc<br>注：我看到很多项目的ant脚本中的命名基本上都是一致的，比如：编译一般叫build或者compile；打包一般叫jar或war；生成文档一般命名为 javadoc或javadocs；执行全部任务all。在每个任务的中，ANT会根据配置调用一些外部应用并配以相应参数执行。虽然ANT可调用的外部应用种类非常丰富，但其实最常用的就2，3个：比如javac javadoc jar等。<br>二．Ant的优点<br>Ant是Apache软件基金会JAKARTA目录中的一个子项目，它有以下的优点。<br>跨平台性。Ant是纯Java语言编写的，因此具有很好的跨平台性。<br>操作简单。Ant是由一个内置任务和可选任务组成的。Ant运行时需要一个XML文件(构建文件)。<br>Ant通过调用target树，就可以执行各种task。每个task实现了特定接口对象。由于Ant构建文件时XML格式的文件，所以很容易维护和书写，而且结构很清晰。<br>Ant可以集成到开发环境中。由于Ant的跨平台性和操作简单的特点，它很容易集成到一些开发环境中去。<br>三．Ant 开发<br>Ant的构建文件<br>当开始一个新的项目时，首先应该编写Ant构建文件。构建文件定义了构建过程，并被团队开发中每个人使用。Ant构建文件默认命名为build.xml，也可以取其他的名字。只不过在运行的时候把这个命名当作参数传给Ant。构建文件可以放在任何的位置。一般做法是放在项目顶层目录中，这样可以保持项目的简洁和清晰。下面是一个典型的项目层次结构。<br>(1) src存放文件。<br>(2) class存放编译后的文件。<br>(3) lib存放第三方JAR包。<br>(4) dist存放打包，发布以后的代码。<br>Ant构建文件是XML文件。每个构建文件定义一个唯一的项目(Project元素)。每个项目下可以定义很多目标(target元素)，这些目标之间可以有依赖关系。当执行这类目标时，需要执行他们所依赖的目标。<br>每个目标中可以定义多个任务，目标中还定义了所要执行的任务序列。Ant在构建目标时必须调用所定义的任务。任务定义了Ant实际执行的命令。Ant中的任务可以为3类。<br>（1） 核心任务。核心任务是Ant自带的任务。<br>（2） 可选任务。可选任务实来自第三方的任务，因此需要一个附加的JAR文件。<br>（3） 用户自定义的任务。用户自定义的任务是用户自己开发的任务。<br>1.<project>标签<br>每个构建文件对应一个项目。<project>标签时构建文件的根标签。它可以有多个内在属性，就如代码中所示，其各个属性的含义分别如下。<br>(1) default表示默认的运行目标，这个属性是必须的。<br>(2) basedir表示项目的基准目录。<br>(3) name表示项目名。<br>(4) description表示项目的描述。<br>每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有自己的构建文件。<br>2.<target>标签<br>一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。<br>例如，有一个target用于编译程序，另一个target用于生成可执行文件。在生成可执行文件之前必须先编译该文件，因此可执行文件的target依赖于编译程序的target。Target的所有属性如下。<br>(1).name表示标明，这个属性是必须的。<br>(2).depends表示依赖的目标。<br>(3)if表示仅当属性设置时才执行。<br>(4)unless表示当属性没有设置时才执行。<br>(5)description表示项目的描述。<br>Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行每个target。在执行之前，首先需要执行它所依赖的target。程序中的名为run的target的depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执行的顺序是prepare-&gt;compile-&gt;run。<br>一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总会被执行。<br>3.<mkdir>标签<br>该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：<br><mkdir dir="”${class.root}”/"><br>通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。<br>4<jar>标签<br>该标签用来生成一个JAR文件，其属性如下。<br>(1) destfile表示JAR文件名。<br>(2) basedir表示被归档的文件名。<br>(3) includes表示被归档的文件模式。<br>(4) exchudes表示被排除的文件模式。<br>5．&lt;javac标签&gt;<br>该标签用于编译一个或一组java文件，其属性如下。<br>(1).srcdir表示源程序的目录。<br>(2).destdir表示class文件的输出目录。<br>(3).include表示被编译的文件的模式。<br>(4).excludes表示被排除的文件的模式。<br>(5).classpath表示所使用的类路径。<br>(6).debug表示包含的调试信息。<br>(7).optimize表示是否使用优化。<br>(8).verbose 表示提供详细的输出信息。<br>(9).fileonerror表示当碰到错误就自动停止。<br>6．<java>标签<br>该标签用来执行编译生成的.class文件，其属性如下。<br>(1).classname 表示将执行的类名。<br>(2).jar表示包含该类的JAR文件名。<br>(3).classpath所表示用到的类路径。<br>(4).fork表示在一个新的虚拟机中运行该类。<br>(5).failonerror表示当出现错误时自动停止。<br>(6).output 表示输出文件。<br>(7).append表示追加或者覆盖默认文件。<br>7.<delete>标签<br>该标签用于删除一个文件或一组文件，其属性如下。<br>(1)/file表示要删除的文件。<br>(2).dir表示要删除的目录。<br>(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。<br>(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。<br>(5).verbose表示指定是否列出所删除的文件，默认值为不列出。<br>8.<copy>标签<br>该标签用于文件或文件集的拷贝，其属性如下。<br>(1).file 表示源文件。<br>(2).tofile 表示目标文件。<br>(3).todir 表示目标目录。<br>(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。<br>(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。<br>(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。<br>(7).verbose 表示制定是否显示详细信息，默认值不显示。<br>四．Ant的数据类型<br>在构建文件中为了标识文件或文件组，经常需要使用数据类型。数据类型包含在org.apache.tool.ant.types包中。下面镜简单介绍构建文件中一些常用的数据类型。</copy></delete></java></jar></mkdir></mkdir></target></project></project></li></ul><ol><li><p>argument 类型<br>由Ant构建文件调用的程序，可以通过<arg>元素向其传递命令行参数，如apply,exec和java任<br>务均可接受嵌套<arg>元素，可以为各自的过程调用指定参数。以下是<arg>的所有属性。<br>(1).values 是一个命令参数。如果参数中有空格，但又想将它作为单独一个值，则使用此属性。<br>(2).file表示一个参数的文件名。在构建文件中，此文件名相对于当前的工作目录。<br>(3).line表示用空格分隔的多个参数列表。<br>(4).path表示路径。<br>2.ervironment 类型<br>由Ant构建文件调用的外部命令或程序，<env>元素制定了哪些环境变量要传递给正在执行的系统命令，<env>元素可以接受以下属性。<br>(1).file表示环境变量值的文件名。此文件名要被转换位一个绝对路径。<br>(2).path表示环境变量的路径。Ant会将它转换为一个本地约定。<br>(3).value 表示环境变量的一个直接变量。<br>(4).key 表示环境变量名。<br>注意 file path 或 value只能取一个。<br>3.filelist类型<br>Filelist 是一个支持命名的文件列表的数据类型，包含在一个filelist类型中的文件不一定是存在的文件。以下是其所有的属性。<br>(1).dir是用于计算绝对文件名的目录。<br>(2).files 是用逗号分隔的文件名列表。<br>(3).refid 是对某处定义的一个<filelist>的引用。<br>注意 dir 和 files 都是必要的，除非指定了refid(这种情况下，dir和files都不允许使用)。<br>4.fileset类型<br>Fileset 数据类型定义了一组文件，并通常表示为<fileset>元素。不过，许多ant任务构建成了隐式的fileset,这说明他们支持所有的fileset属性和嵌套元素。以下为fileset 的属性列表。<br>(1).dir表示fileset 的基目录。<br>(2).casesensitive的值如果为false，那么匹配文件名时，fileset不是区分大小写的，其默认值为true.<br>(3).defaultexcludes 用来确定是否使用默认的排除模式，默认为true。<br>(4).excludes 是用逗号分隔的需要派出的文件模式列表。<br>(5).excludesfile 表示每行包含一个排除模式的文件的文件名。<br>(6).includes 是用逗号分隔的，需要包含的文件模式列表。<br>(7).includesfile 表示每行包括一个包含模式的文件名。<br>5.patternset 类型<br>Fileset 是对文件的分组，而patternset是对模式的分组，他们是紧密相关的概念。<patternset>支持4个属性：includes excludex includexfile 和 excludesfile,与fileset相同。Patternset 还允许以下嵌套元素：include,exclude,includefile 和 excludesfile.<br>6.filterset 类型<br>Filterset定义了一组过滤器，这些过滤器将在文件移动或复制时完成文件的文本替换。<br>主要属性如下：<br>(1).begintoken 表示嵌套过滤器所搜索的记号，这是标识其开始的字符串。<br>(2).endtoken表示嵌套过滤器所搜索的记号这是标识其结束的字符串。<br>(3).id是过滤器的唯一标志符。<br>(4).refid是对构建文件中某处定义一个过滤器的引用。<br>7.Path类型<br>Path元素用来表示一个类路径，不过它还可以用于表示其他的路径。在用作几个属性时，路经中的各项用分号或冒号隔开。在构建的时候，此分隔符将代替当前平台中所有的路径分隔符，其拥有的属性如下。<br>(1).location 表示一个文件或目录。Ant在内部将此扩展为一个绝对路径。<br>(2).refid 是对当前构建文件中某处定义的一个path的引用。<br>(3).path表示一个文件或路径名列表。<br>8.mapper类型<br>Mapper类型定义了一组输入文件和一组输出文件间的关系，其属性如下。<br>(1).classname 表示实现mapper类的类名。当内置mapper不满足要求时，用于创建定制mapper.<br>(2).classpath表示查找一个定制mapper时所用的类型路径。<br>(3).classpathref是对某处定义的一个类路径的引用。<br>(4).from属性的含义取决于所用的mapper.<br>(5).to属性的含义取决于所用的mapper.<br>(6).type属性的取值为identity，flatten glob merge regexp 其中之一，它定义了要是用的内置mapper的类型。<br>五．Ant的安装<br>解包后在系统可执行路径中加入指向ant的bin的路径就可以了，比如可以在GNU/Linux上把以下配置加入/etc/profile中：<br>export ANT_HOME=/home/ant<br>export JAVA_HOME=/usr/java/j2sdk1.4.1<br>export PATH=$PATH:$JAVA_HOME/bin:$ANT_HOME/bin<br>Windows 下的安装：<br>下载后解压到某个目录我这里以D:\apache-ant-1.7.1为例子：<br>添加path全局环境变量:D:\apache-ant-1.7.1\bin<br>这样在command line就可以运行ant命令了<br>测试：运行-&gt;cmd/command-&gt;ant 如果没有安装成功则回报找不到这个命令，安装成功会有相关的提示信息显示。<br>这样执行ant 后，如果不指定配置文件ant会缺省找build.xml这个配置文件，并根据配置文件执行任务，缺省的任务设置可以指向最常用的任务，比如： build，或指向打印帮助信息：usage，告诉用户有那些脚本选项可以使用。<br>六．Ant的运行<br>安装好Ant并且配置好路径之后，在命令行中切换到构建文件的目录，输入Ant命令就可以运行Ant.若没有指定任何参数，Ant会在当前目录下查询build.xml文件。如果找到了就用该文件作为构建文件。如果使用了 –find 选项，Ant 就会在上级目录中找构建文件，直至到达文件系统的根目录。如果构建文件的名字不是build.xml ，则Ant运行的时候就可以使用 –buildfile file,这里file 指定了要使用的构建文件的名称，示例如下：<br>Ant如下说明了表示当前目录的构建文件为build.xml 运行 ant 执行默认的目标。<br>Ant –buildfile test.xml<br>使用当前目录下的test.xml 文件运行Ant ,执行默认的目标</patternset></fileset></filelist></env></env></arg></arg></arg></p><pre><code>Moven与Ant的区别</code></pre><p>Maven 和 Ant 针对构建问题的两个不同方面。Ant 为 Java 技术开发项目提供跨平台构建任务。Maven 本身描述项目的高级方面，它从 Ant 借用了绝大多数构建任务。因此，由于 Maven 和 Ant 代表两个差异很大的工具，所以接下来只说明这两个工具的等同组件之间的区别。</p></li></ol><p>Maven Ant<br>标准构建文件 project.xml 和 maven.xml build.xml<br>特性处理顺序 ${maven.home}/bin/driver.properties<br>${project.home}/project.properties<br>${project.home}/build.properties<br>${user.home}/build.properties<br>通过 -D 命令行选项定义的系统特性<br>最后一个定义起决定作用。 通过 -D 命令行选项定义的系统特性<br>由 <property> 任务装入的特性<br>第一个定义最先被处理。<br>构建规则 构建规则更为动态（类似于编程语言）；它们是基于 Jelly 的可执行 XML。 构建规则或多或少是静态的，除非使用 <script> 任务。（请参阅 参考资料以获得相关教程。）<br>扩展语言 插件是用 Jelly（XML）编写的。 插件是用 Java 语言编写的。<br>构建规则可扩展性 通过定义 <preGoal> 和 <postGoal> 使构建 goal 可扩展。 构建规则不易扩展；可通过使用 <script> 任务模拟 <preGoal> 和 <postGoal> 所起的作用。<br>Maven是一个项目管理工具，它包含了一个项目对象模型 (Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。当你使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自一组共享的（或者自定义的）插件。</p></script></property></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一．Maven简介&lt;br&gt;Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。&lt;br&gt;目前，绝大多数开发人员都把 Ant 当作 Java 编程项目的标准构建工具。遗憾的是，Ant 的项目管理工具（作为 make的替代
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Maven" scheme="http://blog.ozairs.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation经验贴汇总</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation经验贴汇总/</id>
    <published>2019-03-19T12:30:11.000Z</published>
    <updated>2019-03-19T13:02:08.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CloudFormation两年：经验教训"><a href="#1-CloudFormation两年：经验教训" class="headerlink" title="1. CloudFormation两年：经验教训"></a>1. CloudFormation两年：经验教训</h2><p><a href="https://www.colabug.com/4023693.html" target="_blank" rel="noopener">https://www.colabug.com/4023693.html</a></p><h1 id="2-您的基础架构代码CloudFormation与Terraform？"><a href="#2-您的基础架构代码CloudFormation与Terraform？" class="headerlink" title="2.您的基础架构代码CloudFormation与Terraform？"></a>2.您的基础架构代码CloudFormation与Terraform？</h1><p><a href="https://www.colabug.com/3313548.html" target="_blank" rel="noopener">https://www.colabug.com/3313548.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CloudFormation两年：经验教训&quot;&gt;&lt;a href=&quot;#1-CloudFormation两年：经验教训&quot; class=&quot;headerlink&quot; title=&quot;1. CloudFormation两年：经验教训&quot;&gt;&lt;/a&gt;1. CloudFormatio
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>使用Cloud Formation为AWS上的私有实例设置绝对可靠的Bastion节点</title>
    <link href="http://blog.ozairs.com/AWS/%E4%BD%BF%E7%94%A8Cloud-Formation%E4%B8%BAAWS%E4%B8%8A%E7%9A%84%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E7%BB%9D%E5%AF%B9%E5%8F%AF%E9%9D%A0%E7%9A%84Bastion%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.ozairs.com/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/</id>
    <published>2019-03-19T10:43:25.000Z</published>
    <updated>2019-03-19T10:47:22.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg" alt=""></p><p>在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是在实例的安全组的入站规则中简单地允许端口22上的SSH流量，然后通过弹性IP和Internet网关将实例暴露给公共Internet。然而，由于攻击者可能很容易访问您的安全密钥对，并且如果这样的密钥对也可用于其他私有实例，则这会变得有缺陷，那么此类攻击者可以完全访问和控制您的基础结构。</p><p>为了避免这种情况，公司现在使用遍布所有可用区域（AZ）的堡垒实例，其中已经设置了基础架构。Bastion节点是一个专门的实例，故意暴露在互联网上，其设计和配置仅限于遭受攻击的唯一原因。看到堡垒节点暴露在非军事区（DMZ）的公共互联网中，面临潜在攻击的大量风险，因此有必要确保堡垒节点完全万无一失。本文提供了如何设置可靠的堡垒节点的实用见解。使用CloudFormation是因为它通过简单地调整云形成模板中的一些参数，简化了为每个AZ设置堡垒实例的整个瓶颈。</p><p><strong>先修知识：</strong></p><ol><li>基本了解以下Amazon Web服务/概念：EC2，VPC，子网，NAT，安全组和访问控制列表（ACL）</li><li>对云形成的基本认识。</li></ol><p>我们将在10.6.0.0/16 VPC中考虑在10.6.0.0/24子网上具有私有实例的假设网络。此外，我们的堡垒实例应存在于10.5.0.0/24子网中的10.5.0.0/16 VPC中，如下图所示：</p><p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/2.png" alt="img"></p><p>从上图可以看出，NAT网关也已添加到架构中。这为我们的私有实例提供了额外的安全层，只要他们需要访问公共互联网进行软件更新。NAT网关允许来自私有实例的所有出站流量，但阻止从Internet到私有实例的所有始发流量。使用NAT网关，因为我们只想允许来自堡垒节点的SSH流量并阻止来自互联网的所有其他流量。出于简化/清晰的目的，有意地从上面的图中省略了每个实例的安全组信息，但是应该在云形成模板中进行研究。该图还包含10.6.0的访问控制列表（ACL）信息。<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html" target="_blank" rel="noopener">有状态的</a>。我们将在以下部分中探索Bastion节点，私有实例和NAT网关的配置细节：</p><p><strong>堡垒节点</strong></p><p>它存在于自己的VPC中，该VPC暴露于Internet网关并使用VPC对等连接与VPC2（我们的私有实例的VPC）进行通信。互联网网关已与VPC相关联，并且已将弹性IP（EIP）分配给堡垒节点以允许来自互联网的流量。</p><p>路由表清楚地表明，除了10.5.0.0/16和10.6.0.0/16网络之外，所有来自堡垒节点的出站流量都应通过互联网网关转发。发往10.6.0.0/16的流量应使用VPC对等连接作为网关，这样，SSH流量就可以到达我们的私有实例。</p><p>对于安全组，我们只允许来自/到公共互联网的所有SSH流量并阻止所有其他流量。以下是使用云形成实现这一目标的方法：</p><p><strong>私有集群中的实例</strong></p><p>我们决定将我们的假设私有集群放在10.6.0.0/24子网上。路由表描述了发往10.5.0.0/16网络的所有流量都应使用对等连接作为网关。特定于Internet的出站流量使用NAT实例作为网关。</p><p>对于安全组，我们仅允许来自10.5.0.0/24子网的SSH流量和来自Internet上的Internet（0.0.0.0/0）的HTTP / HTTPS流量，并拒绝所有其他协议。</p><p>要添加额外的安全层，我们使用ACL，仅允许SSH，HTTP和HTTPS流量，如上图所示，同时显示入口和出口。由于NAT网关请求此端口以便与私有实例通信，因此端口1024-65535已保持打开以进行<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html#VPC_ACLs_Ephemeral_Ports" target="_blank" rel="noopener">短暂</a>连接。下面使用此云形成模板显示：</p><p><strong>NAT网关</strong></p><p>NAT网关也已放置在自己的10.6.1.0/24子网中。路由表描述了互联网的所有出站流量应使用Internet网关正确分段网络，因为NAT不需要访问对等连接。</p><p>NAT网关的安全组仅允许来自Internet的HTTP和HTTPs流量。以下是云形成如何实现：</p><p>现在我们有了堡垒架构的完整设置。还剩下最后一件事就是<a href="https://brainsik.net/2011/ssh-agent-forwarding/" target="_blank" rel="noopener">SSH Agent Forwarding</a></p><p><strong>SSH代理转发</strong></p><p>为什么需要这个？我们可以简单地进入堡垒，然后跳转到我们的任何私有实例中。为什么这是真的，这是一个巨大的安全风险。有权访问堡垒主机的任何人都可以访问其他所有用户的私钥，并可以模拟该用户。因此，凭证不应存储在堡垒主机上，而应通过<em>SSH代理</em>转发从本地计算机转发到堡垒<em>。</em></p><p><code>-A</code>使用SSH命令添加一段时间应该将您的本地凭据转发到下一台机器上，但是，我们将通过<strong>〜/ .ssh / config</strong>文件进行此配置以简化我们的生活并避免尝试在每次ssh尝试时转发代理。</p><p>将以下行添加到ssh配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host bastion</span><br><span class="line">  HostName       [Bastion Public Ip address]</span><br><span class="line">  User           ec2-user #For example</span><br><span class="line">  IdentityFile   [Path to Identity file]</span><br><span class="line">  ForwardAgent    Yes</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果该文件不存在，您可以直接触摸该文件<code>touch ~/.ssh/config</code></p><p>现在，我们可以简单地说<code>ssh bastion</code>，我们可以进入我们的堡垒实例，我们可以从中跳转到所有其他实例。</p><p>为了进一步简化，我们可以将以下行添加到文件<code>~/.bashrc</code>或<code>~/.zshrc</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ssh-instance（）&#123; </span><br><span class="line">  BASTION_USER =＃你的堡垒用户名</span><br><span class="line">  BASTION_IP =＃你的堡垒IP </span><br><span class="line">  SSH_OPTIONS =“ProxyCommand ssh -q -A -W％h：％p $ BASTION_USER @ $ BASTION_IP” </span><br><span class="line">  ssh $ 1 @ $ 2 -o $ SSH_OPTIONS </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件，通过它来源<code>source ~/.bashrc</code>，现在你可以简单地说<code>ssh-instance ec2-user [my instance ip]</code>，瞧，你直接进入你的私人实例，而不必首先通过堡垒。</p><p><strong>其他提示</strong></p><p>建议对堡垒节点和私有实例使用不同的ssh密钥，并经常轮换这些密钥以减少攻击者获取访问权限的可能性。</p><p>此外，专用的SysAdmin或DevOps工程师还可以在每个堡垒节点中设置用户组，并创建分配给具有各种管理权限的这些不同用户组的用户。应将每个用户的公共ssh密钥复制到<code>~/.ssh/authorized_keys</code>文件中。</p><p><strong>结论</strong></p><p>本文探讨了如何在AWS上为我们的私有实例设置一个万无一失的堡垒节点，而不会在需要系统/软件更新时损害这些实例的Internet可访问性。</p><p>本文的云形成模板可以在这里找到：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">https</a>：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">//github.com/nwochaadim/BastionNode-with-CloudFormation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>玩转Jenkins Pipeline</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%8E%A9%E8%BD%ACJenkins-Pipeline/"/>
    <id>http://blog.ozairs.com/Jenkins/玩转Jenkins-Pipeline/</id>
    <published>2019-03-18T08:47:54.000Z</published>
    <updated>2019-03-18T08:51:11.320Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins Pipeline的总体介绍<br>1.Jenkins Pipeline 的核心概念</p><p>Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。</p><p>Pipeline是Jenkins2.X的最核心的特性，帮助Jenkins实现从CI到CD与DevOps的转变</p><p>Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。</p><p>持续交付管道（CD Pipeline）是将软件从版本控制阶段到交付给用户或客户的完整过程的自动化表现。软件的每一次更改（提交到源代码管理系统）都要经过一个复杂的过程才能被发布。</p><p>Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language（DSL）syntax可以达到Pipeline as Code（Jenkinsfile存储在项目的源代码库）的目的。</p><p>Stage：阶段，一个Pipeline可以划分成若干个Stage，每个Stage代表一组操作，例如：“Build”，“Test”，“Deploy”。</p><p>注意，Stage是一个逻辑分组的概念，可以跨多个Node</p><p>Node：节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行环境。</p><p>Step：步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenklins Plugin提供，例如：sh ‘make’</p><p>Pipeline五大特性</p><p>1、代码:Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑、审查和迭代其CD流程。<br>2、可持续性：Jenklins重启或者中断后都不会影响Pipeline Job。<br>3、停顿：Pipeline可以选择停止并等待任工输入或批准，然后再继续Pipeline运行。<br>4、多功能：Pipeline支持现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力<br>5、可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。</p><p>Pipeline和Freestyle的区别</p><p>Freestyle：<br>上游/下游Job调度，如<br>BuildJob —&gt; TestJob —&gt; DeployJob<br>在DSL Job里面调度多个子Job（利用Build Flow Plugin）</p><p>Pipeline：<br>单个Job中完成所有的任务编排<br>全局视图</p><p>Multibranch Pipeline根据你的代码中Jenlinsfile自动创建Job</p><p>Jenlins Pipeline的基础语法<br>Pipeline脚本是由Groovy语言实现（无需专门学习）</p><p>支持两种语法<br>Declarative 声明式（在Pipeline plugin 2.5中引入）<br>Scripted Pipeline 脚本式</p><p>如何创建最基本的PIpeline<br>直接在Jenkins Web UI 网页界面中输入脚本<br>通过创建一个jenkinsfile可以检入项目的源代码管理库</p><p>通常推荐在Jenkins中直接从源代码控制（SCM）中载入Jenklinsfile Pipeline</p><p>声明式Pipeline</p><p>声明式Pipeline的基本语法和表达式遵循与Groovy语法相同的规则，但有以下例外：</p><p>声明式pipeline必须包含在固定格式pipeline{}快内<br>每个声明语句必须独立一行，行尾无需使用分号<br>块（blocks{}）只能包含章节（Sections），指令（Directives），步骤（Steps）或赋值语句<br>属性引用语句被视为无参数方法调用。例：输入被视为 input()<br>块（blocks{}）<br>由大括号括起来的语句，如pipeline{},Section{},parameters{},script{}<br>章节（Sections）<br>通常包含一个或多个指令或步骤。如 agent 、post、stages、steps<br>指令（Directives）<br>environment、options、parameters、triggers（触发）、stage、tools、when<br>步骤（Steps）<br>Pipeline steps reference<br>执行脚本式pipeline：使用script{}</p><p>agent<br>必须存在，agent必须在pipeline块内的顶层定义，但stage内是否使用使可选的<br>参数：any/none/label/node/docker/dockerfile<br>常用选项 label/cuetomWorkspace/reuseNode</p><p>示例</p><p>agent { label ‘my-label’ }</p><p>agent {<br>    node {<br>        label ‘my-label’<br>        customWorkspace ‘/some/other/path’<br>    }<br>}</p><p>agent {<br>    docker {<br>        image ‘nginx:1.12.2’<br>        label ‘my-label’<br>        args ‘-v /tmp:/tmp’<br>    }<br>}</p><p>post 不是必须的，用于pipeline的最外层或者stage{}中</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps {<br>            echo ‘Hello world’<br>            }<br>        }<br>    }<br>    post {<br>        always {<br>            echo ‘say goodbay’<br>        }<br>    }<br>}</p><p>stages 必须，包括顺序执行的一个或多个stage命令，在pipeline内仅能使用一次，通常位于agent/options后面，例子如上</p><p>steps 必须，steps位于stage指令块内部，包括一个或多个step。仅有一个step的情况下可以忽略关键字step及其{},例子如上</p><p>environment 不是必须的，environment定义了一组全局的环境变量键值对，存在于pipeline{}或者stage指令内。执行特殊方法credentials()可以获取jenkins中预定义的凭证明文内容</p><p>environment {CC=’clang’}<br>environment {AN_ACCESS_KEY = credentials(‘my-prefined-secret-text’)}<br>steps {sh ‘printenv’}</p><p>options 不是必须的 预定义pipeline专有的配置信息，仅可定义一次</p><p>pipeline {<br>    agent any<br>    options{<br>    timeout(time:1,unit: ‘HOURS’)<br>    }<br>    …<br>}</p><p>parameters 不是必须的 定义参数化构建的参数可选参数 booleanParam,choice,file,text,password,run,string</p><p>paramenters {<br>    choice(name:’PerformMavenRelease’,choices:’False\nTrue’,description:’desc’)<br>    password(name:’CredsToUse’,description:’Apassword to build with’,defaultValue:’’)<br>}<br>environment {<br>    BUILD_USR_CHOICE=”${params.PerformMavenRelease}”<br>    BUILD_USR_CREDS=”${params.CredsToUse}”<br>}</p><p>triggers 不是必须的 定义pipeline被自动触发的方式选项 cron、pollSCM、upstream</p><p>triggers {cron(‘H 4/<em> 0 0 1-5’)}<br>triggers {pollSCM(‘H 4/</em> 0 0 1-5’)}<br>triggers {upstream(upstreamProjects:’job1,job2’,threshold:hudson.model.Result.SUCCESS)}</p><p>快速创建一个pipeline<br>新建 选择pipeline 填写Job 的名字 </p><p>填写相应的pipeline script</p><p>pipeline{<br>    agent any<br>    stages {<br>        stage(‘Build’) {<br>            steps{<br>                echo ‘This is a build step’<br>            }<br>        }<br>        stage(‘Test’) {<br>            steps{<br>                echo ‘This is a test step’<br>            }<br>        }<br>        stage(‘Deploy’) {<br>            steps{<br>                echo ‘This is a deploy step’<br>            }<br>        }<br>    }<br>}<br>1</p><p>保存之后，立即构建</p><p>常用的辅助工具</p><p>Snipper Generator（代码片段生成器，语法检查器）<br>Replay Pipeline（重放pipeline，可以修改script，修改后的不存入config.xml）<br>DSL Reference 语法参考手册<br>全局变量引用<br>Stage View<br>BlueOcean(可视化)<br>Pipeline神器：可视化编辑器<br>命令行Pipeline调试工具<br>变量的传递</p><p>自定义变量（局部）<br>def username = ‘Jenkins’<br>echo “Hello Mr.${username}”</p><p>#注意一定要用双引号，单引号识别为字符串</p><p>环境变量（局部）<br>withEnv([‘MYTOOL_HOME=/usr/local/mytool’]){<br>    sh ‘$MYTOOL_HOME/bin/start’<br>}<br>1<br>2<br>3<br>环境变量（全局）<br>environment {CC=’clang’}<br>echo “Compiler is ${env.CC}”</p><p>参数化构建（全局）<br>parameters {string(name:’Jenkins’,defaultValue:’Hello’,description:’How should I greet the world’)}<br>ehco “${params.Greeting} World!”</p><p>判断<br>when仅用于stage内部<br>when的内置条件为：</p><ul><li>when {branch ‘master’}</li><li>when {environment name:’DEPLOY_TO’,value:’production’}<br>#当有环境变量 name 为 DEPLOY_TO 值是 production 条件成立</li><li>when {expression {return params.DEBUG_BUILD}}<br>#表达式返回值为真时</li><li>when {not {branch ‘master’}}</li><li>when {allOf {branch ‘master’; environment name:’DEBUG_TO’,value:’production’}}<br>#allOf 所有条件都满足时</li><li>when {anyOf {branch ‘master’ ; branch ‘staging’}}<br>#anyOf有一个条件满足时即可</li></ul><p>判断和异常处理<br>流程控制if/else条件</p><p>node {<br>    stage(‘Example’){<br>        if(env.BRANCH_NAME == ‘master’){<br>            echo ‘I only execute on the master branch’<br>        }else {<br>            echo ‘Iexecute elsewhere’<br>        }<br>    }<br>}</p><p>异常处理try/catch/finally</p><p>node{<br>    stage(‘Example’){<br>        try{<br>            sh ‘exit 1’<br>        }<br>        catch (exc) {<br>            echo ‘something failed,I should sound the klaxons!’<br>            throw<br>        }<br>    }<br>}</p><p>for循环仅存在域脚本式pipeline中，但是可以通过在声明式pipeline中调用script step来执行</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps{<br>                echo ‘Hello world!’<br>                script {<br>                    def browsers = [‘chrome’,’firefox’]<br>                    for (int i = 0;i &lt; browers.size();++i){<br>                        echo “Testing the ${browsers[i]} browser”<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</p><p>并发需要放在stages中，stages可以嵌套使用<br>stage下的steps和parallel不能共存，只能二选一<br>使用了并发的stage不能再有agent/tools </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jenkins Pipeline的总体介绍&lt;br&gt;1.Jenkins Pipeline 的核心概念&lt;/p&gt;
&lt;p&gt;Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins+ant 构建非maven项目</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%BD%BF%E7%94%A8jenkins-ant-%E6%9E%84%E5%BB%BA%E9%9D%9Emaven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.ozairs.com/Jenkins/使用jenkins-ant-构建非maven项目/</id>
    <published>2019-03-18T05:06:47.000Z</published>
    <updated>2019-03-18T05:14:51.282Z</updated>
    
    <content type="html"><![CDATA[<p>使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下</p><h2 id="1-安装构建环境"><a href="#1-安装构建环境" class="headerlink" title="1. 安装构建环境"></a>1. 安装构建环境</h2><p>除普通必要的环境外，需要额外安装ANT</p><p>到官方主页<a href="http://ant.apache.org下载新版的ant，" target="_blank" rel="noopener">http://ant.apache.org下载新版的ant，</a></p><p>得到的是一个apache-ant-1.10.1-bin.zip的压缩包。将其解压到你的硬盘上</p><p>接下来配置环境变量即可，配置和java类似</p><p>ANT_HOME   :  D:\MyWorkApps\apache-ant-1.10.1</p><p>CLASSPATH  :  D:\MyWorkApps\apache-ant-1.10.1\lib</p><p>PATH:                D:\MyWorkApps\apache-ant-1.10.1\bin</p><p>注意：配置没有使用%ANT_HOME%bin</p><p> 原因:经测试部分系统path不识别%ANT_HOME%</p><p> 解决方法：换成解压目录路径，如上即可</p><p>测试一下是否安装成功</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/1.png" alt=""></p><p>build failed 即成功，只是没有build.xml而已</p><h2 id="2-jenkins安装ant插件并进行环境配置"><a href="#2-jenkins安装ant插件并进行环境配置" class="headerlink" title="2. jenkins安装ant插件并进行环境配置"></a>2. jenkins安装ant插件并进行环境配置</h2><p>进入系统设置，插件管理，安装ant插件</p><p>我这里已经安装好了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/2.png" alt=""></p><p>然后进入 系统管理 =》 <a href="http://localhost:8091/configureTools" target="_blank" rel="noopener"><strong>Global Tool Configuration</strong></a></p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/3.png" alt=""></p><p>配置<a href="https://www.baidu.com/s?wd=JDK&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">JDK</a>也是必须的，若果使用ANT构建就需配置ANT,使用MAVEN构建即要配置MAVEN</p><p>配置也很简单 如下</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/4.png" alt=""></p><p>Name 可以随意取 ,HOME即为安装目录</p><h2 id="3-进入jenkins构建项目"><a href="#3-进入jenkins构建项目" class="headerlink" title="3. 进入jenkins构建项目"></a>3. 进入jenkins构建项目</h2><p>点击新建</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/5.png" alt=""></p><p>如上填写选择，点击ok</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/6.png" alt=""></p><p>继续，到源码管理，选择svn,输入地址和账号密码</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/7.png" alt=""></p><p>继续</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.png" alt=""></p><p>可以看到这里实用最简单的配置，构建触发器，和构建环境都没有选，</p><p>构建里选择一下我们刚刚安装配置的ANT</p><p>点击保存即可</p><p>\4. build.xml文件配置</p><p>使用ANT进行构建，最主要的就是build.xml文件的编写</p><p>这里只需要修改property的几个属性即可</p><property name="catalina.home" value="D:\MyProject\tomcat-6.0.45"><p>由于我们在构建中指定了ANT，所以下面的这个可以去除掉</p><property name="ant.dir" value="D:\MyWorkApps\apache-ant-1.10.1"><p>project name 这个name即是打包之后的包名，也是我们进入工程的工程名称</p><p>如：<a href="http://localhost:8099/myweb/hello/world.do" target="_blank" rel="noopener">http://localhost:8099/myweb/hello/world.do</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"hellojk"</span> <span class="attr">default</span>=<span class="string">"deploy"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name"</span> <span class="attr">value</span>=<span class="string">"hellojk"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"catalina.home"</span> <span class="attr">value</span>=<span class="string">"D:\Program Files\Apache Software Foundation\Tomcat 8.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/dist"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webRoot.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/WebRoot"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/src"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/config"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lib.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/lib"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用eclipse jdt进行编译，而不使用JDK编译  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter" /&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="D:\MyWorkApps\Java\jdk1.8.0_51" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 初始化classpath --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加tomcat类路径 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/lib"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ant lib包  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;fileset dir="$&#123;ant.dir&#125;"&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;include name="**/*.jar" /&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/fileset&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- get the source compile classpath in a printable form --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pathconvert</span> <span class="attr">pathsep</span>=<span class="string">"$&#123;line.separator&#125;|   |-- "</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">property</span>=<span class="string">"echo.path.compile"</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">refid</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pathconvert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- show classpath jars --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"print_classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|-- compile classpath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |-- $&#123;echo.path.compile&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 删除之前的目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"清理旧文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;.war"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span> <span class="attr">depends</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"创建初始化目录结构"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编译java --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span> <span class="attr">description</span>=<span class="string">"编译java文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src.dir&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">includeantruntime</span>=<span class="string">"false"</span> <span class="attr">nowarn</span>=<span class="string">"on"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">source</span>=<span class="string">"1.8"</span> <span class="attr">target</span>=<span class="string">"1.8"</span> <span class="attr">deprecation</span>=<span class="string">"true"</span> <span class="attr">debug</span>=<span class="string">"true"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">encoding</span>=<span class="string">"UTF-8"</span> <span class="attr">classpathref</span>=<span class="string">"project.classpath"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-Xlint:unchecked"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;classpath refid="project.classpath" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;build.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;src.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;config.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将class文件打成 jar包 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;target name="pack" depends="compile"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;jar jarfile="$&#123;build.dir&#125;/$&#123;webapp.name&#125;.jar"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;fileset dir="$&#123;build.dir&#125;/classes"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &lt;include name="**/*.class"/&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;/fileset&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;/jar&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;/target&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打成war包, 名称默认为 项目名 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"war"</span> <span class="attr">depends</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"将工程打成war包"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">webxml</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/web.xml"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"***.*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">war</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- copy war包 tomcat的deploy目录 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"deploy"</span> <span class="attr">depends</span>=<span class="string">"war"</span> <span class="attr">description</span>=<span class="string">"部署项目"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">todir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如构建出现这样的错误（之前使用别的build.xml构建时错误）</p><p>大多是工程里缺少文件夹，手动创建即可</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.1.png" alt=""></p><p>走了很多弯路，不过最后成功了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/9.png" alt=""></p></blockquote></property></property>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下&lt;/p&gt;
&lt;h2 id=&quot;1-安装构建环境&quot;&gt;&lt;a href=&quot;#1-安装构建环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装构建环境&quot;&gt;&lt;/a&gt;1. 安装构建环境
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
</feed>
