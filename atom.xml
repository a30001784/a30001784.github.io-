<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>带你走进美丽的墨尔本</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ozairs.com/"/>
  <updated>2019-03-19T12:46:31.434Z</updated>
  <id>http://blog.ozairs.com/</id>
  
  <author>
    <name>Mark Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CloudFormation经验贴汇总</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation%E7%BB%8F%E9%AA%8C%E8%B4%B4%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation经验贴汇总/</id>
    <published>2019-03-19T12:30:11.000Z</published>
    <updated>2019-03-19T12:46:31.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-CloudFormation两年：经验教训"><a href="#1-CloudFormation两年：经验教训" class="headerlink" title="1. CloudFormation两年：经验教训"></a>1. CloudFormation两年：经验教训</h2><p><a href="https://www.colabug.com/4023693.html" target="_blank" rel="noopener">https://www.colabug.com/4023693.html</a></p><h1 id="2-您的基础架构代码CloudFormation与Terraform？"><a href="#2-您的基础架构代码CloudFormation与Terraform？" class="headerlink" title="2.您的基础架构代码CloudFormation与Terraform？"></a>2.您的基础架构代码CloudFormation与Terraform？</h1><p><a href="https://www.colabug.com/3313548.html" target="_blank" rel="noopener">https://www.colabug.com/3313548.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-CloudFormation两年：经验教训&quot;&gt;&lt;a href=&quot;#1-CloudFormation两年：经验教训&quot; class=&quot;headerlink&quot; title=&quot;1. CloudFormation两年：经验教训&quot;&gt;&lt;/a&gt;1. CloudFormatio
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>使用Cloud Formation为AWS上的私有实例设置绝对可靠的Bastion节点</title>
    <link href="http://blog.ozairs.com/AWS/%E4%BD%BF%E7%94%A8Cloud-Formation%E4%B8%BAAWS%E4%B8%8A%E7%9A%84%E7%A7%81%E6%9C%89%E5%AE%9E%E4%BE%8B%E8%AE%BE%E7%BD%AE%E7%BB%9D%E5%AF%B9%E5%8F%AF%E9%9D%A0%E7%9A%84Bastion%E8%8A%82%E7%82%B9/"/>
    <id>http://blog.ozairs.com/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/</id>
    <published>2019-03-19T10:43:25.000Z</published>
    <updated>2019-03-19T10:47:22.853Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg" alt=""></p><p>在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是在实例的安全组的入站规则中简单地允许端口22上的SSH流量，然后通过弹性IP和Internet网关将实例暴露给公共Internet。然而，由于攻击者可能很容易访问您的安全密钥对，并且如果这样的密钥对也可用于其他私有实例，则这会变得有缺陷，那么此类攻击者可以完全访问和控制您的基础结构。</p><p>为了避免这种情况，公司现在使用遍布所有可用区域（AZ）的堡垒实例，其中已经设置了基础架构。Bastion节点是一个专门的实例，故意暴露在互联网上，其设计和配置仅限于遭受攻击的唯一原因。看到堡垒节点暴露在非军事区（DMZ）的公共互联网中，面临潜在攻击的大量风险，因此有必要确保堡垒节点完全万无一失。本文提供了如何设置可靠的堡垒节点的实用见解。使用CloudFormation是因为它通过简单地调整云形成模板中的一些参数，简化了为每个AZ设置堡垒实例的整个瓶颈。</p><p><strong>先修知识：</strong></p><ol><li>基本了解以下Amazon Web服务/概念：EC2，VPC，子网，NAT，安全组和访问控制列表（ACL）</li><li>对云形成的基本认识。</li></ol><p>我们将在10.6.0.0/16 VPC中考虑在10.6.0.0/24子网上具有私有实例的假设网络。此外，我们的堡垒实例应存在于10.5.0.0/24子网中的10.5.0.0/16 VPC中，如下图所示：</p><p><img src="/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/2.png" alt="img"></p><p>从上图可以看出，NAT网关也已添加到架构中。这为我们的私有实例提供了额外的安全层，只要他们需要访问公共互联网进行软件更新。NAT网关允许来自私有实例的所有出站流量，但阻止从Internet到私有实例的所有始发流量。使用NAT网关，因为我们只想允许来自堡垒节点的SSH流量并阻止来自互联网的所有其他流量。出于简化/清晰的目的，有意地从上面的图中省略了每个实例的安全组信息，但是应该在云形成模板中进行研究。该图还包含10.6.0的访问控制列表（ACL）信息。<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html" target="_blank" rel="noopener">有状态的</a>。我们将在以下部分中探索Bastion节点，私有实例和NAT网关的配置细节：</p><p><strong>堡垒节点</strong></p><p>它存在于自己的VPC中，该VPC暴露于Internet网关并使用VPC对等连接与VPC2（我们的私有实例的VPC）进行通信。互联网网关已与VPC相关联，并且已将弹性IP（EIP）分配给堡垒节点以允许来自互联网的流量。</p><p>路由表清楚地表明，除了10.5.0.0/16和10.6.0.0/16网络之外，所有来自堡垒节点的出站流量都应通过互联网网关转发。发往10.6.0.0/16的流量应使用VPC对等连接作为网关，这样，SSH流量就可以到达我们的私有实例。</p><p>对于安全组，我们只允许来自/到公共互联网的所有SSH流量并阻止所有其他流量。以下是使用云形成实现这一目标的方法：</p><p><strong>私有集群中的实例</strong></p><p>我们决定将我们的假设私有集群放在10.6.0.0/24子网上。路由表描述了发往10.5.0.0/16网络的所有流量都应使用对等连接作为网关。特定于Internet的出站流量使用NAT实例作为网关。</p><p>对于安全组，我们仅允许来自10.5.0.0/24子网的SSH流量和来自Internet上的Internet（0.0.0.0/0）的HTTP / HTTPS流量，并拒绝所有其他协议。</p><p>要添加额外的安全层，我们使用ACL，仅允许SSH，HTTP和HTTPS流量，如上图所示，同时显示入口和出口。由于NAT网关请求此端口以便与私有实例通信，因此端口1024-65535已保持打开以进行<a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_ACLs.html#VPC_ACLs_Ephemeral_Ports" target="_blank" rel="noopener">短暂</a>连接。下面使用此云形成模板显示：</p><p><strong>NAT网关</strong></p><p>NAT网关也已放置在自己的10.6.1.0/24子网中。路由表描述了互联网的所有出站流量应使用Internet网关正确分段网络，因为NAT不需要访问对等连接。</p><p>NAT网关的安全组仅允许来自Internet的HTTP和HTTPs流量。以下是云形成如何实现：</p><p>现在我们有了堡垒架构的完整设置。还剩下最后一件事就是<a href="https://brainsik.net/2011/ssh-agent-forwarding/" target="_blank" rel="noopener">SSH Agent Forwarding</a></p><p><strong>SSH代理转发</strong></p><p>为什么需要这个？我们可以简单地进入堡垒，然后跳转到我们的任何私有实例中。为什么这是真的，这是一个巨大的安全风险。有权访问堡垒主机的任何人都可以访问其他所有用户的私钥，并可以模拟该用户。因此，凭证不应存储在堡垒主机上，而应通过<em>SSH代理</em>转发从本地计算机转发到堡垒<em>。</em></p><p><code>-A</code>使用SSH命令添加一段时间应该将您的本地凭据转发到下一台机器上，但是，我们将通过<strong>〜/ .ssh / config</strong>文件进行此配置以简化我们的生活并避免尝试在每次ssh尝试时转发代理。</p><p>将以下行添加到ssh配置文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host bastion</span><br><span class="line">  HostName       [Bastion Public Ip address]</span><br><span class="line">  User           ec2-user #For example</span><br><span class="line">  IdentityFile   [Path to Identity file]</span><br><span class="line">  ForwardAgent    Yes</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果该文件不存在，您可以直接触摸该文件<code>touch ~/.ssh/config</code></p><p>现在，我们可以简单地说<code>ssh bastion</code>，我们可以进入我们的堡垒实例，我们可以从中跳转到所有其他实例。</p><p>为了进一步简化，我们可以将以下行添加到文件<code>~/.bashrc</code>或<code>~/.zshrc</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ssh-instance（）&#123; </span><br><span class="line">  BASTION_USER =＃你的堡垒用户名</span><br><span class="line">  BASTION_IP =＃你的堡垒IP </span><br><span class="line">  SSH_OPTIONS =“ProxyCommand ssh -q -A -W％h：％p $ BASTION_USER @ $ BASTION_IP” </span><br><span class="line">  ssh $ 1 @ $ 2 -o $ SSH_OPTIONS </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件，通过它来源<code>source ~/.bashrc</code>，现在你可以简单地说<code>ssh-instance ec2-user [my instance ip]</code>，瞧，你直接进入你的私人实例，而不必首先通过堡垒。</p><p><strong>其他提示</strong></p><p>建议对堡垒节点和私有实例使用不同的ssh密钥，并经常轮换这些密钥以减少攻击者获取访问权限的可能性。</p><p>此外，专用的SysAdmin或DevOps工程师还可以在每个堡垒节点中设置用户组，并创建分配给具有各种管理权限的这些不同用户组的用户。应将每个用户的公共ssh密钥复制到<code>~/.ssh/authorized_keys</code>文件中。</p><p><strong>结论</strong></p><p>本文探讨了如何在AWS上为我们的私有实例设置一个万无一失的堡垒节点，而不会在需要系统/软件更新时损害这些实例的Internet可访问性。</p><p>本文的云形成模板可以在这里找到：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">https</a>：<a href="https://github.com/nwochaadim/BastionNode-with-CloudFormation" target="_blank" rel="noopener">//github.com/nwochaadim/BastionNode-with-CloudFormation</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/AWS/使用Cloud-Formation为AWS上的私有实例设置绝对可靠的Bastion节点/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在AWS上设置基础架构时，您需要为管理目的提供SSH / RDP访问私有实例的方法。实现此目的的一种简单方法是
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>玩转Jenkins Pipeline</title>
    <link href="http://blog.ozairs.com/Jenkins/%E7%8E%A9%E8%BD%ACJenkins-Pipeline/"/>
    <id>http://blog.ozairs.com/Jenkins/玩转Jenkins-Pipeline/</id>
    <published>2019-03-18T08:47:54.000Z</published>
    <updated>2019-03-18T08:51:11.320Z</updated>
    
    <content type="html"><![CDATA[<p>Jenkins Pipeline的总体介绍<br>1.Jenkins Pipeline 的核心概念</p><p>Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。</p><p>Pipeline是Jenkins2.X的最核心的特性，帮助Jenkins实现从CI到CD与DevOps的转变</p><p>Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。</p><p>持续交付管道（CD Pipeline）是将软件从版本控制阶段到交付给用户或客户的完整过程的自动化表现。软件的每一次更改（提交到源代码管理系统）都要经过一个复杂的过程才能被发布。</p><p>Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language（DSL）syntax可以达到Pipeline as Code（Jenkinsfile存储在项目的源代码库）的目的。</p><p>Stage：阶段，一个Pipeline可以划分成若干个Stage，每个Stage代表一组操作，例如：“Build”，“Test”，“Deploy”。</p><p>注意，Stage是一个逻辑分组的概念，可以跨多个Node</p><p>Node：节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent，是执行Step的具体运行环境。</p><p>Step：步骤，Step是最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类Jenklins Plugin提供，例如：sh ‘make’</p><p>Pipeline五大特性</p><p>1、代码:Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑、审查和迭代其CD流程。<br>2、可持续性：Jenklins重启或者中断后都不会影响Pipeline Job。<br>3、停顿：Pipeline可以选择停止并等待任工输入或批准，然后再继续Pipeline运行。<br>4、多功能：Pipeline支持现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力<br>5、可扩展：Pipeline插件支持其DSL的自定义扩展以及与其他插件集成的多个选项。</p><p>Pipeline和Freestyle的区别</p><p>Freestyle：<br>上游/下游Job调度，如<br>BuildJob —&gt; TestJob —&gt; DeployJob<br>在DSL Job里面调度多个子Job（利用Build Flow Plugin）</p><p>Pipeline：<br>单个Job中完成所有的任务编排<br>全局视图</p><p>Multibranch Pipeline根据你的代码中Jenlinsfile自动创建Job</p><p>Jenlins Pipeline的基础语法<br>Pipeline脚本是由Groovy语言实现（无需专门学习）</p><p>支持两种语法<br>Declarative 声明式（在Pipeline plugin 2.5中引入）<br>Scripted Pipeline 脚本式</p><p>如何创建最基本的PIpeline<br>直接在Jenkins Web UI 网页界面中输入脚本<br>通过创建一个jenkinsfile可以检入项目的源代码管理库</p><p>通常推荐在Jenkins中直接从源代码控制（SCM）中载入Jenklinsfile Pipeline</p><p>声明式Pipeline</p><p>声明式Pipeline的基本语法和表达式遵循与Groovy语法相同的规则，但有以下例外：</p><p>声明式pipeline必须包含在固定格式pipeline{}快内<br>每个声明语句必须独立一行，行尾无需使用分号<br>块（blocks{}）只能包含章节（Sections），指令（Directives），步骤（Steps）或赋值语句<br>属性引用语句被视为无参数方法调用。例：输入被视为 input()<br>块（blocks{}）<br>由大括号括起来的语句，如pipeline{},Section{},parameters{},script{}<br>章节（Sections）<br>通常包含一个或多个指令或步骤。如 agent 、post、stages、steps<br>指令（Directives）<br>environment、options、parameters、triggers（触发）、stage、tools、when<br>步骤（Steps）<br>Pipeline steps reference<br>执行脚本式pipeline：使用script{}</p><p>agent<br>必须存在，agent必须在pipeline块内的顶层定义，但stage内是否使用使可选的<br>参数：any/none/label/node/docker/dockerfile<br>常用选项 label/cuetomWorkspace/reuseNode</p><p>示例</p><p>agent { label ‘my-label’ }</p><p>agent {<br>    node {<br>        label ‘my-label’<br>        customWorkspace ‘/some/other/path’<br>    }<br>}</p><p>agent {<br>    docker {<br>        image ‘nginx:1.12.2’<br>        label ‘my-label’<br>        args ‘-v /tmp:/tmp’<br>    }<br>}</p><p>post 不是必须的，用于pipeline的最外层或者stage{}中</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps {<br>            echo ‘Hello world’<br>            }<br>        }<br>    }<br>    post {<br>        always {<br>            echo ‘say goodbay’<br>        }<br>    }<br>}</p><p>stages 必须，包括顺序执行的一个或多个stage命令，在pipeline内仅能使用一次，通常位于agent/options后面，例子如上</p><p>steps 必须，steps位于stage指令块内部，包括一个或多个step。仅有一个step的情况下可以忽略关键字step及其{},例子如上</p><p>environment 不是必须的，environment定义了一组全局的环境变量键值对，存在于pipeline{}或者stage指令内。执行特殊方法credentials()可以获取jenkins中预定义的凭证明文内容</p><p>environment {CC=’clang’}<br>environment {AN_ACCESS_KEY = credentials(‘my-prefined-secret-text’)}<br>steps {sh ‘printenv’}</p><p>options 不是必须的 预定义pipeline专有的配置信息，仅可定义一次</p><p>pipeline {<br>    agent any<br>    options{<br>    timeout(time:1,unit: ‘HOURS’)<br>    }<br>    …<br>}</p><p>parameters 不是必须的 定义参数化构建的参数可选参数 booleanParam,choice,file,text,password,run,string</p><p>paramenters {<br>    choice(name:’PerformMavenRelease’,choices:’False\nTrue’,description:’desc’)<br>    password(name:’CredsToUse’,description:’Apassword to build with’,defaultValue:’’)<br>}<br>environment {<br>    BUILD_USR_CHOICE=”${params.PerformMavenRelease}”<br>    BUILD_USR_CREDS=”${params.CredsToUse}”<br>}</p><p>triggers 不是必须的 定义pipeline被自动触发的方式选项 cron、pollSCM、upstream</p><p>triggers {cron(‘H 4/<em> 0 0 1-5’)}<br>triggers {pollSCM(‘H 4/</em> 0 0 1-5’)}<br>triggers {upstream(upstreamProjects:’job1,job2’,threshold:hudson.model.Result.SUCCESS)}</p><p>快速创建一个pipeline<br>新建 选择pipeline 填写Job 的名字 </p><p>填写相应的pipeline script</p><p>pipeline{<br>    agent any<br>    stages {<br>        stage(‘Build’) {<br>            steps{<br>                echo ‘This is a build step’<br>            }<br>        }<br>        stage(‘Test’) {<br>            steps{<br>                echo ‘This is a test step’<br>            }<br>        }<br>        stage(‘Deploy’) {<br>            steps{<br>                echo ‘This is a deploy step’<br>            }<br>        }<br>    }<br>}<br>1</p><p>保存之后，立即构建</p><p>常用的辅助工具</p><p>Snipper Generator（代码片段生成器，语法检查器）<br>Replay Pipeline（重放pipeline，可以修改script，修改后的不存入config.xml）<br>DSL Reference 语法参考手册<br>全局变量引用<br>Stage View<br>BlueOcean(可视化)<br>Pipeline神器：可视化编辑器<br>命令行Pipeline调试工具<br>变量的传递</p><p>自定义变量（局部）<br>def username = ‘Jenkins’<br>echo “Hello Mr.${username}”</p><p>#注意一定要用双引号，单引号识别为字符串</p><p>环境变量（局部）<br>withEnv([‘MYTOOL_HOME=/usr/local/mytool’]){<br>    sh ‘$MYTOOL_HOME/bin/start’<br>}<br>1<br>2<br>3<br>环境变量（全局）<br>environment {CC=’clang’}<br>echo “Compiler is ${env.CC}”</p><p>参数化构建（全局）<br>parameters {string(name:’Jenkins’,defaultValue:’Hello’,description:’How should I greet the world’)}<br>ehco “${params.Greeting} World!”</p><p>判断<br>when仅用于stage内部<br>when的内置条件为：</p><ul><li>when {branch ‘master’}</li><li>when {environment name:’DEPLOY_TO’,value:’production’}<br>#当有环境变量 name 为 DEPLOY_TO 值是 production 条件成立</li><li>when {expression {return params.DEBUG_BUILD}}<br>#表达式返回值为真时</li><li>when {not {branch ‘master’}}</li><li>when {allOf {branch ‘master’; environment name:’DEBUG_TO’,value:’production’}}<br>#allOf 所有条件都满足时</li><li>when {anyOf {branch ‘master’ ; branch ‘staging’}}<br>#anyOf有一个条件满足时即可</li></ul><p>判断和异常处理<br>流程控制if/else条件</p><p>node {<br>    stage(‘Example’){<br>        if(env.BRANCH_NAME == ‘master’){<br>            echo ‘I only execute on the master branch’<br>        }else {<br>            echo ‘Iexecute elsewhere’<br>        }<br>    }<br>}</p><p>异常处理try/catch/finally</p><p>node{<br>    stage(‘Example’){<br>        try{<br>            sh ‘exit 1’<br>        }<br>        catch (exc) {<br>            echo ‘something failed,I should sound the klaxons!’<br>            throw<br>        }<br>    }<br>}</p><p>for循环仅存在域脚本式pipeline中，但是可以通过在声明式pipeline中调用script step来执行</p><p>pipeline {<br>    agent any<br>    stages {<br>        stage(‘Example’){<br>            steps{<br>                echo ‘Hello world!’<br>                script {<br>                    def browsers = [‘chrome’,’firefox’]<br>                    for (int i = 0;i &lt; browers.size();++i){<br>                        echo “Testing the ${browsers[i]} browser”<br>                    }<br>                }<br>            }<br>        }<br>    }<br>}</p><p>并发需要放在stages中，stages可以嵌套使用<br>stage下的steps和parallel不能共存，只能二选一<br>使用了并发的stage不能再有agent/tools </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Jenkins Pipeline的总体介绍&lt;br&gt;1.Jenkins Pipeline 的核心概念&lt;/p&gt;
&lt;p&gt;Pipeline，简而言之，就是一套运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Pipeline" scheme="http://blog.ozairs.com/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>使用jenkins+ant 构建非maven项目</title>
    <link href="http://blog.ozairs.com/Jenkins/%E4%BD%BF%E7%94%A8jenkins-ant-%E6%9E%84%E5%BB%BA%E9%9D%9Emaven%E9%A1%B9%E7%9B%AE/"/>
    <id>http://blog.ozairs.com/Jenkins/使用jenkins-ant-构建非maven项目/</id>
    <published>2019-03-18T05:06:47.000Z</published>
    <updated>2019-03-18T05:14:51.282Z</updated>
    
    <content type="html"><![CDATA[<p>使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下</p><h2 id="1-安装构建环境"><a href="#1-安装构建环境" class="headerlink" title="1. 安装构建环境"></a>1. 安装构建环境</h2><p>除普通必要的环境外，需要额外安装ANT</p><p>到官方主页<a href="http://ant.apache.org下载新版的ant，" target="_blank" rel="noopener">http://ant.apache.org下载新版的ant，</a></p><p>得到的是一个apache-ant-1.10.1-bin.zip的压缩包。将其解压到你的硬盘上</p><p>接下来配置环境变量即可，配置和java类似</p><p>ANT_HOME   :  D:\MyWorkApps\apache-ant-1.10.1</p><p>CLASSPATH  :  D:\MyWorkApps\apache-ant-1.10.1\lib</p><p>PATH:                D:\MyWorkApps\apache-ant-1.10.1\bin</p><p>注意：配置没有使用%ANT_HOME%bin</p><p> 原因:经测试部分系统path不识别%ANT_HOME%</p><p> 解决方法：换成解压目录路径，如上即可</p><p>测试一下是否安装成功</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/1.png" alt=""></p><p>build failed 即成功，只是没有build.xml而已</p><h2 id="2-jenkins安装ant插件并进行环境配置"><a href="#2-jenkins安装ant插件并进行环境配置" class="headerlink" title="2. jenkins安装ant插件并进行环境配置"></a>2. jenkins安装ant插件并进行环境配置</h2><p>进入系统设置，插件管理，安装ant插件</p><p>我这里已经安装好了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/2.png" alt=""></p><p>然后进入 系统管理 =》 <a href="http://localhost:8091/configureTools" target="_blank" rel="noopener"><strong>Global Tool Configuration</strong></a></p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/3.png" alt=""></p><p>配置<a href="https://www.baidu.com/s?wd=JDK&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">JDK</a>也是必须的，若果使用ANT构建就需配置ANT,使用MAVEN构建即要配置MAVEN</p><p>配置也很简单 如下</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/4.png" alt=""></p><p>Name 可以随意取 ,HOME即为安装目录</p><h2 id="3-进入jenkins构建项目"><a href="#3-进入jenkins构建项目" class="headerlink" title="3. 进入jenkins构建项目"></a>3. 进入jenkins构建项目</h2><p>点击新建</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/5.png" alt=""></p><p>如上填写选择，点击ok</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/6.png" alt=""></p><p>继续，到源码管理，选择svn,输入地址和账号密码</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/7.png" alt=""></p><p>继续</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.png" alt=""></p><p>可以看到这里实用最简单的配置，构建触发器，和构建环境都没有选，</p><p>构建里选择一下我们刚刚安装配置的ANT</p><p>点击保存即可</p><p>\4. build.xml文件配置</p><p>使用ANT进行构建，最主要的就是build.xml文件的编写</p><p>这里只需要修改property的几个属性即可</p><property name="catalina.home" value="D:\MyProject\tomcat-6.0.45"><p>由于我们在构建中指定了ANT，所以下面的这个可以去除掉</p><property name="ant.dir" value="D:\MyWorkApps\apache-ant-1.10.1"><p>project name 这个name即是打包之后的包名，也是我们进入工程的工程名称</p><p>如：<a href="http://localhost:8099/myweb/hello/world.do" target="_blank" rel="noopener">http://localhost:8099/myweb/hello/world.do</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">"hellojk"</span> <span class="attr">default</span>=<span class="string">"deploy"</span> <span class="attr">basedir</span>=<span class="string">"."</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">environment</span>=<span class="string">"env"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webapp.name"</span> <span class="attr">value</span>=<span class="string">"hellojk"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"catalina.home"</span> <span class="attr">value</span>=<span class="string">"D:\Program Files\Apache Software Foundation\Tomcat 8.5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dist.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/dist"</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webRoot.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/WebRoot"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"src.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/src"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"config.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/config"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"lib.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/lib"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"build.dir"</span> <span class="attr">value</span>=<span class="string">"$&#123;basedir&#125;/build"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用eclipse jdt进行编译，而不使用JDK编译  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter" /&gt;  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;property name="build.compiler" value="D:\MyWorkApps\Java\jdk1.8.0_51" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 初始化classpath --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">id</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加tomcat类路径 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/lib"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"*.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ant lib包  --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--&lt;fileset dir="$&#123;ant.dir&#125;"&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;include name="**/*.jar" /&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;/fileset&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- get the source compile classpath in a printable form --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pathconvert</span> <span class="attr">pathsep</span>=<span class="string">"$&#123;line.separator&#125;|   |-- "</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">property</span>=<span class="string">"echo.path.compile"</span>  </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">             <span class="attr">refid</span>=<span class="string">"project.classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">pathconvert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- show classpath jars --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"print_classpath"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|-- compile classpath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"|   |-- $&#123;echo.path.compile&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 删除之前的目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"清理旧文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">file</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;.war"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">dir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps/$&#123;webapp.name&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建目录结构 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"init"</span> <span class="attr">depends</span>=<span class="string">"clear"</span> <span class="attr">description</span>=<span class="string">"创建初始化目录结构"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mkdir</span> <span class="attr">dir</span>=<span class="string">"$&#123;dist.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 编译java --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"compile"</span> <span class="attr">depends</span>=<span class="string">"init"</span> <span class="attr">description</span>=<span class="string">"编译java文件"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">javac</span> <span class="attr">srcdir</span>=<span class="string">"$&#123;src.dir&#125;"</span> <span class="attr">destdir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">includeantruntime</span>=<span class="string">"false"</span> <span class="attr">nowarn</span>=<span class="string">"on"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">source</span>=<span class="string">"1.8"</span> <span class="attr">target</span>=<span class="string">"1.8"</span> <span class="attr">deprecation</span>=<span class="string">"true"</span> <span class="attr">debug</span>=<span class="string">"true"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">encoding</span>=<span class="string">"UTF-8"</span> <span class="attr">classpathref</span>=<span class="string">"project.classpath"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            &gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">compilerarg</span> <span class="attr">line</span>=<span class="string">"-Xlint:unchecked"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;classpath refid="project.classpath" /&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">javac</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">"$&#123;build.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;src.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;config.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"**/*.sql"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end compile..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将class文件打成 jar包 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;target name="pack" depends="compile"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;jar jarfile="$&#123;build.dir&#125;/$&#123;webapp.name&#125;.jar"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;fileset dir="$&#123;build.dir&#125;/classes"&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &lt;include name="**/*.class"/&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                &lt;/fileset&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            &lt;/jar&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;/target&gt;   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 打成war包, 名称默认为 项目名 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"war"</span> <span class="attr">depends</span>=<span class="string">"compile"</span> <span class="attr">description</span>=<span class="string">"将工程打成war包"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">war</span> <span class="attr">destfile</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">basedir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>   </span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">            <span class="attr">webxml</span>=<span class="string">"$&#123;webRoot.dir&#125;/WEB-INF/web.xml"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;lib.dir&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">classes</span> <span class="attr">dir</span>=<span class="string">"$&#123;build.dir&#125;/classes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">fileset</span> <span class="attr">dir</span>=<span class="string">"$&#123;webRoot.dir&#125;"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"***.*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">war</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end war..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- copy war包 tomcat的deploy目录 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">name</span>=<span class="string">"deploy"</span> <span class="attr">depends</span>=<span class="string">"war"</span> <span class="attr">description</span>=<span class="string">"部署项目"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"begin deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">copy</span> <span class="attr">file</span>=<span class="string">"$&#123;dist.dir&#125;/$&#123;webapp.name&#125;.war"</span> <span class="attr">todir</span>=<span class="string">"$&#123;catalina.home&#125;/webapps"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">"end deploy..."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如构建出现这样的错误（之前使用别的build.xml构建时错误）</p><p>大多是工程里缺少文件夹，手动创建即可</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/8.1.png" alt=""></p><p>走了很多弯路，不过最后成功了</p><p><img src="/Jenkins/使用jenkins-ant-构建非maven项目/9.png" alt=""></p></blockquote></property></property>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用ant构建是因为在许多公司仍有许多项目没有使用maven,所以自己学习并研究了了一下&lt;/p&gt;
&lt;h2 id=&quot;1-安装构建环境&quot;&gt;&lt;a href=&quot;#1-安装构建环境&quot; class=&quot;headerlink&quot; title=&quot;1. 安装构建环境&quot;&gt;&lt;/a&gt;1. 安装构建环境
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>从Docker到Jenkins再到Ansible的部署经验</title>
    <link href="http://blog.ozairs.com/Ansible/%E4%BB%8EDocker%E5%88%B0Jenkins%E5%86%8D%E5%88%B0Ansible%E7%9A%84%E9%83%A8%E7%BD%B2%E7%BB%8F%E9%AA%8C/"/>
    <id>http://blog.ozairs.com/Ansible/从Docker到Jenkins再到Ansible的部署经验/</id>
    <published>2019-03-17T10:53:04.000Z</published>
    <updated>2019-03-17T10:56:53.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从Docker-到Jenkins-到Ansible的部署经验"><a href="#从Docker-到Jenkins-到Ansible的部署经验" class="headerlink" title="从Docker 到Jenkins 到Ansible的部署经验"></a>从Docker 到Jenkins 到Ansible的部署经验</h1><p>工作中，除了开发功能，还负责系统的部署工作。我从频繁的部署工作中，逐渐找到了一些偷懒的方法。从传统的Java -jar命令启动服务，到通过Docker 容器构建部署服务，再后来通过自动化部署工具Jenkins来完成部署，最后再结合Ansible完成远程部署。一步步的进步极大的减少部署工作，提高了工作效率（增加了许多划水时间）。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的<a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>Docker给我的印象很深，没有什么环境是docker pull 解决不了的，</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">docker ps           ， docker ps 默认显示运行中的容器，-a 显示所有，-l显示近期创建的容器</span><br><span class="line"></span><br><span class="line">docker start xxx    ， 启动xxx容器</span><br><span class="line"></span><br><span class="line">docker restart xxx  ， 重启xxx容器</span><br><span class="line"></span><br><span class="line">docker run xxx      ， 创建并运行xxx容器</span><br><span class="line"></span><br><span class="line">docker build -t xxx .   ，使用 Dockerfile 创建镜像</span><br><span class="line"></span><br><span class="line">docker stop xxx     ， 关闭容器</span><br><span class="line"></span><br><span class="line">docker rm xxx       ， 删除容器</span><br><span class="line"></span><br><span class="line">docker images       ， 查看所有镜像</span><br><span class="line"></span><br><span class="line">docker rmi xxx      ， 删除xxx镜像</span><br><span class="line"></span><br><span class="line">docker exec -it xxx sh          ， 进入xxx容器中，用quit退出</span><br><span class="line"></span><br><span class="line">docker logs -f xxx --tail 500   ， 查看xxx容器的日志，显示最后500行，常用命令</span><br><span class="line"></span><br><span class="line">docker inspect xxxx             ， 查看容器配置信息</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml up -d ， 按照app.yml文件配置以debug形式启动</span><br><span class="line"></span><br><span class="line">docker-compose -f app.yml down  ， 按照app.yml文件配置形式关闭</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：在gradle项目加入docker插件，即在gradle.build 文件中加入以下代码。需要注意的有插件的版本，项目打包后的名称，Dockerfile文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath(&quot;se.transmode.gradle:gradle-docker:1.2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: &apos;docker&apos;</span><br><span class="line"></span><br><span class="line">task buildDocker(type: Docker, dependsOn: build) &#123;</span><br><span class="line">    push = false</span><br><span class="line">    applicationName = &quot;项目名&quot;</span><br><span class="line">    dockerfile = file(&apos;src/main/docker/Dockerfile文件目录&apos;)</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        copy &#123;</span><br><span class="line">            from jar</span><br><span class="line">            into stageDir</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：创建Dockerfile文件，文件目录要和第一步中设置的保持一致。需要配置jdk镜像和基本的启动参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM frolvlad/alpine-oraclejdk8:slim</span><br><span class="line">VOLUME /tmp</span><br><span class="line">ADD 项目jar名称.jar app.jar</span><br><span class="line">RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line">ENV JAVA_OPTS=&quot;&quot;</span><br><span class="line">ENV PORT=&quot;6666&quot;</span><br><span class="line">ENV DB_CONNECTION=&quot;jdbc:mysql://ip:port/database&quot;</span><br><span class="line">ENV DB_USER=&quot;user&quot;</span><br><span class="line">ENV DB_PASSWORD=&quot;password&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar --spring.datasource.url=$DB_CONNECTION --spring.datasource.usernam=$DB_USER --spring.datasource.password=$DB_PASSWORD --port=$PORT&quot;]</span><br></pre></td></tr></table></figure><p>第三步：将jar拷贝到服务器上，然后执行编译，运行的docker命令</p><p>一）、通过gradle的bootJar，将项目打包。同时需要把引入的第三方jar也要一起打入到项目jar中。</p><p>二）、Windows系统中可以通过Xftp将jar和Dockerfile文件拷贝同一个目录下。Linux系统可以通过scp命令上传文件。</p><p>三）、执行docker ps，查看当前运行的容器，执行docker stop和docker rm 关闭和删除之前旧版本的容器</p><p>四）、找到jar的目录，并在当前目录下，执行 docker build -t 镜像名称 . 的命令编译项目，注意后面的点不要漏了。</p><p>五）、编译成功后执行 docker run –name 容器名 -v /tmp:/tmp -p 对外开发的端口:项目启动的端口 镜像名:latest 。启动容器</p><p>六）、执行docker ps，查看容器启动是否正常启动。同时执行docker logs -f 容器名 –tail 500，查看容器启动日志，检查是否有异常</p><p>七）、最后浏览器访问一下，已确保部署成功。</p><p>全称大概需要几分钟的时间，虽然不算麻烦。可次数多了，就很麻烦了。有没有什么好的工具帮助我们完成这一系列操作呢？答案是肯定的。</p><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>The leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.</p></blockquote><p>Jenkins 的logo是一个管家的形象，很贴切。对它的理解比较肤浅。他通过管理Git上的项目，来确保每次打包的jar都是最新的。同时在构建成功后执行我们输入的shell命令，来达到自动化部署的工作。</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：创建一个负责编译的Jenkins项目，</p><p>在Jenkins控制台页面，点击页面左上角的“新建”按钮。再输入项目名后，可以选择创建一个空项目，也可以在页面最下面选择copy from 其他项目。不管如何创建，我们需要Jenkins管理项目的源码，构建和构建后的操作。</p><p>第二步：创建一个负责运行的Jenkins项目</p><p>以同样的方式创建项目，在构建触发器上，选择第一步创建的项目，构建的Shell命令是先删除之前的容器，然后在重新运行容器。若之前的容器不存在，则会构建失败。所以第一次构建的时候把第一行命令删掉。解决方案傻乎乎的，只是因为没有花时间去处理。</p><p>第三步：选择编译项目，点击立即构建，当第一个项目构成成功后，会自动触发运行项目。等待两个项目都成功后，就可以访问浏览器，检查功能。</p><p>有了Jenkins，一切变得轻松很多。但他也有一个较大的弊端，就是使用前必须要先安装。特别是在客户的服务器上，也许别人就只跑这一个服务，你给别人整了一个Jenkins，似乎有点大材小用了。有没有好的解决方法？答案是肯定的。</p><h2 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Ansible is an IT automation tool. It can configure systems, deploy software, and orchestrate more advanced IT tasks such as continuous deployments or zero downtime rolling updates.</p></blockquote><p>从接触到使用Ansible大概有一天的时间，对它的理解也是比较肤浅。我单纯的认为，他可以帮助我们在服务器之间传输文件，同时还可以执行一些shell命令。抱着这样的想法，我们可以通过Jenkins完成自动化编译，再通过Ansible传输资源文件到部署的环境中，同时执行启动Shell命令。</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>第一步：修改Jenkins运行项目的构建Shell，将之前的docker run改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook ansible命令文件路径/app.yaml</span><br></pre></td></tr></table></figure><p>第二步：创建Ansible脚本文件app.yaml，目录和第一步中设置的保存一致，模版大致如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- hosts: &apos;需要部署的远程服务ip&apos;</span><br><span class="line">  tasks:</span><br><span class="line">   - name: &quot;关闭旧版本的容器&quot;</span><br><span class="line">     shell: docker stop xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除旧版本的容器&quot;</span><br><span class="line">     shell: docker rm xxx</span><br><span class="line">     ignore_errors: true</span><br><span class="line">   - name: &quot;删除之前的旧文件&quot;</span><br><span class="line">     shell: rm -rf /旧文件路径/*</span><br><span class="line">   - name: &quot;传输Dockerfile文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/文件目录/Dockerfile</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;传输Jar文件&quot;</span><br><span class="line">     copy:</span><br><span class="line">       src=/jar目录/xxx.jar</span><br><span class="line">       dest=/远程服务指定目录</span><br><span class="line">   - name: &quot;构建docker 镜像&quot;</span><br><span class="line">     shell: chdir=/jar所在目录 nohup docker build -t 镜像名 .</span><br><span class="line">   - name: &quot;启动容器&quot;</span><br><span class="line">     shell: nohup docker run --name 容器名 -v /挂载路径/:/挂载路径/ -p 对外端口:服务端口 -d 镜像名:latest</span><br></pre></td></tr></table></figure><p>第三步：在Jenkins上构建编译项目。</p><h2 id="前后端项目的部署"><a href="#前后端项目的部署" class="headerlink" title="前后端项目的部署"></a>前后端项目的部署</h2><p>到这里，三种部署的流程就完成了。如果你熟悉Docker的方式构建，再用Jenkins和Ansible的时候，就会简单很多。我在实际开发中，项目是前后端分离的。公司做了两个方案，</p><p>第一种：前后端分开部署，即Jenkins上有四个项目。前端和后端各两个项目。这样的好处就是前后端互不影响。不会因为对方的错误而从新编译。缺点也是有的，很难保证对方部署的环境是最新的。</p><p>第二种：把前后端放在一个项目中，一次构建完成两个项目的打包部署。缺点是构建慢，优点就是保证两端的代码都是最新的，适合发布到预发布环境和正式环境。</p><p>那么，针对前后端一起部署的需求，Jenkins和Ansible同样也需要简单的修改。其思路就是Jenkins负责编译项目，将资源文件压缩，再通过Ansible上传到其他服务器上。执行解压，构建，启动的命令。</p><p>看起来视乎很简单，但有一个坑希望你们跨过去。前端打包需要npm或者其他工具，但是你的服务器上没有安装。此时请务必通过Jenkins控制台，或者用Jenkins帐号登录服务器安装这些工具。笔者就是通过root帐号登录服务器安装的npm，通过Jenkins编译时提示没有权限。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从Docker-到Jenkins-到Ansible的部署经验&quot;&gt;&lt;a href=&quot;#从Docker-到Jenkins-到Ansible的部署经验&quot; class=&quot;headerlink&quot; title=&quot;从Docker 到Jenkins 到Ansible的部署经验&quot;&gt;
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ansible-playbook之roles实现</title>
    <link href="http://blog.ozairs.com/Ansible/ansible-playbook%E4%B9%8Broles%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.ozairs.com/Ansible/ansible-playbook之roles实现/</id>
    <published>2019-03-17T10:19:21.000Z</published>
    <updated>2019-03-17T10:26:15.653Z</updated>
    
    <content type="html"><![CDATA[<p>一、目标<br>两台主机：192.168.50.138（安装ansible）、192.168.50.139</p><p>[webservers]<br>192.168.50.138 httpd_point=80<br>192.168.50.139 httpd_point=8080<br>实现在两台主机上同时安装apache，提供配置文件，并启动。在139主机上提供mysql服务。</p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>二、roles之apache<br>1、创建目录</li></ul><p>mkdir -pv /ansible_playbooks/roles/{apache,mysql}/{tasks,files,templates,meta,handlers,vars}<br>2、复制一份httpd配置文件作为template</p></li></ul><p>cp /etc/httpd/conf/httpd.conf /ansible_playbooks/roles/apache/templates/<br>编辑此配置文件做变量引用</p><p>Listen <br>3、编写tasks任务</p><p>[root@node1 apache]# vim tasks/main.yml </p><ul><li>name: install httpd<br>yum: name=httpd state=latest</li><li>name: install config<br>template: src=httpd.conf dest=/etc/httpd/conf/httpd.conf<br>notify:<ul><li>restart apache</li></ul></li><li>name: start apache<br>service: name=httpd state=started<br>4、编写handlers</li></ul><p>[root@node1 apache]# vim handlers/main.yml </p><ul><li>name: restart apache<br>service: name=httpd state=restarted<br>三、roles之mysql<br>1、复制一份mysql配置文件到files文件中</li></ul><p>cp /etc/my.cnf /ansible_playbooks/roles/mysql/files/<br>2、编写tasks任务<br>[root@node1 mysql]# vim /ansible_playbooks/roles/mysql/tasks/main.yml </p><ul><li>name: install mysql<br>yum: name=mariadb state=latest</li><li>name: install config-mysql<br>copy: src=my.cnf dest=/etc/my.cnf</li><li>name: start mariadb<br>service: name=mariadb state=started<br>四、编写剧本</li></ul><p>[root@node1 mysql]# vim /ansible_playbooks/site.yml </p><ul><li><p>hosts: all<br>remote_user: root<br>roles:</p><ul><li>apache</li></ul></li><li><p>hosts: 192.168.50.139<br>remote_user: root<br>roles:</p><ul><li>apache</li><li>mysql<br>五、执行剧本</li></ul></li></ul><p>[root@node1 handlers]# ansible-playbook /ansible_playbooks/site.yml </p><p>PLAY [all] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.138]<br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]<br>ok: [192.168.50.138]</p><p>PLAY [192.168.50.139] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p>TASK [Gathering Facts] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install httpd] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>**</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : install config] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [apache : start apache] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>ok: [192.168.50.139]</p><p>TASK [mysql : install config-mysql] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>TASK [mysql : start mariadb] <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>changed: [192.168.50.139]</p><p>PLAY RECAP <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br>192.168.50.138             : ok=4    changed=0    unreachable=0    failed=0<br>192.168.50.139             : ok=11   changed=2    unreachable=0    failed=0   </p><h2 id="成功！！！"><a href="#成功！！！" class="headerlink" title="成功！！！"></a>成功！！！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、目标&lt;br&gt;两台主机：192.168.50.138（安装ansible）、192.168.50.139&lt;/p&gt;
&lt;p&gt;[webservers]&lt;br&gt;192.168.50.138 httpd_point=80&lt;br&gt;192.168.50.139 httpd_point=
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible实战汇总</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%AE%9E%E6%88%98%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible实战汇总/</id>
    <published>2019-03-17T10:05:37.000Z</published>
    <updated>2019-03-17T11:02:01.798Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible 实战目录</p><p>一、Ansible与Terraform相结合</p><p>1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；</p><p><a href="https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d" target="_blank" rel="noopener">https://hackernoon.com/setup-docker-swarm-on-aws-using-ansible-terraform-daa1eabbc27d</a></p><p>二、Ansible操作Docker容器</p><p>1、使用 Ansible 高效交付 Docker 容器</p><p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/cloud/library/cl-provision-docker-containers-ansible/index.html</a></p><p>2、基于 docker 的 jenkins-ansible-gitlab 实现自动化部署</p><p><a href="https://www.jianshu.com/p/191f0c81c6bb" target="_blank" rel="noopener">https://www.jianshu.com/p/191f0c81c6bb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible 实战目录&lt;/p&gt;
&lt;p&gt;一、Ansible与Terraform相结合&lt;/p&gt;
&lt;p&gt;1、使用Ansible和Terraform在AWS上构建Docker Swarm集群；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hackernoon.com/setu
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们抛弃ECS而选择了Kubernetes</title>
    <link href="http://blog.ozairs.com/Kubernetes/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E6%8A%9B%E5%BC%83ECS%E8%80%8C%E9%80%89%E6%8B%A9%E4%BA%86Kubernetes/"/>
    <id>http://blog.ozairs.com/Kubernetes/为什么我们抛弃ECS而选择了Kubernetes/</id>
    <published>2019-03-17T05:18:22.000Z</published>
    <updated>2019-03-17T05:20:40.489Z</updated>
    
    <content type="html"><![CDATA[<p>在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。</p><p>3个月前，我们在</p><p>nanit.com</p><p>希望选择一个合适的Docker编排框架，ECS成为了我们的首选，毕竟，我们对AWS的服务较为熟悉，并且我们的基础设施都是建立在AWS的。经过一段时间的测试，我们发现ECS并不成熟，缺少一些我们需要的关键功能，因此我们开始尝试其他的框架：Kubernetes。令人意外的是，Kubernetes非常成熟，几乎支持我们需要的所有功能。对于我们来说，Kubernetes在ECS的主场完胜了ECS。接下来，就让我们一起来看看Kubernetes赢在哪些方面。</p><p>注意：ECS一直在更新，我们会尽可能的跟进这些内容，但部分内容可能被忽略了，希望读者不要介意。</p><h3 id="构建集群（Cluster-Setup）"><a href="#构建集群（Cluster-Setup）" class="headerlink" title="构建集群（Cluster Setup）"></a>构建集群（Cluster Setup）</h3><p>ECS:为了启动一个ECS集群，用户需要设置一个Auto Scaling Group。用户可以编辑user-data来将EC2实例添加到指定的ECS集群上。当ASG被设置，实例启动之后，用户可以在ECS控制台看到这部分内容。现在，用户可以开始进行task-definition，方式类似于Docker-compose。</p><p>Kubernetes：想要在AWS上启动一个Kubernetes，用户需要先启动一个具有一定权限的EC2实例（通过IAM）。这将会创建多个AWS constructs来支持你的集群：VPC、ASG、一些安全组（Security Groups）和一个Kubernetes主实例。集群需要几分钟来启动，之后用户就能够在上面运行自己的容器。</p><p>比较结果：使用这两种框架来启动一个集群都非常的简单和友好。</p><h3 id="启动基础服务（Basic-Service-Setup）"><a href="#启动基础服务（Basic-Service-Setup）" class="headerlink" title="启动基础服务（Basic Service Setup）"></a>启动基础服务（Basic Service Setup）</h3><p>我们的任务是启动一个Nginx 镜像，并且让其他人能够访问这个Web服务。</p><p>ECS: 首先，我们需要创建一个ELB(Elastic Load Balancer)，它负责80端口的转发。然后，我们需要创建一个task-definition，它负责在80端口上启动一个Docker镜像。最后，需要创建一个Service，它会显示出有多少实例会同时运行。我们需要将它绑定到我们之前创建的ELB上。</p><p>Kubernetes：首先需要创建一个Replication Controller，它会显示出我们希望运行的Docker镜像和有多少镜像会同时运行。之后，我们需要创建一个Service object，这会启动一个ELB并且将ELB的流量转发到对应的容器上。</p><p>比较结果：Kubernetes的方式更舒服一些，更简洁。用户并不需要手工启动或者管理ELB。Kubernetes会完全负责管理：当用户创建了一个service，一个ELB会自动创建；当用户删除了一个service，它会自动从AWS上删除。</p><h3 id="服务发现（Service-Discovery）"><a href="#服务发现（Service-Discovery）" class="headerlink" title="服务发现（Service Discovery）"></a>服务发现（Service Discovery）</h3><p>当你使用了微服务架构和Docker，一个好的服务发现解决方案是至关重要的。Docker容器总是在不同虚拟机中迁移，用户必须有一个可靠的方法来发现在集群内和集群外的服务。</p><p>ECS: ECS并没有提供任何服务发现的解决方案。我能想到的最好方法就是构建一个内部加载平衡器（internal load balancer），并且将每一个service附加到一个平衡器上。平衡器的host name不会被改变，然后你就能够利用这个host name来作为服务的端点。其他的方法还有集成一个外部的程序，比如</p><p>Consul</p><p>。</p><p>Kubernetes：我认为这是Kubernetes的亮点之一。Kubernetes内置了一个完全的解决方案。它是一个插件，因此用户可以选择是否使用，但我强烈建议使用。它能够和namespace一起很好的工作。简单来说，当你创建了一个Kubernetes服务，比如说叫做redis，你就能够在集群的任何地方引用redis这个名字，即便是跨虚拟机。这就像是让docker网络跨越了特定的虚拟机，连通了整个集群。Namespaces允许你将多个服务归纳到一个具有逻辑的组中。现在假设我们有两个命名空间，分别是production和staging，他们都包含有一个redis的服务。一个在production命名空间下的容器可以通过redis来引用在production命名空间下的redis服务，同样的，在stagin命名空间下的容器也能通过redis来引用到位于stagine命名空间下的redis服务。这种自动化识别使得用户不需要花费时间去配置信息就能够构建一个隔离的环境，并且你可以随意在所有的命名空间中使用redis来引用对应的服务，接下来kunernetes会为你自动解析它们。</p><p>比较结果：毫无疑问，Kubernetes小胜一局。使用Kubernetes，用户完全不用关心服务发现的事情，全部交给Kubernetes来做就好了：）</p><h3 id="部署（Deployments）"><a href="#部署（Deployments）" class="headerlink" title="部署（Deployments）"></a>部署（Deployments）</h3><p>当我们升级一个服务的时候，即便还在部署，我们也想要确保它百分之百能用。我们的测试包括一个简单的NginX服务和一些简单的静态网页。我们启动了一个并发为30个请求的负载测试，并且在负载测试期间，我们会对该服务进行升级。</p><p>在部署期间，我们发现ECS丢失了比Kubernetes更多的请求。其中，Kubernetes丢失了0-2个请求，而ECS丢失了9-14个。</p><p>比较结果：说实话，我对ECS非常的失望。同样，我也对Kubernetes表示失望，但是它至少比ECS好多了。值得注意的是，Kubernetes 1.1.1版本应该会对轮询升级机制（rollong update mechanism）进行改善，还有一些其他的系统系能提升，这些改进都会使得这些数字变得更好看。</p><h3 id="持久卷（Persistent-Volumes）"><a href="#持久卷（Persistent-Volumes）" class="headerlink" title="持久卷（Persistent Volumes）"></a>持久卷（Persistent Volumes）</h3><p>我们经常需要挂载一些持久性的文件系统到一个指定的容器上，MySQL就是一个典型的例子。</p><p>ECS：ECS支持Docker原生的解决方案——用户可以启动一个数据容器，然后使用volumes-from命令来挂载它到其他容器上。就拿MySQL来看，你首先需要设置一个mysql-data容器，这个容器仅仅拥有一个数据卷。然后设置另外一个mysql-db容器，这个容器使用volumes-from命令来挂载之前创建的数据卷容器。这个方法看起来不错，但是它是host-sepicific的，这意味着你的mysql-db容器不能够在主机之间移动。你必须指定mysql-db容器在哪一个主机上运行，以此来防止容器被重新分配到其他主机上，最终失去了持久性。</p><p>Kubernetes：除了从一个指定的主机上挂载数据卷，Kubernetes还提供了一个选项：挂载一个EBS（Elastic Book Store）数据卷。这意味着一个容器的持久性存储可以在多个不同的虚拟机之间保留。你再也不需要强制你的MySQL容器必须运行在哪一个具体的虚拟机上。</p><p>注意：EBS同一时间只能被一个虚拟机挂载，这意味着如果有一个服务，它有两个运行在不同虚拟机的容器，他们将不能够挂载和共享这个EBS。</p><p>比较结果：即便Kubernetes的EBS挂载有一定的限制，但它依旧非常的独特和有用。</p><h3 id="健康检查（Health-Checks）"><a href="#健康检查（Health-Checks）" class="headerlink" title="健康检查（Health-Checks）"></a>健康检查（Health-Checks）</h3><p>确保拥有足够的服务容量是高可用性和冗余性的核心思想。健康检查就是用来确保服务不仅仅是运行的，并且它们还是健康和可操作的。</p><p>ECS：ECS使用ELB(Elastic Load Balancer)健康检查，这种方式有三个主要的缺点：</p><p>\1. ELB健康检查仅仅限于HTTP/TCP检查</p><p>\2. 如果你想要对一个不开放TCP端口的服务进行检查，这是不行的。仅仅是为了能够进行健康检查，你就必须运行一个HTTP/TCP服务器。</p><p>\3. 即便你拥有一个支持HTTP/TCP的服务，你还需要创建一个ELB，并将它绑定到这个服务上，这样才能进行健康检查。</p><p>Kubernetes：除了基于HTTP/TCP的健康检查，Kubernetes还提供了一种叫做Exec的方式。Exec可以让用户在容器中运行命令。如果命令结束，并且返回0则表示这个服务是健康的，否则这个服务很可能是不健康的，它会被其他的实例所替换。</p><p>比较结果：Kubernetes的方式更灵活，更简单配置。用户并不需要去启动一个冗余的HTTP/TCP服务器仅仅为了进行健康检查，并且即便服务没有绑定ELB，你也可以对它们进行健康检查。</p><h3 id="端口管理（Port-Management）"><a href="#端口管理（Port-Management）" class="headerlink" title="端口管理（Port Management）"></a>端口管理（Port Management）</h3><p>从我们的上篇文章中可以看出，端口管理在Docker中是比较困难的。我们想通过一个简单的例子来说明Kubernetes如何比ECS更优雅的解决了这个问题。我们拥有一台虚拟机和两个监听80端口的网站。我们不能够在同一个虚拟机上开2个80端口，因此我们需要寻找一个方法来解决这个问题。</p><p>ECS:用户必须手工确定两个服务没有使用同一个端口。我们只有一台虚拟机，因此只能运行一个开放80端口的容器。当我们想要开启第二个开放80端口的容器时，这是不行的，因为我们没有多余的虚拟机了。也就是说，能够开放多少个x端口的服务取决于拥有多少个虚拟机。在小型集群中，这是非常容易满足的条件，但是当你的服务数量变得越来越多时，这将成为一个头疼的问题，因为当你想要扩充容器时，你必须确认你还有足够的端口。</p><p>Kubernetes：Kubernetes非常优雅的解决了这个问题。它为每一个虚拟机上的容器都分配了一个随机的端口。然后它创建了2个ELB，一个将80端口转发到容器A的随机端口上，另外一个转发到容器B的随机端口上。一个内部的路由机制会负责将数据包转发到对应容器端口。</p><p>比较结果：Kubernetes使用虚拟端口的方式代替绑定原始端口的方法，很好的解决了这个头疼的问题。</p><h3 id="记录（Logging）"><a href="#记录（Logging）" class="headerlink" title="记录（Logging）"></a>记录（Logging）</h3><p>没有什么系统不需要记录功能。</p><p>我从没有想过记录会成为一个大问题，但能够为你解决问题令我非常的高兴，即便这个问题非常简单。我们之前提到Kubernetes提供了一个服务发现的扩展功能，在这里，我想说的是记录的扩展功能。它含有两个不同的记录和度量收集（metric collection）的机制。第一种是著名的</p><p>ELK</p><p>方法，ELK会收集容器的所有记录，并且能够让用户通过Kibana接口来查询和可视化这些记录。第二种是InfluxDB，它使用</p><p>Grafana</p><p>作为可视化工具来查询系统信息，如CPU和内存使用情况。</p><p>比较结果：Kubernetes的扩展功能更胜一筹。当然，你会说我并不需要这些扩展，系统也能很好工作，但是，它们效果如此之好，并且能适用于99%的用例，为什么不使用呢？ECS并没有提供内置的记录功能，用户想要集成一个进去并不是很困难，但是这些并不能和Kubernetes提供的功能相提并论。</p><h3 id="未知的云平台（Cloud-Agnostic）"><a href="#未知的云平台（Cloud-Agnostic）" class="headerlink" title="未知的云平台（Cloud Agnostic）"></a>未知的云平台（Cloud Agnostic）</h3><p>其实，Kubernetes和ECS之间并不存在竞争：）</p><p>ECS会专注于AWS平台，如果你已经在ECS上构建了你的基础架构，当你想要转移到其他云平台时，你将会遇到很多困难。</p><p>Kubernetes适用于多个云平台。你可以在AWS，Google Cloud，微软的ZURE，Rackspace等等上运行你的集群，并且运行效果或多或少都是相同的。在这里，或多或少指的是有一些功能只有部分云供应商提供。你必须确认你选择的新供应商能够支持Kubernetes中使用的功能，至少确保迁移是可能的。</p><h3 id="开源软件（OSS）"><a href="#开源软件（OSS）" class="headerlink" title="开源软件（OSS）"></a>开源软件（OSS）</h3><p>Kubernetes是开源的项目，而ECS不是。这意味着，所有的一切，从源代码到未来的发展路线都是对你开放的。发现了漏洞？你可以创建一个issue或者直接提交一个pull 请求来修复它。新的功能会被添加到每一个新版本，其中的贡献人数和pull请求是惊人的。</p><p>ECS有着不同的性质，我不能够在网上找到关于它未来发展路线的规划。你不能够获得一个漏洞和issue的列表，你必须深入到论坛上去寻找想要的答案。并且你寻找的答案往往都是缺乏实际的，并不能够提供任何帮助（请看</p><p>这里</p><p>）。也许这仅仅是因为我个人的糟糕经历，但是不管怎么说，这都是令人烦躁和失望的。</p><p>比较结果：就我个人而言，我更喜欢开源软件。我喜欢Kubernetes的开放性，每个人都能够参与讨论和贡献代码。我相信社区的力量会给我们带来一个更好的产品。</p><h3 id="多可用区域（Multi-AZ）"><a href="#多可用区域（Multi-AZ）" class="headerlink" title="多可用区域（Multi-AZ）"></a>多可用区域（Multi-AZ）</h3><p>当谈论到Kubernetes时，有一件事情困扰着我：它不支持AWS上的多可用区域集群（multiple availability-zones cluters）。这意味着所有EC2实例都集中在一个AZ上，这使得你的集群很可能会遭受到中断问题。</p><p>ECS有对Multi-AZ有很好的支持。</p><p>比较结果：在Kubernetes的issue上，已经有一些工作正在进行。我十分确定下个版本会很好的得到改善。因此ECS在这一点上的胜利并不会长久。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很多公司都开始使用Docker作为他们的主要基础设置，传递机制（delivery mechanism）和编排框架（orchestration frameworks）成为了系统的核心，并且影响着我们开发，迁移，运行，升级的方式。当我想要比较ECS和Kubernetes时，我找不到类似的文章。所以我认为把我们的经验公布出来非常的重要，这样其他人能够站在我们的肩膀上看的更远。</p><p>对于nanit.com来说，Kubernetes毫无疑问获得了胜利。如果你有任何的异议，请告诉我理由，我非常想要知道这些内容：）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。&lt;/p&gt;
&lt;p&gt;3个月前，我们在&lt;/p&gt;
&lt;p&gt;nanit.com&lt;/p&gt;
&lt;p&gt;希望选择一个合适的Docker
      
    
    </summary>
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="http://blog.ozairs.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins与Docker的自动化CI/CD实战</title>
    <link href="http://blog.ozairs.com/DevOps/Jenkins%E4%B8%8EDocker%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96CI-CD%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.ozairs.com/DevOps/Jenkins与Docker的自动化CI-CD实战/</id>
    <published>2019-03-17T02:48:26.000Z</published>
    <updated>2019-03-17T03:02:41.598Z</updated>
    
    <content type="html"><![CDATA[<p>在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。</p><h2 id="一、发布流程设计"><a href="#一、发布流程设计" class="headerlink" title="一、发布流程设计"></a>一、发布流程设计</h2><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/1.1.png" alt=""></p><p>工作流程：**</p><ol><li>开发人员提交代码到Git版本仓库；</li><li>Jenkins人工/定时触发项目构建；</li><li>Jenkins拉取代码、代码编码、打包镜像、推送到镜像仓库；</li><li>Jenkins在Docker主机创建容器并发布。</li></ol><p>环境规划如下：</p><table><thead><tr><th>角色</th><th>IP</th></tr></thead><tbody><tr><td>Jenkins/Docker</td><td>192.168.0.217</td></tr><tr><td>Docker</td><td>192.168.0.218</td></tr><tr><td>Git/Registry</td><td>192.168.0.219</td></tr></tbody></table><p>操作系统：CentOS7.4</p><h2 id="二、部署Git仓库"><a href="#二、部署Git仓库" class="headerlink" title="二、部署Git仓库"></a>二、部署Git仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install git -y</span><br></pre></td></tr></table></figure><ol><li><p>创建Git用户并设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># useradd git</span><br><span class="line"># passwd git</span><br></pre></td></tr></table></figure></li><li><p>创建仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># su - git</span><br><span class="line"># mkdir solo.git</span><br><span class="line"># cd solo.git</span><br><span class="line"># git --bare init</span><br></pre></td></tr></table></figure></li><li><p>访问创建的这个仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone git@192.168.0.212:/home/git/solo.git</span><br></pre></td></tr></table></figure><h2 id="三、准备Jenkins环境"><a href="#三、准备Jenkins环境" class="headerlink" title="三、准备Jenkins环境"></a>三、准备Jenkins环境</h2><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于代码编译、部署、测试等工作。 Jenkins也是一个跨平台的，大多数主流的平台都支持，而且安装很简单，我们这里以部署war包方式安装它。<br>官网下载地址：<a href="https://jenkins.io/download/" target="_blank" rel="noopener">https://jenkins.io/download/</a> </p><p>在安装前需要具备Java环境，安装方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tar zxf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8 </span><br><span class="line"># vi /etc/profile </span><br><span class="line">JAVA_HOME=/usr/local/jdk1.8 </span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar </span><br><span class="line">export JAVA_HOME PATH CLASSPATH</span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>在192.168.0.217主机安装Jenkins，下载Tomcat二进制包将war包到webapps下即可：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war </span><br><span class="line"># wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.32/bin/apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># tar zxf apache-tomcat-8.5.32.tar.gz </span><br><span class="line"># mv apache-tomcat-8.5.32 /usr/local/tomcat-jenkins </span><br><span class="line"># rm /usr/local/tomcat-jenkins/webapps/* -rf </span><br><span class="line"># unzip jenkins.war -d /usr/local/tomcat-jenkins/webapps/ROOT </span><br><span class="line"># cd /usr/local/tomcat-jenkins/bin/ </span><br><span class="line"># ./startup.sh </span><br><span class="line"># tail ../logs/catalina.out -f </span><br><span class="line">... </span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated. </span><br><span class="line">Please use the following password to proceed to installation: </span><br><span class="line"></span><br><span class="line">a5f1f7c167fd4b8ab62f9497d32d97db </span><br><span class="line"></span><br><span class="line">This may also be found at: /root/.jenkins/secrets/initialAdminPassword ...</span><br></pre></td></tr></table></figure><p>部署成功，访问Jenkins：<a href="http://ip:8080/" target="_blank" rel="noopener">http://ip:8080</a></p><p>第一步：输入上面日志输出的密码：a5f1f7c167fd4b8ab62f9497d32d97db，或者从本机/root/.jenkins/secrets/initialAdminPassword文件获取，点击继续<br>第二步：点击“选择插件来安装”<br>第三步：保持默认，点击继续<br>第四步：创建管理员用户，保存并完成<br>第五步：设置Jenkins访问地址，保持默认，点击保存完成</p><p>安装完成，开始使用Jenkins：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/2.png" alt=""></p><h2 id="四、部署私有镜像仓库"><a href="#四、部署私有镜像仓库" class="headerlink" title="四、部署私有镜像仓库"></a>四、部署私有镜像仓库</h2><p>Docker Hub作为Docker默认官方公共镜像；如果想自己搭建私有镜像仓库，官方也提供registry镜像，使得搭建私有仓库非常简单。<br>在192.168.0.219部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>接下来测试registry可用性。<br>由于Docker CLI默认以HTTPS访问，而部署的registry并未提供HTTPS，因此，需要在pull镜像的Docker主机（192.168.0.217，192.168.0.218）添加HTTP可信任：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> # vi /etc/docker/daemon.json </span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.0.219:5000&quot;]&#125;</span><br><span class="line"># service docker restart</span><br></pre></td></tr></table></figure><h2 id="五、安装Docker"><a href="#五、安装Docker" class="headerlink" title="五、安装Docker"></a>五、安装Docker</h2><p>在192.168.0.217/192.168.0.218/192.168.0.219主机安装Docker，如下：</p><ol><li><p>安装依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li><li><p>添加Docker软件包源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># yum install docker-ce -y</span><br></pre></td></tr></table></figure></li><li><p>配置加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://bc437cce.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>启动并开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start docker</span><br><span class="line"># systemctl enable docker</span><br></pre></td></tr></table></figure><h2 id="六、构建Tomcat基础镜像"><a href="#六、构建Tomcat基础镜像" class="headerlink" title="六、构建Tomcat基础镜像"></a>六、构建Tomcat基础镜像</h2><p>JAVA程序必须有JDK环境才可以运行，为了减少镜像大小及提高性能，这里直接把JDK放到宿主机上，容器以挂载形式使用。<br>在192.168.0.217/192.168.0.218安装JDK：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf jdk-8u45-linux-x64.tar.gz </span><br><span class="line"># mv jdk-8u45-linux-x64 /usr/local/jdk1.8</span><br></pre></td></tr></table></figure><p>Tomcat基础镜像Dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER www.aliangedu.com</span><br><span class="line"></span><br><span class="line">ENV VERSION=8.5.32</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk</span><br><span class="line"></span><br><span class="line">RUN yum install wget -y</span><br><span class="line"></span><br><span class="line">RUN wget http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v$&#123;VERSION&#125;/bin/apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    tar zxf apache-tomcat-$&#123;VERSION&#125;.tar.gz &amp;&amp; \</span><br><span class="line">    mv apache-tomcat-$&#123;VERSION&#125; /usr/local/tomcat &amp;&amp; \</span><br><span class="line">    rm -rf apache-tomcat-$&#123;VERSION&#125;.tar.gz /usr/local/tomcat/webapps/* &amp;&amp; \</span><br><span class="line">    mkdir /usr/local/tomcat/webapps/ROOT</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br></pre></td></tr></table></figure><p>构建镜像并上传到registry：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker build -t 192.168.0.219:5000/tomcat-85 -f Dockerfile .</span><br><span class="line"># docker push 192.168.0.219:5000/tomcat-85</span><br></pre></td></tr></table></figure><h2 id="七、Jenkins配置全局工具配置"><a href="#七、Jenkins配置全局工具配置" class="headerlink" title="七、Jenkins配置全局工具配置"></a>七、Jenkins配置全局工具配置</h2><p>主页面 -&gt; 系统管理 -&gt; 全局工具配置</p><p>指定JDK、Maven路径，Git保持默认：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/3.png" alt=""><br>如果Jenkins主机没有git命令，需要安装Git：<br><code># yum install git -y</code></p><h2 id="八、Jenkins安装必要插件"><a href="#八、Jenkins安装必要插件" class="headerlink" title="八、Jenkins安装必要插件"></a>八、Jenkins安装必要插件</h2><p><strong>1. Jenkins安装必要插件</strong><br>主页面 -&gt; 系统管理 -&gt;管理插件：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/4.png" alt=""><br>安装SSH与Git Parameter插件。</p><p>插件说明：</p><ul><li>SSH：用于SSH远程Docker主机执行Shell命令</li><li>Git Parameter：动态获取Git仓库Branch、Tag</li></ul><p><strong>2. 配置SSH插件</strong><br><strong>第一步：先创建一个用于连接Docker主机的凭据。</strong><br>主页面 -&gt; 凭据 -&gt; 系统 -&gt; 右击全局凭据 -&gt; 添加凭据：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/5.png" alt="">输入连接Docker主机的用户名和密码：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/6.png" alt=""><br><strong>第二步：添加SSH远程主机</strong><br>主页面 -&gt; 系统管理 -&gt; 系统设置 -&gt; SSH remote hosts：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/7.png" alt=""></p><h2 id="九、上传JAVA项目代码到Git仓库"><a href="#九、上传JAVA项目代码到Git仓库" class="headerlink" title="九、上传JAVA项目代码到Git仓库"></a>九、上传JAVA项目代码到Git仓库</h2><p>从Github拉取开源JAVA博客系统solo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/b3log/solo</span><br><span class="line"># cd solo</span><br><span class="line">移除旧的推送地址，添加新的：</span><br><span class="line"># git remote remove origin </span><br><span class="line"># git remote add origin git@192.168.0.219:/home/git/solo.git</span><br><span class="line">提交代码到Git仓库并创建tag：</span><br><span class="line"># touch src/main/webapp/a.html</span><br><span class="line"># git add .</span><br><span class="line"># git commit -m “a”</span><br><span class="line">创建标签：</span><br><span class="line"># git tag 1.0.0</span><br><span class="line">推送到Git服务器：</span><br><span class="line"># git push origin 1.0.0</span><br></pre></td></tr></table></figure><h2 id="十、Jenkins创建项目并发布测试"><a href="#十、Jenkins创建项目并发布测试" class="headerlink" title="十、Jenkins创建项目并发布测试"></a>十、Jenkins创建项目并发布测试</h2><p>主页面 -&gt; 新建任务 -&gt; 输入任务名称，构建一个Maven项目：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/8.png" alt=""><br>注意：如果没有显示“构建一个Maven项目”选项，需要在管理插件里安装“Maven Integration plugin”插件。<br>配置Git参数化构建：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/9.png" alt=""><br>动态获取Git仓库tag，与用户交互选择Tag发布：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/10.png" alt=""><br>指定项目Git仓库地址：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/11.png" alt=""><br>修改*/master为$Tag，Tag是上面动态获取的变量名，表示根据用户选择打代码版本。</p><p>设置maven构建命令选项：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/12.png" alt=""></p><p>利用pom.xml文件构建项目。<br>在Jenkins本机镜像构建与推送到镜像仓库，并SSH远程连接到Docker主机使用推送的镜像创建容器：<br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/13.png" alt=""><br>上图中，在Jenkins主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 构建镜像</span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM 192.168.0.219:5000/tomcat-85:latest</span><br><span class="line">RUN rm -rf /usr/local/tomcat/webapps/ROOT</span><br><span class="line">COPY target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</span><br><span class="line">EOF</span><br><span class="line">docker build -t $REPOSITORY .</span><br><span class="line"># 上传镜像</span><br><span class="line">docker push $REPOSITORY</span><br></pre></td></tr></table></figure><p>上图中，SSH远程Docker主机执行的Shell命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY=192.168.0.219:5000/solo:$&#123;Tag&#125;</span><br><span class="line"># 部署</span><br><span class="line">docker rm -f blog-solo |true</span><br><span class="line">docker image rm $REPOSITORY |true</span><br><span class="line">docker container run -d --name blog-solo -v /usr/local/jdk1.8:/usr/local/jdk -p 88:8080 $REPOSITORY</span><br></pre></td></tr></table></figure><p>注：容器名称blog-solo，暴露宿主机端口88，即使用宿主机IP:88访问blog-solo项目。<br>blog-solo项目已配置完成，开始构建：</p><p>选择tag，开始构建：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/14.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/15.png" alt=""></p><p>点击左下角构建历史里，右击第一个查看控制台输出：</p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/16.png" alt=""></p><p><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/17.png" alt=""></p><p>浏览器访问solo项目：<a href="http://192.168.0.218:88/" target="_blank" rel="noopener">http://192.168.0.218:88</a><br><img src="/DevOps/Jenkins与Docker的自动化CI-CD实战/18.png" alt=""><br>如果输出上述页面说明是正常的，页面没有加载成功样式，需要修改下项目里访问地址。</p><p>至此，自动化CI环境搭建完成，你可以模拟提交代码并打tag测试自动化发布流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在互联网时代，对于每一家公司，软件开发和发布的重要性不言而喻，目前已经形成一套标准的流程，最重要的组成部分就是持续集成（CI）及持续部署、交付（CD）。本文基于Jenkins+Docker+Git实现一套CI自动化发布流程。&lt;/p&gt;
&lt;h2 id=&quot;一、发布流程设计&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="Jenkins" scheme="http://blog.ozairs.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>把一个Node.js web应用程序给Docker化</title>
    <link href="http://blog.ozairs.com/DevOps/%E6%8A%8A%E4%B8%80%E4%B8%AANode-js-web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%99Docker%E5%8C%96/"/>
    <id>http://blog.ozairs.com/DevOps/把一个Node-js-web应用程序给Docker化/</id>
    <published>2019-03-17T02:26:13.000Z</published>
    <updated>2019-03-17T03:02:41.595Z</updated>
    
    <content type="html"><![CDATA[<p>本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 <em>非</em> 产品发布人员。此教程同样假定你有一个可以正常工作的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">Docker 安装</a>，并且对于 Node.js 的应用程序是如何组织的有一个大致的基本了解。</p><p>在本教程的第一部分我们在 Node.js 中创建一个 Web 的应用程序，然后我们为那个应用构建一个 Docker 镜像；最后我们将把那个镜像作为容器运行之。</p><p>Docker 允许你以应用程序所有的依赖全部打包成一个标准化的单元，这被成为一个容器。对于应用开发而言，一个容器就是一个蜕化到最基础的 Linux 操作系统。一个镜像是你加载到容器中的软件。</p><h2 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h2><p>首先，创建一个新文件夹以便于容纳需要的所有文件，并且在此其中创建一个 <code>package.json</code> 文件，描述你应用程序以及需要的依赖：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"docker_web_app"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"Node.js on Docker"</span>,</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"First Last &lt;first.last@example.com&gt;"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"server.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.1"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合着你的 <code>package.json</code> 请运行 <code>npm install</code>。如果你使用的 <code>npm</code> 是版本 5 或者之后的版本，这会自动生成一个 <code>package-lock.json</code> 文件，它将一起被拷贝进入你的 Docker 镜像中。</p><p>然后，创建一个 <code>server.js</code> 文件，使用 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express.js</a> 框架定义一个 Web 应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'0.0.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'Hello world\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(PORT, HOST);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在稍后的步骤中我们将看一下借助使用官方的 Docker 镜像，你如何在 Docker 镜像中运行这个应用。首先，你需要一个构建一个应用程序的 Docker 应用。</p><h2 id="创建一个名称为-Dockerfile-的文件"><a href="#创建一个名称为-Dockerfile-的文件" class="headerlink" title="创建一个名称为 Dockerfile 的文件"></a>创建一个名称为 <code>Dockerfile</code> 的文件</h2><p>创建一个空文件，命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>用你最喜欢的文本编辑器打开这个 <code>Dockerfile</code>。</p><p>我们要做的第一件事是定义我们需要从哪个镜像进行构建。这里我们将使用最新的 LTS（长期服务器支持版），<code>Node</code> 的版本号为 <code>8</code>。你可以从 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker 站点</a> 获取相关镜像：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>下一步在镜像中创建一个文件夹存放应用程序代码，这将是你的应用程序工作目录：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br></pre></td></tr></table></figure><p>此镜像中 Node.js 和 NPM 都已经安装，所以下一件事对于我们而言是使用 <code>npm</code> 安装你的应用程序的所有依赖。请注意，如果你的 <code>npm</code> 的版本是 4 或者更早的版本，<code>package-lock.json</code> 文件将不会自动生成。</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Install app dependencies</span></span><br><span class="line"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span><br><span class="line"><span class="comment"># where available (npm@5+)</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br></pre></td></tr></table></figure><p>请注意，我们只是拷贝了 <code>package.json</code> 文件而非整个工作目录。这允许我们利用缓存 Docker 层的优势。bitJudo 对此有一个很好的解释，请 <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" target="_blank" rel="noopener">见此</a>。 进一步说，对于生产环境而言，注释中提及的 <code>npm ci</code> 命令协助提供了一个更快、可靠、可再生的构建环境。欲知详情，可以参考<a href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" target="_blank" rel="noopener">此处</a>。</p><p>在 Docker 镜像中使用 <code>COPY</code> 命令绑定你的应用程序：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bundle app source</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure><p>你的应用程序绑定的端口为 <code>8080</code>，所以你可以使用 <code>EXPOSE</code> 命令使它与 <code>docker</code> 的镜像做映射：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>最后但同样重要的事是，使用定义运行时的 <code>CMD</code> 定义命令来运行应用程序。这里我们使用最简单的 <code>npm start</code> 命令，它将运行 <code>node server.js</code> 启动你的服务器：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><p>你的 <code>Dockerfile</code> 现在看上去是这个样子：</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create app directory</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Install app dependencies</span></span></span><br><span class="line"><span class="bash"><span class="comment"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span></span></span><br><span class="line"><span class="bash"><span class="comment"># where available (npm@5+)</span></span></span><br><span class="line"><span class="bash">COPY package*.json ./</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN npm install</span></span><br><span class="line"><span class="bash"><span class="comment"># If you are building your code for production</span></span></span><br><span class="line"><span class="bash"><span class="comment"># RUN npm ci --only=production</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Bundle app source</span></span></span><br><span class="line"><span class="bash">COPY . .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8080</span></span><br><span class="line"><span class="bash">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure><h2 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h2><p>在 <code>Dockerfile</code> 的同一个文件夹中创建一个 <code>.dockerignore</code> 文件，带有以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了。</p><h2 id="构建你的镜像"><a href="#构建你的镜像" class="headerlink" title="构建你的镜像"></a>构建你的镜像</h2><p>进入到 <code>Dockerfile</code> 所在的那个目录中，运行以下命令构建 Docker 镜像。开关符 <code>-t</code> 让你标记你的镜像，以至于让你以后很容易地用 <code>docker images</code> 找到它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t &lt;your username&gt;/node-web-app .</span><br></pre></td></tr></table></figure><p>Docker 现在将给出你的镜像列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">REPOSITORY                      TAG        ID              CREATED</span><br><span class="line">node                            8          1934b0b038d1    5 days ago</span><br><span class="line">&lt;your username&gt;/node-web-app    latest     d64d3505b0d2    1 minute ago</span><br></pre></td></tr></table></figure><h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><p>使用 <code>-d</code> 模式运行镜像将以分离模式运行 Docker 容器，使得容器在后台自助运行。开关符 <code>-p</code> 在容器中把一个公共端口导向到私有的端口，请用以下命令运行你之前构建的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 49160:8080 -d &lt;your username&gt;/node-web-app</span><br></pre></td></tr></table></figure><p>把你应用程序的输出打印出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get container ID</span></span><br><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print app output</span></span><br><span class="line">$ docker logs &lt;container id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">Running on http://localhost:8080</span><br></pre></td></tr></table></figure><p>如果你需要进入容器中，请运行 <code>exec</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enter the container</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it &lt;container id&gt; /bin/bash</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为测试你的应用程序，给出与 Docker 映射过的端口号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># Example</span></span><br><span class="line">ID            IMAGE                                COMMAND    ...   PORTS</span><br><span class="line">ecce33b30ebf  &lt;your username&gt;/node-web-app:latest  npm start  ...   49160-&gt;8080</span><br></pre></td></tr></table></figure><p>在上面的例子中，在容器中 Docker 把端口号 <code>8080</code> 映射到你机器上的 <code>49160</code> 。</p><p>现在你可以使用 <code>curl</code>（如果需要的话请通过 <code>sudo apt-get install curl</code> 安装）调用你的程序了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i localhost:49160</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Powered-By: Express</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 12</span><br><span class="line">ETag: W/<span class="string">"c-M6tWOb/Y57lesdjQuHeB1P/qTV0"</span></span><br><span class="line">Date: Mon, 13 Nov 2017 20:53:59 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>我们希望本教程能够帮助你起步，在 Docker 中运行一个简单的 Node.js 应用程序。</p><p>你也可以在以下一些地方寻觅到更多有关于 Docker 和基于 Docker 的 Node.js 相关内容：</p><ul><li><a href="https://hub.docker.com/_/node/" target="_blank" rel="noopener">官方 Node.js 的 Docker 镜像</a></li><li><a href="https://github.com/nodejs/docker-node/blob/master/docs/BestPractices.md" target="_blank" rel="noopener">Node.js 基于 Docker 使用的最佳经验</a></li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">官方 Docker 文档</a></li><li><a href="https://stackoverflow.com/questions/tagged/docker" target="_blank" rel="noopener">在 StackOverFlow 上有关 Docker 标记内容</a></li><li><a href="https://reddit.com/r/docker" target="_blank" rel="noopener">Docker Subreddit</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本示例的目标是给你演示如何将一个 Node.js 的应用装入到 Docker 容器中。本教程旨在针对于开发人员，而 &lt;em&gt;非&lt;/em&gt; 产品发布人员。此教程同样假定你有一个可以正常工作的 &lt;a href=&quot;https://docs.docker.com/engine/in
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="NodeJs" scheme="http://blog.ozairs.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>CloudFormation CLI命令</title>
    <link href="http://blog.ozairs.com/AWS/CloudFormation-CLI%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.ozairs.com/AWS/CloudFormation-CLI命令/</id>
    <published>2019-03-16T11:47:59.000Z</published>
    <updated>2019-03-16T11:52:06.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Creating-a-Stack"><a href="#Creating-a-Stack" class="headerlink" title="Creating a Stack"></a>Creating a Stack</h2><p>You must provide the stack name, the location of a valid template, and any input parameters. If you specify a local template file, AWS CloudFormation uploads it to an Amazon S3 bucket in your AWS account.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation create-stack --stack-name myteststack --template-body file:///home/testuser/mytemplate.json --parameters ParameterKey=Parm1,ParameterValue=test1 ParameterKey=Parm2,ParameterValue=test2</span><br></pre></td></tr></table></figure><h2 id="Listing-Your-Stacks"><a href="#Listing-Your-Stacks" class="headerlink" title="Listing Your Stacks"></a>Listing Your Stacks</h2><p>Note The aws cloudformation list-stacks command returns information on deleted stacks for 90 days after they have been deleted.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE</span><br></pre></td></tr></table></figure><h2 id="Describing-Your-Stacks"><a href="#Describing-Your-Stacks" class="headerlink" title="Describing Your Stacks"></a>Describing Your Stacks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stacks --stack-name myteststack</span><br></pre></td></tr></table></figure><p>By default, aws cloudformation describe-stacks returns parameter values. To prevent sensitive parameter values such as passwords from being returned, include a NoEcho property set to TRUE in your AWS CloudFormation template.</p><h2 id="Viewing-Stack-Event-History"><a href="#Viewing-Stack-Event-History" class="headerlink" title="Viewing Stack Event History"></a>Viewing Stack Event History</h2><p>You can track the status of the resources AWS CloudFormation is creating and deleting with the aws cloudformation describe-stack-events command. The amount of time to create or delete a stack depends on the complexity of your stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation describe-stack-events --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Listing-Stack-Resources"><a href="#Listing-Stack-Resources" class="headerlink" title="Listing Stack Resources"></a>Listing Stack Resources</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation list-stack-resources --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Retrieving-a-Template"><a href="#Retrieving-a-Template" class="headerlink" title="Retrieving a Template"></a>Retrieving a Template</h2><p>AWS CloudFormation stores the template you use to create your stack as part of the stack.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation get-template --stack-name myteststack</span><br></pre></td></tr></table></figure><h2 id="Validating-a-Template"><a href="#Validating-a-Template" class="headerlink" title="Validating a Template"></a>Validating a Template</h2><p>You can validate templates locally by using the –template-body parameter, or remotely with the –template-url parameter.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation validate-template --template-url https://s3.amazonaws.com/cloudformation-templates-us-east-1/S3_Bucket.template</span><br><span class="line">$ aws cloudformation validate-template --template-body file:///home/local/test/sampletemplate.json</span><br></pre></td></tr></table></figure><h2 id="Deleting-a-Stack"><a href="#Deleting-a-Stack" class="headerlink" title="Deleting a Stack"></a>Deleting a Stack</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ aws cloudformation delete-stack --stack-name myteststack</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Creating-a-Stack&quot;&gt;&lt;a href=&quot;#Creating-a-Stack&quot; class=&quot;headerlink&quot; title=&quot;Creating a Stack&quot;&gt;&lt;/a&gt;Creating a Stack&lt;/h2&gt;&lt;p&gt;You must provi
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="CloudFormation" scheme="http://blog.ozairs.com/tags/CloudFormation/"/>
    
  </entry>
  
  <entry>
    <title>Ansible常用模块</title>
    <link href="http://blog.ozairs.com/Ansible/Ansible%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.ozairs.com/Ansible/Ansible常用模块/</id>
    <published>2019-03-16T11:25:04.000Z</published>
    <updated>2019-03-16T11:26:18.285Z</updated>
    
    <content type="html"><![CDATA[<p>Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（<a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）。这里从官方分类的模块里选择最常用的一些模块进行介绍。</a></p><p>1，ping模块。测试主机是否是通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m ping</span></span><br><span class="line">Server5 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br><span class="line">Server6 | SUCCESS =&gt; &#123;</span><br><span class="line">    <span class="string">"changed"</span>: <span class="literal">false</span>, </span><br><span class="line">    <span class="string">"ping"</span>: <span class="string">"pong"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2，远程命令模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible webserver -m <span class="built_in">command</span> -a <span class="string">"free -m"</span>  <span class="comment">#远程命令。</span></span><br><span class="line">ansible webserver -m script -a <span class="string">"/home/test.sh"</span> <span class="comment">#远程主机执行主控服务器ansible上的脚本</span></span><br><span class="line">ansible webserver -m shell -a <span class="string">"/home/test.sh"</span>   <span class="comment">#执行远程主机上的脚本命令</span></span><br></pre></td></tr></table></figure><p>3，setup模块。主要用于获取主机信息，在playbooks里经常会用到的一个参数，gather_facts就与该模块相关。setup模块下经常使用的一个参数是filter参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_*_mb'</span>   //查看主机内存信息</span><br><span class="line">ansible 10.212.52.252 -m setup -a <span class="string">'filter=ansible_eth[0-2]'</span>   //查看地接口为eth0-2的网卡信息</span><br><span class="line">ansible all -m setup --tree /tmp/facts   //将所有主机的信息输入到/tmp/facts目录下，每台主机的信息输入到主机名文件中（/etc/ansible/hosts里的主机名）</span><br></pre></td></tr></table></figure><p>4，stat模块。获取远程文件状态信息,包括atime、ctime、mtime、MD5、uid、gid等信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.5 -m stat -a "path=/etc/sysctl.conf </span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.5 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": false, </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">stat</span><span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>atime<span class="string">": 1504513902.6297896, </span></span><br><span class="line"><span class="string">        "</span>checksum<span class="string">": "</span>a27c7ce2e6002c37f3cb537ad997c6da7fd76480<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>ctime<span class="string">": 1480926522.4591811, </span></span><br><span class="line"><span class="string">        "</span>dev<span class="string">": 64768, </span></span><br><span class="line"><span class="string">        "</span>executable<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>exists<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>gr_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>inode<span class="string">": 393634, </span></span><br><span class="line"><span class="string">        "</span>isblk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>ischr<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isdir<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isfifo<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isgid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>islnk<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isreg<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>issock<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>isuid<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>md5<span class="string">": "</span>c97839af771c8447b9fc23090b4e8d0f<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>mtime<span class="string">": 1361531931.0, </span></span><br><span class="line"><span class="string">        "</span>nlink<span class="string">": 1, </span></span><br><span class="line"><span class="string">        "</span>path<span class="string">": "</span>/etc/sysctl.conf<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>pw_name<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">        "</span>readable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rgrp<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>roth<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>rusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>size<span class="string">": 1150, </span></span><br><span class="line"><span class="string">        "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">        "</span>wgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>woth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>writeable<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>wusr<span class="string">": true, </span></span><br><span class="line"><span class="string">        "</span>xgrp<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xoth<span class="string">": false, </span></span><br><span class="line"><span class="string">        "</span>xusr<span class="string">": false</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>5，file模块。file模块主要用于远程主机上的文件操作，file模块包含如下选项： </p><p>force：需要在两种情况下强制创建软链接，一种是源文件不存在但之后会建立的情况下；另一种是目标软链接已存在,需要先取消之前的软链，然后创建新的软链，有两个选项：yes|no </p><ul><li>group：定义文件/目录的属组 </li><li>mode：定义文件/目录的权限</li><li>owner：定义文件/目录的属主</li><li>path：必选项，定义文件/目录的路径</li><li>recurse：递归的设置文件的属性，只对目录有效</li><li>src：要被链接的源文件的路径，只应用于state=link的情况</li><li>dest：被链接到的路径，只应用于state=link的情况 </li><li>state：    </li><li>directory：如果目录不存在，创建目录</li><li>file：即使文件不存在，也不会被创建</li><li>link：创建软链接</li><li>hard：创建硬链接</li><li>touch：如果文件不存在，则会创建一个新的文件，如果文件或目录已存在，则更新其最后修改时间</li><li>absent：删除目录、文件或者取消链接文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m file -a "src=/etc/fstab dest=/</span></span><br><span class="line">tmp/fstab state=link<span class="string">"                         ########在远程主机180.6上创建远程软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 10, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/etc/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>link<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">touch<span class="string">"                                 ############在远程主机180.6上创建test文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0644<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 5, </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/<span class="built_in">test</span> state=</span><br><span class="line">absent<span class="string">"                                #############在远程主机删除文件</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/<span class="built_in">test</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m file -a "</span>path=/tmp/fstab state</span><br><span class="line">=absent<span class="string">"                                            #############在远程主机删除fstab软连接</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>path<span class="string">": "</span>/tmp/fstab<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>absent<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>6，copy模块。实现复制文件到远程主机，copy模块包含如下选项：</p><ul><li>backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no </li><li>content：用于替代”src”,可以直接设定指定文件的值 </li><li>dest：必选项。要将源文件复制到的远程主机的绝对路径，如果源文件是一个目录，那么该路径也必须是个目录 </li><li>directory_mode：递归的设定目录的权限，默认为系统默认权限</li><li>force：如果目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，如果为no，则只有当目标主机的目标位置不存在该文件时，才复制。默认为yes</li><li>others：所有的file模块里的选项都可以在这里使用</li><li>src：要复制到远程主机的文件在本地的地址，可以是绝对路径，也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用”/“来结尾，则只复制目录里的内容，如果没有使用”/“来结尾，则包含目录在内的整个内容全部复制，类似于rsync。 </li></ul><p>以下的例子试下拷贝/etc/ansible/script.sh文件到主机组web1所有的主机/tmp下并更新文件属主和权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible web1 -m copy -a "src=/etc/ansible/script.sh des</span></span><br><span class="line">t=/tmp/ owner=appuser group=appuser mode=0755<span class="string">"      ###复制本地脚本到远程主机server6下并定义用户和组以及权限755</span></span><br><span class="line"><span class="string">Server6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum<span class="string">": "</span>18ca258e92141948010f2e0896cf655cdb945a1d<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/script.sh<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 500, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>d5e15b2da056fdd7b7ba30100035de2e<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0755<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>appuser<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 30, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504517543.07-102988847745614/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 500</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>7,service模块。用于远程主机的服务管理。该模块包含如下选项： </p><ul><li>arguments：给命令行提供一些选项 </li><li>enabled：是否开机启动 yes|no</li><li>name：必选项，服务名称 </li><li>pattern：定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行</li><li>runlevel：运行级别</li><li>sleep：如果执行了restarted，在则stop和start之间沉睡几秒钟</li><li>state：对当前服务执行启动，停止、重启、重新加载等操作（started,stopped,restarted,reloaded）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####重启远程主机180.6的网卡服务</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m service -a "name=network state</span></span><br><span class="line">=restarted args=eth0<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>name<span class="string">": "</span>network<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>started<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>8，cron模块。用于远程主机crontab配置，管理计划任务包含如下选项： </p><ul><li>backup：对远程主机上的原任务计划内容修改之前做备份 </li><li>cron_file：如果指定该选项，则用该文件替换远程主机上的cron.d目录下的用户的任务计划 </li><li>day：日（1-31，<em>，</em>/2,……） </li><li>hour：小时（0-23，<em>，</em>/2，……）  </li><li>minute：分钟（0-59，<em>，</em>/2，……） </li><li>month：月（1-12，<em>，</em>/2，……） </li><li>weekday：周（0-7，*，……）</li><li>job：要执行的任务，依赖于state=present </li><li>name：该任务的描述 </li><li>special_time：指定什么时候执行，参数：reboot,yearly,annually,monthly,weekly,daily,hourly </li><li>state：确认该任务计划是创建还是删除 </li><li>user：以哪个用户的身份执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6  -m cron -a 'name="a job for rebo</span></span><br><span class="line">ot<span class="string">" special_time=reboot job="</span>/some/job.sh<span class="string">"'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>envs<span class="string">": [], </span></span><br><span class="line"><span class="string">    "</span><span class="built_in">jobs</span><span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>a job <span class="keyword">for</span> reboot<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">##########客户端</span></span><br><span class="line"><span class="string">-bash-4.1# crontab -l</span></span><br><span class="line"><span class="string">#Ansible: a job for reboot</span></span><br><span class="line"><span class="string">@reboot /some/job.sh</span></span><br></pre></td></tr></table></figure><p>9，yum模块。Linux平台软件包管理操作 常见的有yum apt 管理方式，其选项有： </p><ul><li>config_file：yum的配置文件 </li><li>disable_gpg_check：关闭gpg_check </li><li>disablerepo：不启用某个源 </li><li>enablerepo：启用某个源</li><li>name：要进行操作的软件包的名字，也可以传递一个url或者一个本地的rpm包的路径 </li><li>state：状态（present，absent，latest）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m yum -a "name=curl state=latest</span></span><br><span class="line"><span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>rc<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>results<span class="string">": [</span></span><br><span class="line"><span class="string">        "</span>已加载插件：fastestmirror\n设置更新进程\nLoading mirror speeds from cached hostfile\n解决依赖关系\n--&gt; 执行事务检查\n---&gt; Package curl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package curl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 处理依赖关系 libcurl = 7.19.7-53.el6_9，它被软件包 curl-7.19.7-53.el6_9.x86_64 需要\n--&gt; 执行事务检查\n---&gt; Package libcurl.x86_64 0:7.19.7-52.el6 will be 升级\n---&gt; Package libcurl.x86_64 0:7.19.7-53.el6_9 will be an update\n--&gt; 完成依赖关系计算\n\n依赖关系解决\n\n================================================================================\n 软件包          架构           版本                      仓库             大小\n================================================================================\n正在升级:\n curl            x86_64         7.19.7-53.el6_9           updates         197 k\n为依赖而更新:\n libcurl         x86_64         7.19.7-53.el6_9           updates         169 k\n\n事务概要\n================================================================================\nUpgrade       2 Package(s)\n\n总下载量：367 k\n下载软件包：\n--------------------------------------------------------------------------------\n总计                                            3.1 MB/s | 367 kB     00:00     \n运行 rpm_check_debug \n执行事务测试\n事务测试成功\n执行事务\n\r  正在升级   : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  正在升级   : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  清理       : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  清理       : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\r  Verifying  : libcurl-7.19.7-53.el6_9.x86_64                               1/4 \n\r  Verifying  : curl-7.19.7-53.el6_9.x86_64                                  2/4 \n\r  Verifying  : curl-7.19.7-52.el6.x86_64                                    3/4 \n\r  Verifying  : libcurl-7.19.7-52.el6.x86_64                                 4/4 \n\n更新完毕:\n  curl.x86_64 0:7.19.7-53.el6_9                                                 \n\n作为依赖被升级:\n  libcurl.x86_64 0:7.19.7-53.el6_9                                              \n\n完毕！\n<span class="string">"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之前</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-52.el6.x86_64</span></span><br><span class="line"><span class="string">#######远程客户端的主机180.6yum更新之后</span></span><br><span class="line"><span class="string">-bash-4.1# rpm -qa|grep curl</span></span><br><span class="line"><span class="string">python-pycurl-7.19.0-9.el6.x86_64</span></span><br><span class="line"><span class="string">libcurl-7.19.7-53.el6_9.x86_64</span></span><br><span class="line"><span class="string">curl-7.19.7-53.el6_9.x86_64</span></span><br></pre></td></tr></table></figure><p>10.user模块。实现远程主机系统用户管理。</p><ul><li>home：指定用户的家目录，需要与createhome配合使用</li><li>groups：指定用户的属组</li><li>uid：指定用的uid</li><li>password：指定用户的密码</li><li>name：指定用户名</li><li>createhome：是否创建家目录 yes|no</li><li>system：是否为系统用户</li><li>remove：当state=absent时，remove=yes则表示连同家目录一起删除，等价于userdel -r</li><li>state：是创建还是删除</li><li>shell：指定用户的shell环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m user -a 'name=www1 comment=lqb</span></span><br><span class="line"> uid=1001 group=root <span class="string">'               ###新建www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "comment": "lqb", </span></span><br><span class="line"><span class="string">    "createhome": true, </span></span><br><span class="line"><span class="string">    "group": 0, </span></span><br><span class="line"><span class="string">    "home": "/home/www1", </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "shell": "/bin/bash", </span></span><br><span class="line"><span class="string">    "state": "present", </span></span><br><span class="line"><span class="string">    "system": false, </span></span><br><span class="line"><span class="string">    "uid": 1001</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -m user -a '</span>name=www1 state=absen</span><br><span class="line">t remove=yes<span class="string">'                     ########删除www1用户</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "force": false, </span></span><br><span class="line"><span class="string">    "name": "www1", </span></span><br><span class="line"><span class="string">    "remove": true, </span></span><br><span class="line"><span class="string">    "state": "absent"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>11.rsynchronize模块。使用rsync同步文件，其参数如下：</p><ul><li>archive: 归档，相当于同时开启recursive(递归)、links、perms、times、owner、group、-D选项都为yes ，默认该项为开启</li><li>checksum: 跳过检测sum值，默认关闭</li><li>compress:是否开启压缩</li><li>copy_links：复制链接文件，默认为no ，注意后面还有一个links参数</li><li>delete: 删除不存在的文件，默认no</li><li>dest：目录路径</li><li>dest_port：默认目录主机上的端口 ，默认是22，走的ssh协议</li><li>dirs：传速目录不进行递归，默认为no，即进行目录递归</li><li>rsync_opts：rsync参数部分</li><li>set_remote_user：主要用于/etc/ansible/hosts中定义或默认使用的用户与rsync使用的用户不同的情况</li><li>mode: push或pull 模块，push模的话，一般用于从本机向远程主机上传文件，pull 模式用于从远程主机上取文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#############使用rsynchronize模块首先远程客户端要先按照rsync包才可以使用</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -a "yum install rsync -y"</span></span><br><span class="line">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">设置安装进程</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">解决依赖关系</span><br><span class="line">--&gt; 执行事务检查</span><br><span class="line">---&gt; Package rsync.x86_64 0:3.0.6-12.el6 will be 安装</span><br><span class="line">--&gt; 完成依赖关系计算</span><br><span class="line">依赖关系解决</span><br><span class="line">================================================================================</span><br><span class="line"> 软件包          架构             版本                     仓库            大小</span><br><span class="line">================================================================================</span><br><span class="line">正在安装:</span><br><span class="line"> rsync           x86_64           3.0.6-12.el6             base           335 k</span><br><span class="line">事务概要</span><br><span class="line">================================================================================</span><br><span class="line">Install       1 Package(s)</span><br><span class="line">总下载量：335 k</span><br><span class="line">Installed size: 682 k</span><br><span class="line">下载软件包：</span><br><span class="line">运行 rpm_check_debug </span><br><span class="line">执行事务测试</span><br><span class="line">事务测试成功</span><br><span class="line">执行事务</span><br><span class="line">  正在安装   : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">  Verifying  : rsync-3.0.6-12.el6.x86_64                                    1/1 </span><br><span class="line">已安装:</span><br><span class="line">  rsync.x86_64 0:3.0.6-12.el6                                                   </span><br><span class="line">完毕！</span><br><span class="line"></span><br><span class="line"><span class="comment">############远程客户端安装好rsync包后就可以在ansible服务端使用rsync进行同步了</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m synchronize -a 'src=/etc/ansib</span></span><br><span class="line">le/conf/hosts dest=/tmp/ <span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "cmd": "/usr/bin/rsync --delay-updates -F --compress --archive --rsh '</span>ssh -i /root/.ssh/id_rsa_web -S none -o StrictHostKeyChecking=no -o Port=22<span class="string">' --out-format='</span>&lt;&lt;CHANGED&gt;&gt;%i %n%L<span class="string">' \"/etc/ansible/conf/hosts\" \"root@192.168.180.6:/tmp/\"", </span></span><br><span class="line"><span class="string">    "msg": "&lt;f+++++++++ hosts\n", </span></span><br><span class="line"><span class="string">    "rc": 0, </span></span><br><span class="line"><span class="string">    "stdout_lines": [</span></span><br><span class="line"><span class="string">        "&lt;f+++++++++ hosts"</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>12.mount模块。主要配置挂载点的。主要的参数如下：</p><ul><li>dump</li><li>fstype：必选项，挂载文件的类型 </li><li>name：必选项，挂载点 </li><li>opts：传递给mount命令的参数</li><li>src：必选项，要挂载的文件 </li><li>state：必选项 </li><li>present：只处理fstab中的配置 </li><li>absent：删除挂载点 </li><li>mounted：自动创建挂载点并挂载之 </li><li>umounted：卸载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###############把本地的磁盘挂载到远程主机180.6上</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m mount -a 'name=/tmp/app src=/d</span></span><br><span class="line">ev/sda2 fstype=ext4 state=mounted opts=rw<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "changed": true, </span></span><br><span class="line"><span class="string">    "dump": "0", </span></span><br><span class="line"><span class="string">    "fstab": "/etc/fstab", </span></span><br><span class="line"><span class="string">    "fstype": "ext4", </span></span><br><span class="line"><span class="string">    "name": "/tmp/app", </span></span><br><span class="line"><span class="string">    "opts": "rw", </span></span><br><span class="line"><span class="string">    "passno": "0", </span></span><br><span class="line"><span class="string">    "src": "/dev/sda2"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#############下面是查看远程主机是否挂载成功</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>cat /etc/fstab<span class="string">'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># /etc/fstab</span></span><br><span class="line"><span class="string"># Created by anaconda on Wed Jan 18 14:50:09 2017</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Accessible filesystems, by reference, are maintained under '</span>/dev/disk<span class="string">'</span></span><br><span class="line"><span class="string"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">UUID=942820c4-9134-41da-9271-78ad0f8a33b2 /                       ext4    defaults        1 1</span></span><br><span class="line"><span class="string">UUID=e5d84663-09d2-429f-9f90-43a37b1a84a7 /opt                    ext4    defaults        1 2</span></span><br><span class="line"><span class="string">UUID=e9098124-206a-4116-a580-91d1d46fe8a9 swap                    swap    defaults        0 0</span></span><br><span class="line"><span class="string">tmpfs                   /dev/shm                tmpfs   defaults        0 0</span></span><br><span class="line"><span class="string">devpts                  /dev/pts                devpts  gid=5,mode=620  0 0</span></span><br><span class="line"><span class="string">sysfs                   /sys                    sysfs   defaults        0 0</span></span><br><span class="line"><span class="string">proc                    /proc                   proc    defaults        0 0</span></span><br><span class="line"><span class="string">/dev/sda2 /tmp/app ext4 rw 0 0</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a '</span>df -h<span class="string">'         </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">Filesystem      Size  Used Avail Use% Mounted on</span></span><br><span class="line"><span class="string">/dev/sda1        87G   12G   71G  14% /</span></span><br><span class="line"><span class="string">tmpfs           935M     0  935M   0% /dev/shm</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /opt</span></span><br><span class="line"><span class="string">/dev/sda2       9.9G  1.4G  8.1G  15% /tmp/app</span></span><br></pre></td></tr></table></figure><p>13.get_url模块。该模块主要用于从http，ftp ,https等服务器上下载文件类似于wget。主要选项如下：</p><ul><li>sha256sum：下载完成后进行sha256 check；</li><li>timeout：下载超时时间，默认10s</li><li>url：下载的URL</li><li>url_password、url_username：主要用于需要用户名密码进行验证的情况</li><li>use_proxy：是事使用代理，代理需事先在环境变更中定义</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##################从网站下载页面到/tmp/下</span></span><br><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m get_url -a "url=http://www.guo</span></span><br><span class="line">jinbao.com dest=/tmp/guojinbao mode=0440 force=yes<span class="string">"    </span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>checksum_dest<span class="string">": null, </span></span><br><span class="line"><span class="string">    "</span>checksum_src<span class="string">": "</span>75fa271ea83d05f2817027cf4009f9e9fda7ef88<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/guojinbao<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>md5sum<span class="string">": "</span>e9ea1af241cf68289f3286b99af24baa<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>0440<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>msg<span class="string">": "</span>OK (unknown bytes)<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 38033, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/tmp/tmp47gp_m<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>file<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>url<span class="string">": "</span>http://www.guojinbao.com<span class="string">"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########远程查看下载目录下有没有刚才下载的文件</span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -lh /tmp/'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 104K</span></span><br><span class="line"><span class="string">drwx------  2 root    root    4.0K 9月   5 16:01 ansible_zwKwyh</span></span><br><span class="line"><span class="string">drwxr-xr-x. 7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--  1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">-r--r-----  1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x. 3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x  1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------. 1 root    root       0 1月  18 2017 yum.log</span></span><br></pre></td></tr></table></figure><p>14.sysctl包管理模块。用于远程主机sysctl的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible-doc -s sysctl        ###########查看sysctl的使用说明</span></span><br><span class="line">- name: Manage entries <span class="keyword">in</span> sysctl.conf.</span><br><span class="line">  action: sysctl</span><br><span class="line">      ignoreerrors           <span class="comment"># Use this option to ignore errors about unknown</span></span><br><span class="line">                               keys.</span><br><span class="line">      name=                  <span class="comment"># The dot-separated path (aka `key') specifying the                               sysctl variable.</span></span><br><span class="line">      reload                 <span class="comment"># If `yes', performs a `/sbin/sysctl -p' if the</span></span><br><span class="line">                               `sysctl_file<span class="string">' is</span></span><br><span class="line"><span class="string">                               updated. If `no'</span>,</span><br><span class="line">                               does not reload</span><br><span class="line">                               `sysctl<span class="string">' even if</span></span><br><span class="line"><span class="string">                               the `sysctl_file'</span></span><br><span class="line">                               is updated.</span><br><span class="line">      state                  <span class="comment"># Whether the entry should be present or absent in</span></span><br><span class="line">                               the sysctl file.</span><br><span class="line">      sysctl_file            <span class="comment"># Specifies the absolute path to `sysctl.conf', if</span></span><br><span class="line">                               not `/etc/sysctl.c</span><br><span class="line">                               onf<span class="string">'.</span></span><br><span class="line"><span class="string">      sysctl_set             # Verify token value with the sysctl command and</span></span><br><span class="line"><span class="string">                               set with -w if</span></span><br><span class="line"><span class="string">                               necessary</span></span><br><span class="line"><span class="string">      value                  # Desired value of the sysctl key.</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m sysctl -a "name=kernel.panic v</span></span><br><span class="line">alue=3 sysctl_file=/etc/sysctl.conf<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>15.unarchive模块。功能：解压缩，这个模块有两种用法：</p><p>1、将ansible主机上的压缩包在本地解压缩后传到远程主机上，这种情况下，copy=yes</p><p>2、将远程主机上的某个压缩包解压缩到指定路径下。这种情况下，需要设置copy=no</p><p>具体吃的参数如下：</p><ul><li>copy：在解压文件之前，是否先将文件复制到远程主机，默认为yes。若为no，则要求目标主机上压缩包必须存在。</li><li>creates：指定一个文件名，当该文件存在时，则解压指令不执行</li><li>dest：远程主机上的一个路径，即文件解压的路径 </li><li>grop：解压后的目录或文件的属组</li><li>list_files：如果为yes，则会列出压缩包里的文件，默认为no，2.0版本新增的选项</li><li>mode：解决后文件的权限</li><li>src：如果copy为yes，则需要指定压缩文件的源路径 </li><li>owner：解压后文件或目录的属主</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@Monitor ansible]<span class="comment"># ansible 192.168.180.6 -m unarchive -a "src=/tmp/install</span></span><br><span class="line">/zabbix-3.0.4.tar.gz dest=/tmp/ mode=0755<span class="string">"</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS =&gt; &#123;</span></span><br><span class="line"><span class="string">    "</span>changed<span class="string">": true, </span></span><br><span class="line"><span class="string">    "</span>dest<span class="string">": "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>extract_results<span class="string">": &#123;</span></span><br><span class="line"><span class="string">        "</span>cmd<span class="string">": [</span></span><br><span class="line"><span class="string">            "</span>/bin/gtar<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>--extract<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-C<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/tmp/<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-z<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>-f<span class="string">", </span></span><br><span class="line"><span class="string">            "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">"</span></span><br><span class="line"><span class="string">        ], </span></span><br><span class="line"><span class="string">        "</span>err<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>out<span class="string">": "</span><span class="string">", </span></span><br><span class="line"><span class="string">        "</span>rc<span class="string">": 0</span></span><br><span class="line"><span class="string">    &#125;, </span></span><br><span class="line"><span class="string">    "</span>gid<span class="string">": 0, </span></span><br><span class="line"><span class="string">    "</span>group<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>handler<span class="string">": "</span>TgzArchive<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>mode<span class="string">": "</span>01777<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>owner<span class="string">": "</span>root<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>size<span class="string">": 4096, </span></span><br><span class="line"><span class="string">    "</span>src<span class="string">": "</span>/root/.ansible/tmp/ansible-tmp-1504599995.75-84735087578916/<span class="built_in">source</span><span class="string">", </span></span><br><span class="line"><span class="string">    "</span>state<span class="string">": "</span>directory<span class="string">", </span></span><br><span class="line"><span class="string">    "</span>uid<span class="string">": 0</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">########下面是查看路径下的zabbix解压包</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@Monitor ansible]# ansible 192.168.180.6 -a 'ls -alh /tmp'</span></span><br><span class="line"><span class="string">192.168.180.6 | SUCCESS | rc=0 &gt;&gt;</span></span><br><span class="line"><span class="string">总用量 120K</span></span><br><span class="line"><span class="string">drwxrwxrwt.  7 root    root    4.0K 9月   5 16:28 .</span></span><br><span class="line"><span class="string">dr-xr-xr-x. 24 root    root    4.0K 9月   1 09:45 ..</span></span><br><span class="line"><span class="string">drwx------   2 root    root    4.0K 9月   5 16:28 ansible_1zOyd2</span></span><br><span class="line"><span class="string">drwxr-xr-x.  7 appuser appuser 4.0K 1月  19 2017 app</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 16:01 guojinbao</span></span><br><span class="line"><span class="string">-rw-r--r--   1 root    root    1.5K 9月   4 14:25 hosts</span></span><br><span class="line"><span class="string">drwxrwxrwt   2 root    root    4.0K 9月   1 09:45 .ICE-unix</span></span><br><span class="line"><span class="string">-r--r-----   1 root    root     38K 9月   5 15:59 index.html</span></span><br><span class="line"><span class="string">drwxr-xr-x.  3 root    root    4.0K 9月   5 15:17 install</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 appuser appuser   30 9月   4 17:32 script.sh</span></span><br><span class="line"><span class="string">-rwxr-xr-x   1 root    root      26 9月   4 15:52 test.sh</span></span><br><span class="line"><span class="string">-rw-------.  1 root    root       0 1月  18 2017 yum.log</span></span><br><span class="line"><span class="string">drwxr-xr-x  13 www        1000 4.0K 7月  22 2016 zabbix-3.0.4</span></span><br></pre></td></tr></table></figure><p><strong>总之，以上就是ansible常用的模块，如果还需要其他的模块的话可以查看下官方文档（**</strong><a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/list_of_all_modules.html）*</a>* <a href="http://docs.ansible.com/ansible/latest/list_of_all_modules.html%EF%BC%89%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener"><strong>也可以通过命令来进行查看</strong></a></p><p><strong>1，查看所有的模块命令： ansible-doc  -l</strong></p><p><strong>2，查看具体某个模块用法：ansible-doc -s MODULE_NAME</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ansible模块按功能分为：云模块、集群模块、 命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、windows模块 具体的可以参考官网（&lt;a href=&quot;http://docs
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://blog.ozairs.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>三个技巧将Docker镜像体积压缩90%</title>
    <link href="http://blog.ozairs.com/Docker/%E4%B8%89%E4%B8%AA%E6%8A%80%E5%B7%A7%E5%B0%86Docker%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A990/"/>
    <id>http://blog.ozairs.com/Docker/三个技巧将Docker镜像体积压缩90/</id>
    <published>2019-03-16T05:44:57.000Z</published>
    <updated>2019-03-16T05:52:11.404Z</updated>
    
    <content type="html"><![CDATA[<p>在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。</p><p>但<code>RUN</code>语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？</p><p>你可能已经注意到了，大多数 Dockerfiles 都使用了一些奇怪的技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install vim</span><br></pre></td></tr></table></figure><p>为什么使用 &amp;&amp;？而不是使用两个 RUN 语句代替呢？比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>从 Docker 1.10 开始，<code>COPY</code>、<code>ADD</code>和<code>RUN</code>语句会向镜像中添加新层。前面的示例创建了两个层而不是一个。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/1.gif" alt=""></p><p>镜像的层就像 Git 的提交（commit）一样。</p><p>Docker 的层用于保存镜像的上一版本和当前版本之间的差异。就像 Git 的提交一样，如果你与其他存储库或镜像共享它们，就会很方便。</p><p>实际上，当你向注册表请求镜像时，只是下载你尚未拥有的层。这是一种非常高效地共享镜像的方式。</p><p>但额外的层并不是没有代价的。</p><p>层仍然会占用空间，你拥有的层越多，最终的镜像就越大。Git 存储库在这方面也是类似的，存储库的大小随着层数的增加而增加，因为 Git 必须保存提交之间的所有变更。</p><p>过去，将多个<code>RUN</code>语句组合在一行命令中或许是一种很好的做法，就像上面的第一个例子那样，但在现在看来，这样做并不妥。</p><p>通过Docker 多阶段构建将多个层压缩为一个</p><p>当 Git 存储库变大时，你可以选择将历史提交记录压缩为单个提交。</p><p>事实证明，在 Docker 中也可以使用多阶段构建达到类似的目的。</p><p>在这个示例中，你将构建一个 Node.js 容器。</p><p>让我们从 index.js 开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const app = express()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;Hello World!&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  console.log(`Example app listening on port 3000!`)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和 package.json：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;name&quot;: &quot;hello-world&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;express&quot;: &quot;^4.16.2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &quot;start&quot;: &quot;node index.js&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用下面的 Dockerfile 来打包这个应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">FROM node:10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MAINTAINER xialeistudio xialeistudio@gmail.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ARG disturl=https://npm.taobao.org/dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set disturl $disturl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn config set registry $registry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN yarn --frozen-lockfile --production</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY . /usr/src/app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [ &quot;yarn&quot;, &quot;start:prod&quot; ]</span><br></pre></td></tr></table></figure><p>然后开始构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-vanilla .</span><br></pre></td></tr></table></figure><p>然后用以下方法验证它是否可以正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-vanilla</span><br></pre></td></tr></table></figure><p>你应该能访问 <a href="http://localhost:3000，并收到“Hello" target="_blank" rel="noopener">http://localhost:3000，并收到“Hello</a> World!”。</p><p>Dockerfile 中使用了一个 COPY 语句和一个 RUN 语句，所以按照预期，新镜像应该比基础镜像多出至少两个层：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-vanilla</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">075d229d3f48   /bin/sh -c #(nop)  CMD [&quot;npm&quot; &quot;start&quot;]          0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bc8c3cc813ae   /bin/sh -c npm install                          2.91MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bac31afb6f42   /bin/sh -c #(nop) COPY multi:3071ddd474429e1…   364B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">500a9fbef90e   /bin/sh -c #(nop) WORKDIR /app                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">78b28027dfbf   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>但实际上，生成的镜像多了五个新层：每一个层对应 Dockerfile 里的一个语句。</p><p>现在，让我们来试试 Docker 的多阶段构建。</p><p>你可以继续使用与上面相同的 Dockerfile，只是现在要调用两次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>Dockerfile 的第一部分创建了三个层，然后这些层被合并并复制到第二个阶段。在第二阶段，镜像顶部又添加了额外的两个层，所以总共是三个层。</p><p><img src="/Docker/三个技巧将Docker镜像体积压缩90/2.gif" alt=""></p><p>现在来验证一下。首先，构建容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-multi-stage .</span><br></pre></td></tr></table></figure><p>查看镜像的历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ docker history node-multi-stage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE          CREATED BY                                      SIZE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">331b81a245b1   /bin/sh -c #(nop)  CMD [&quot;index.js&quot;]             0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bdfc932314af   /bin/sh -c #(nop)  EXPOSE 3000                  0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f8992f6c62a6   /bin/sh -c #(nop) COPY dir:e2b57dff89be62f77…   1.62MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b87c2ad8344d   /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.17MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV YARN_VERSION=1.3.2       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   56.9MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  ENV NODE_VERSION=8.9.4       0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   129kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  apt-get update;  apt-ge…   324MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c apt-get update &amp;&amp; apt-get install…   44.6MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;missing&gt;      /bin/sh -c #(nop) ADD file:1dd78a123212328bd…   123MB</span><br></pre></td></tr></table></figure><p>文件大小是否已发生改变？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-multi-stage   331b81a245b1   678MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-vanilla       075d229d3f48   679MB</span><br></pre></td></tr></table></figure><p>最后一个镜像（node-multi-stage）更小一些。</p><p>你已经将镜像的体积减小了，即使它已经是一个很小的应用程序。</p><p>但整个镜像仍然很大！</p><p>有什么办法可以让它变得更小吗？</p><p>用 distroless 去除不必要的东西</p><p>这个镜像包含了 Node.js 以及 yarn、npm、bash 和其他的二进制文件。因为它也是基于 Ubuntu 的，所以你等于拥有了一个完整的操作系统，其中包括所有的小型二进制文件和实用程序。</p><p>但在运行容器时是不需要这些东西的，你需要的只是 Node.js。</p><p>Docker 容器应该只包含一个进程以及用于运行这个进程所需的最少的文件，你不需要整个操作系统。</p><p>实际上，你可以删除 Node.js 之外的所有内容。</p><p>但要怎么做？</p><p>所幸的是，<a href="https://www.baidu.com/s?wd=%E8%B0%B7%E6%AD%8C&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">谷歌</a>为我们提供了 distroless（<a href="https://github.com/GoogleCloudPlatform/distroless）。" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/distroless）。</a></p><p>以下是 distroless 存储库的描述：</p><blockquote><p>“distroless”镜像只包含应用程序及其运行时依赖项，不包含程序包管理器、shell 以及在标准 Linux 发行版中可以找到的任何其他程序。</p></blockquote><p>这正是你所需要的！</p><p>你可以对 Dockerfile 进行调整，以利用新的基础镜像，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM gcr.io/distroless/nodejs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;index.js&quot;]</span><br></pre></td></tr></table></figure><p>你可以像往常一样编译镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-distroless .</span><br></pre></td></tr></table></figure><p>这个镜像应该能正常运行。要验证它，可以像这样运行容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-distroless</span><br></pre></td></tr></table></figure><p>s现在可以访问 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 页面。</p><p>不包含其他额外二进制文件的镜像是不是小多了？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-distroless</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-distroless   7b4db3b7f1e5   76.7MB</span><br></pre></td></tr></table></figure><p>只有 76.7MB！</p><p>比之前的镜像小了 600MB！</p><p>但在使用 distroless 时有一些事项需要注意。</p><p>当容器在运行时，如果你想要检查它，可以使用以下命令 attach 到正在运行的容器上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; bash</span><br></pre></td></tr></table></figure><p>attach 到正在运行的容器并运行 bash 命令就像是建立了一个 SSH 会话一样。</p><p>但 distroless 版本是原始操作系统的精简版，没有了额外的二进制文件，所以容器里没有 shell！</p><p>在没有 shell 的情况下，如何 attach 到正在运行的容器呢？</p><p>答案是，你做不到。这既是个坏消息，也是个好消息。</p><p>之所以说是坏消息，因为你只能在容器中执行二进制文件。你可以运行的唯一的二进制文件是 Node.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti &lt;insert_docker_id&gt; node</span><br></pre></td></tr></table></figure><p>说它是个好消息，是因为如果攻击者利用你的应用程序获得对容器的访问权限将无法像访问 shell 那样造成太多破坏。换句话说，更少的二进制文件意味着更小的体积和更高的安全性，不过这是以痛苦的调试为代价的。</p><blockquote><p>或许你不应在生产环境中 attach 和调试容器，而应该使用日志和监控。</p></blockquote><p>但如果你确实需要调试，又想保持小体积该怎么办？</p><p>小体积的 Alpine 基础镜像</p><p>你可以使用 Alpine 基础镜像替换 distroless 基础镜像。</p><p>Alpine Linux 是：</p><blockquote><p>一个基于 musl libc 和 <a href="https://www.baidu.com/s?wd=busybox&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">busybox</a> 的面向安全的轻量级 Linux 发行版。</p></blockquote><p>换句话说，它是一个体积更小也更安全的 Linux 发行版。</p><p>不过你不应该<a href="https://www.baidu.com/s?wd=%E7%90%86%E6%89%80%E5%BD%93%E7%84%B6&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">理所当然</a>地认为他们声称的就一定是事实，让我们来看看它的镜像是否更小。</p><p>先修改 Dockerfile，让它使用 node:8-alpine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8 as build</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY package.json index.js ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FROM node:8-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COPY --from=build /app /</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><p>使用下面的命令构建镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t node-alpine .</span><br></pre></td></tr></table></figure><p>现在可以检查一下镜像大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker images | grep node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">node-alpine   aa1f85f8e724   69.7MB</span><br></pre></td></tr></table></figure><p>69.7MB！</p><p>甚至比 distrless 镜像还小！</p><p>现在可以 attach 到正在运行的容器吗？让我们来试试。</p><p>让我们先启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 3000:3000 -ti --rm --init node-alpine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example app listening on port 3000!</span><br></pre></td></tr></table></figure><p>你可以使用以下命令 attach 到运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OCI runtime exec failed: exec failed: container_linux.go:296: starting container process caused &quot;exec: \&quot;bash\&quot;: executable file not found in $PATH&quot;: unknown</span><br></pre></td></tr></table></figure><p>看来不行，但或许可以使用 shell？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -ti 9d8e97e307d7 sh / #</span><br></pre></td></tr></table></figure><p>成功了！现在可以 attach 到正在运行的容器中了。</p><p>看起来很有希望，但还有一个问题。</p><p>Alpine 基础镜像是基于 muslc 的——C 语言的一个替代标准库，而大多数 Linux 发行版如 Ubuntu、Debian 和 CentOS 都是基于 glibc 的。这两个库应该实现相同的内核接口。</p><p>但它们的目的是不一样的：</p><ul><li>glibc 更常见，速度也更快；</li><li>muslc 使用较少的空间，并侧重于安全性。</li></ul><p>在编译应用程序时，大部分都是针对特定的 libc 进行编译的。如果你要将它们与另一个 libc 一起使用，则必须重新编译它们。</p><p>换句话说，基于 Alpine 基础镜像构建容器可能会导致非预期的行为，因为标准 C 库是不一样的。</p><p>你可能会注意到差异，特别是当你处理预编译的二进制文件（如 Node.js C++ 扩展）时。</p><p>例如，PhantomJS 的预构建包就不能在 Alpine 上运行。</p><p>你应该选择哪个基础镜像？</p><p>你应该使用 Alpine、distroless 还是原始镜像？</p><p>如果你是在生产环境中运行容器，并且更关心安全性，那么可能 distroless 镜像更合适。</p><p>添加到 Docker 镜像的每个二进制文件都会给整个应用程序增加一定的风险。</p><p>只在容器中安装一个二进制文件可以降低总体风险。</p><p>例如，如果攻击者能够利用运行在 distroless 上的应用程序的漏洞，他们将无法在容器中使用 shell，因为那里根本就没有 shell！</p><blockquote><p>请注意，OWASP 本身就建议尽量减少攻击表面。</p></blockquote><p>如果你只关心更小的镜像体积，那么可以考虑基于 Alpine 的镜像。</p><p>它们的体积非常小，但代价是兼容性较差。Alpine 使用了略微不同的标准 C 库——muslc。你可能会时不时地遇到一些兼容性问题。</p><p>原始基础镜像非常适合用于测试和开发。</p><p>它虽然体积很大，但提供了与 Ubuntu 工作站一样的体验。此外，你还可以访问操作系统的所有二进制文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在构建 Docker 容器时，应该尽量想办法获得体积更小的镜像，因为传输和部署体积较小的镜像速度更快。&lt;/p&gt;
&lt;p&gt;但&lt;code&gt;RUN&lt;/code&gt;语句总是会创建一个新层，而且在生成镜像之前还需要使用很多中间文件，在这种情况下，该如何获得体积更小的镜像呢？&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>如何编写最佳的Dockerfile</title>
    <link href="http://blog.ozairs.com/Docker/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%9C%80%E4%BD%B3%E7%9A%84Dockerfile/"/>
    <id>http://blog.ozairs.com/Docker/如何编写最佳的Dockerfile/</id>
    <published>2019-03-16T05:28:24.000Z</published>
    <updated>2019-03-16T05:29:37.407Z</updated>
    
    <content type="html"><![CDATA[<p><strong>为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习</strong>。</p><p>我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的Dockerfile。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul><li>更快的构建速度</li><li>更小的Docker镜像大小</li><li>更少的Docker镜像层</li><li>充分利用镜像缓存</li><li>增加Dockerfile可读性</li><li>让Docker容器使用起来更简单</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>编写.dockerignore文件</li><li>容器只运行单个应用</li><li>将多个RUN指令合并为一个</li><li>基础镜像的标签不要用latest</li><li>每个RUN指令后删除多余文件</li><li>选择合适的基础镜像(alpine版本最好)</li><li>设置WORKDIR和CMD</li><li>使用ENTRYPOINT (可选)</li><li>在entrypoint脚本中使用exec</li><li>COPY与ADD优先使用前者</li><li>合理调整COPY与RUN的顺序</li><li>设置默认的环境变量，映射端口和数据卷</li><li>使用LABEL设置镜像元数据</li><li>添加HEALTHCHECK</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>示例Dockerfile犯了几乎所有的错(当然我是故意的)。接下来，我会一步步优化它。假设我们需要使用Docker运行一个Node.js应用，下面就是它的Dockerfile(CMD指令太复杂了，所以我简化了，它是错误的，仅供参考)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y  </span><br><span class="line">RUN apt-get install -y nodejs ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line"># this should start three processes, mysql and ssh</span><br><span class="line"># in the background and node app in foreground</span><br><span class="line"># isn&apos;t it beautifully terrible? &lt;3</span><br><span class="line">CMD mysql &amp; sshd &amp; npm start</span><br></pre></td></tr></table></figure><p>构建镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t wtf .</span><br></pre></td></tr></table></figure><h3 id="1-编写-dockerignore文件"><a href="#1-编写-dockerignore文件" class="headerlink" title="1. 编写.dockerignore文件"></a>1. 编写.dockerignore文件</h3><p>构建镜像时，Docker需要先准备<code>context</code> ，将所有需要的文件收集到进程中。默认的<code>context</code>包含Dockerfile目录中的所有文件，但是实际上，<strong>我们并不需要.git目录，node_modules目录等内容</strong>。 <code>.dockerignore</code> 的作用和语法类似于 <code>.gitignore</code>，可以忽略一些不需要的文件，这样可以有效加快镜像构建时间，同时减少Docker镜像的大小。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.git/</span><br><span class="line">node_modules/</span><br></pre></td></tr></table></figure><h3 id="2-容器只运行单个应用"><a href="#2-容器只运行单个应用" class="headerlink" title="2. 容器只运行单个应用"></a>2. 容器只运行单个应用</h3><p>从技术角度讲，你可以在Docker容器中运行多个进程。你可以将数据库，前端，后端，ssh，supervisor都运行在同一个Docker容器中。但是，这会让你非常痛苦:</p><ul><li>非常长的构建时间(修改前端之后，整个后端也需要重新构建)</li><li>非常大的镜像大小</li><li>多个应用的日志难以处理(不能直接使用stdout，否则多个应用的日志会混合到一起)</li><li>横向扩展时非常浪费资源(不同的应用需要运行的容器数并不相同)</li><li>僵尸进程问题 - 你需要选择合适的init进程</li></ul><p>因此，我建议大家为每个应用构建单独的Docker镜像，然后使用 <a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a> 运行多个Docker容器。</p><p>现在，我从Dockerfile中删除一些不需要的安装包，另外，SSH可以用<a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank" rel="noopener">docker exec</a>替代。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update  </span><br><span class="line">RUN apt-get upgrade -y</span><br><span class="line"></span><br><span class="line"># we should remove ssh and mysql, and use</span><br><span class="line"># separate container for database </span><br><span class="line">RUN apt-get install -y nodejs  # ssh mysql  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="3-将多个RUN指令合并为一个"><a href="#3-将多个RUN指令合并为一个" class="headerlink" title="3. 将多个RUN指令合并为一个"></a>3. 将多个RUN指令合并为一个</h3><p>Docker镜像是分层的，下面这些知识点非常重要:</p><ul><li>Dockerfile中的每个指令都会创建一个新的镜像层。</li><li>镜像层将被缓存和复用</li><li>当Dockerfile的指令修改了，复制的文件变化了，或者构建镜像时指定的变量不同了，对应的镜像层缓存就会失效</li><li>某一层的镜像缓存失效之后，它之后的镜像层缓存都会失效</li><li>镜像层是不可变的，如果我们再某一层中添加一个文件，然后在下一层中删除它，则镜像中依然会包含该文件(只是这个文件在Docker容器中不可见了)。</li></ul><p>Docker镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。记住这一点的话，其他内容就很好理解了。</p><p>现在，我们<strong>将所有的RUN指令合并为一个</strong>。同时把<code>apt-get upgrade</code>删除，因为它会使得镜像构建非常不确定(我们只需要依赖基础镜像的更新就好了)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">ADD . /app</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    &amp;&amp; cd /app \</span><br><span class="line">    &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>记住一点，我们只能将变化频率一样的指令合并在一起。将node.js安装与npm模块安装放在一起的话，则每次修改源代码，都需要重新安装node.js，这显然不合适。因此，正确的写法是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="4-基础镜像的标签不要用latest"><a href="#4-基础镜像的标签不要用latest" class="headerlink" title="4. 基础镜像的标签不要用latest"></a>4. 基础镜像的标签不要用latest</h3><p>当镜像没有指定标签时，将默认使用<code>latest</code> 标签。因此， <code>FROM ubuntu</code> 指令等同于<code>FROM ubuntu:latest</code>。当时，当镜像更新时，latest标签会指向不同的镜像，这时构建镜像有可能失败。如果你的确需要使用最新版的基础镜像，可以使用latest标签，否则的话，最好指定确定的镜像标签。</p><p>示例Dockerfile应该使用<code>16.04</code>作为标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04  # it&apos;s that easy!</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nodejs  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="5-每个RUN指令后删除多余文件"><a href="#5-每个RUN指令后删除多余文件" class="headerlink" title="5. 每个RUN指令后删除多余文件"></a>5. 每个RUN指令后删除多余文件</h3><p>假设我们更新了apt-get源，下载，解压并安装了一些软件包，它们都保存在<code>/var/lib/apt/lists/</code>目录中。但是，运行应用时Docker镜像中并不需要这些文件。我们最好将它们删除，因为它会使Docker镜像变大。</p><p>示例Dockerfile中，我们可以删除<code>/var/lib/apt/lists/</code>目录中的文件(它们是由apt-get update生成的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update \  </span><br><span class="line">    &amp;&amp; apt-get install -y nodejs \</span><br><span class="line">    # added lines</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><h3 id="6-选择合适的基础镜像-alpine版本最好"><a href="#6-选择合适的基础镜像-alpine版本最好" class="headerlink" title="6. 选择合适的基础镜像(alpine版本最好)"></a>6. 选择合适的基础镜像(alpine版本最好)</h3><p>在示例中，我们选择了<code>ubuntu</code>作为基础镜像。但是我们只需要运行node程序，有必要使用一个通用的基础镜像吗？<code>node</code>镜像应该是更好的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line"># we don&apos;t need to install node </span><br><span class="line"># anymore and use apt-get</span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p>更好的选择是alpine版本的<code>node</code>镜像。alpine是一个极小化的Linux发行版，只有4MB，这让它非常适合作为基础镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ADD . /app  </span><br><span class="line">RUN cd /app &amp;&amp; npm install</span><br><span class="line"></span><br><span class="line">CMD npm start</span><br></pre></td></tr></table></figure><p><a href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management" target="_blank" rel="noopener">apk</a>是Alpine的包管理工具。它与<code>apt-get</code>有些不同，但是非常容易上手。另外，它还有一些非常有用的特性，比如<code>no-cache</code>和 <code>--virtual</code>选项，它们都可以帮助我们减少镜像的大小。</p><h3 id="7-设置WORKDIR和-CMD"><a href="#7-设置WORKDIR和-CMD" class="headerlink" title="7. 设置WORKDIR和 CMD"></a>7. 设置WORKDIR和 CMD</h3><p><a href="https://docs.docker.com/engine/reference/builder/#workdir" target="_blank" rel="noopener">WORKDIR</a>指令可以设置默认目录，也就是运行<code>RUN</code> / <code>CMD</code> / <code>ENTRYPOINT</code>指令的地方。</p><p><a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">CMD</a>指令可以设置容器创建是执行的默认命令。另外，你应该讲命令写在一个数组中，数组中每个元素为命令的每个单词(参考<a href="https://docs.docker.com/engine/reference/builder/#cmd" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">CMD [&quot;npm&quot;, &quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="8-使用ENTRYPOINT-可选"><a href="#8-使用ENTRYPOINT-可选" class="headerlink" title="8. 使用ENTRYPOINT (可选)"></a>8. 使用ENTRYPOINT (可选)</h3><p><a href="https://docs.docker.com/engine/reference/builder/#entrypoint" target="_blank" rel="noopener">ENTRYPOINT</a>指令并不是必须的，因为它会增加复杂度。<code>ENTRYPOINT</code>是一个脚本，它会默认执行，并且将指定的命令错误其参数。它通常用于构建可执行的Docker镜像。entrypoint.sh如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env sh</span><br><span class="line"># $0 is a script name, </span><br><span class="line"># $1, $2, $3 etc are passed arguments</span><br><span class="line"># $1 is our command</span><br><span class="line">CMD=$1</span><br><span class="line"></span><br><span class="line">case &quot;$CMD&quot; in  </span><br><span class="line">  &quot;dev&quot; )</span><br><span class="line">    npm install</span><br><span class="line">    export NODE_ENV=development</span><br><span class="line">    exec npm run dev</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  &quot;start&quot; )</span><br><span class="line">    # we can modify files here, using ENV variables passed in </span><br><span class="line">    # &quot;docker create&quot; command. It can&apos;t be done during build process.</span><br><span class="line">    echo &quot;db: $DATABASE_ADDRESS&quot; &gt;&gt; /app/config.yml</span><br><span class="line">    export NODE_ENV=production</span><br><span class="line">    exec npm start</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">   * )</span><br><span class="line">    # Run custom command. Thanks to this line we can still use </span><br><span class="line">    # &quot;docker run our_image /bin/bash&quot; and it will work</span><br><span class="line">    exec $CMD $&#123;@:2&#125;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>示例Dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app  </span><br><span class="line">ADD . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>可以使用如下命令运行该镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 运行开发版本</span><br><span class="line">docker run our-app dev </span><br><span class="line"></span><br><span class="line"># 运行生产版本</span><br><span class="line">docker run our-app start </span><br><span class="line"></span><br><span class="line"># 运行bash</span><br><span class="line">docker run -it our-app /bin/bash</span><br></pre></td></tr></table></figure><h3 id="9-在entrypoint脚本中使用exec"><a href="#9-在entrypoint脚本中使用exec" class="headerlink" title="9. 在entrypoint脚本中使用exec"></a>9. 在entrypoint脚本中使用exec</h3><p>在前文的entrypoint脚本中，我使用了<code>exec</code>命令运行node应用。不使用<code>exec</code>的话，我们则不能顺利地关闭容器，因为SIGTERM信号会被bash脚本进程吞没。<code>exec</code>命令启动的进程可以取代脚本进程，因此所有的信号都会正常工作。</p><h3 id="10-COPY与ADD优先使用前者"><a href="#10-COPY与ADD优先使用前者" class="headerlink" title="10. COPY与ADD优先使用前者"></a>10. COPY与ADD优先使用前者</h3><p><a href="https://docs.docker.com/engine/reference/builder/#copy" target="_blank" rel="noopener">COPY</a>指令非常简单，仅用于将文件拷贝到镜像中。<a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank" rel="noopener">ADD</a>相对来讲复杂一些，可以用于下载远程文件以及解压压缩包(参考<a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#add-or-copy" target="_blank" rel="noopener">官方文档</a>)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY . /app  </span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="11-合理调整COPY与RUN的顺序"><a href="#11-合理调整COPY与RUN的顺序" class="headerlink" title="11. 合理调整COPY与RUN的顺序"></a>11. 合理调整COPY与RUN的顺序</h3><p>我们应该<strong>把变化最少的部分放在Dockerfile的前面</strong>，这样可以充分利用镜像缓存。</p><p>示例中，源代码会经常变化，则每次构建镜像时都需要重新安装NPM模块，这显然不是我们希望看到的。因此我们可以先拷贝<code>package.json</code>，然后安装NPM模块，最后才拷贝其余的源代码。这样的话，即使源代码变化，也不需要重新安装NPM模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line">COPY package.json /app  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><h3 id="12-设置默认的环境变量，映射端口和数据卷"><a href="#12-设置默认的环境变量，映射端口和数据卷" class="headerlink" title="12. 设置默认的环境变量，映射端口和数据卷"></a>12. 设置默认的环境变量，映射端口和数据卷</h3><p>运行Docker容器时很可能需要一些环境变量。在Dockerfile设置默认的环境变量是一种很好的方式。另外，我们应该在Dockerfile中设置映射端口和数据卷。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app</span><br><span class="line"></span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/builder/#env" target="_blank" rel="noopener">ENV</a>指令指定的环境变量在容器中可以使用。如果你只是需要指定构建镜像时的变量，你可以使用<a href="https://docs.docker.com/engine/reference/builder/#arg" target="_blank" rel="noopener">ARG</a>指令。</p><h3 id="13-使用LABEL设置镜像元数据"><a href="#13-使用LABEL设置镜像元数据" class="headerlink" title="13. 使用LABEL设置镜像元数据"></a>13. 使用LABEL设置镜像元数据</h3><p>使用<a href="https://docs.docker.com/engine/reference/builder/#label" target="_blank" rel="noopener">LABEL</a>指令，可以为镜像设置元数据，例如<strong>镜像创建者</strong>或者<strong>镜像说明</strong>。旧版的Dockerfile语法使用<a href="https://docs.docker.com/engine/reference/builder/#maintainer-deprecated" target="_blank" rel="noopener">MAINTAINER</a>指令指定镜像创建者，但是它已经被弃用了。有时，一些外部程序需要用到镜像的元数据，例如<a href="https://github.com/NVIDIA/nvidia-docker" target="_blank" rel="noopener">nvidia-docker</a>需要用到<code>com.nvidia.volumes.needed</code>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="14-添加HEALTHCHECK"><a href="#14-添加HEALTHCHECK" class="headerlink" title="14. 添加HEALTHCHECK"></a>14. 添加HEALTHCHECK</h3><p>运行容器时，可以指定<code>--restart always</code>选项。这样的话，容器崩溃时，Docker守护进程(docker daemon)会重启容器。对于需要长时间运行的容器，这个选项非常有用。但是，如果容器的确在运行，但是不可(陷入死循环，配置错误)用怎么办？使用<a href="https://docs.docker.com/engine/reference/builder/#healthcheck" target="_blank" rel="noopener">HEALTHCHECK</a>指令可以让Docker周期性的检查容器的健康状况。我们只需要指定一个命令，如果一切正常的话返回0，否则返回1。对HEALTHCHECK感兴趣的话，可以参考<a href="https://blog.newrelic.com/2016/08/24/docker-health-check-instruction/" target="_blank" rel="noopener">这篇博客</a>。示例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM node:7-alpine  </span><br><span class="line">LABEL maintainer &quot;jakub.skalecki@example.com&quot;</span><br><span class="line"></span><br><span class="line">ENV PROJECT_DIR=/app  </span><br><span class="line">WORKDIR $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">COPY package.json $PROJECT_DIR  </span><br><span class="line">RUN npm install  </span><br><span class="line">COPY . $PROJECT_DIR</span><br><span class="line"></span><br><span class="line">ENV MEDIA_DIR=/media \  </span><br><span class="line">    NODE_ENV=production \</span><br><span class="line">    APP_PORT=3000</span><br><span class="line"></span><br><span class="line">VOLUME $MEDIA_DIR  </span><br><span class="line">EXPOSE $APP_PORT  </span><br><span class="line">HEALTHCHECK CMD curl --fail http://localhost:$APP_PORT || exit 1</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;./entrypoint.sh&quot;]  </span><br><span class="line">CMD [&quot;start&quot;]</span><br></pre></td></tr></table></figure><p>当请求失败时，<code>curl --fail</code> 命令返回非0状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;为了保证可读性，本文采用意译而非直译。另外，本文版权归原作者所有，翻译仅用于学习&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我已经使用Docker有一段时间了，其中编写Dockerfile是非常重要的一部分工作。在这篇博客中，我打算分享一些建议，帮助大家编写更好的D
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker三剑客之Docker Swarm</title>
    <link href="http://blog.ozairs.com/Docker/Docker%E4%B8%89%E5%89%91%E5%AE%A2%E4%B9%8BDocker-Swarm/"/>
    <id>http://blog.ozairs.com/Docker/Docker三剑客之Docker-Swarm/</id>
    <published>2019-03-16T04:03:40.000Z</published>
    <updated>2019-03-16T04:18:41.275Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Docker Machine 创建 Docker 主机</strong></li><li><strong>Docker Swarm 配置集群节点</strong></li><li><strong>Docker Service 部署单个集群服务</strong></li><li><strong>Docker Stack 部署多个集群服务，以及 GUI 管理页面</strong></li><li><strong>docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令</strong></li></ul><p><a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Docker Swarm</a> 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。</p><p>从 Docker 1.12.0 版本开始，Docker Swarm 已经包含在 Docker 引擎中（<code>docker swarm</code>），并且已经内置了服务发现工具，我们就不需要像之前一样，再配置 Etcd 或者 <a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-consul-docker-swarm/index.html" target="_blank" rel="noopener">Consul</a> 来进行服务发现配置了。</p><h2 id="1-Docker-Machine-创建-Docker-主机"><a href="#1-Docker-Machine-创建-Docker-主机" class="headerlink" title="1. Docker Machine 创建 Docker 主机"></a>1. Docker Machine 创建 Docker 主机</h2><p>在进行 Docker Swarm 配置之前，我们还需要说下 Docker 另外一个官方工具 Docker Machine（也是 Docker 三剑客之一），其作用就是快速帮助我们搭建 Docker 主机环境，比如我们要使用 Docker Swarm，就必须有很多的 Docker 主机来进行操作，Docker Machine 就是最理想的工具。</p><p>因为我是在 Mac OS 上进行操作的，并且 Docker for Mac 已经包含了 Docker Machine（<code>docker machine</code>），所以我不需要再额外进行安装了，如果使用 Linux 系统的话，安装也非常简单，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-machine</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><p>好了，我们先使用 Docker Machine 创建四个 Docker 主机，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create -d virtualbox manager1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox manager2 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker1 &amp;&amp; </span><br><span class="line">docker-machine create -d virtualbox worker2</span><br><span class="line"></span><br><span class="line">Running pre-create checks...</span><br><span class="line">(worker1) No default Boot2Docker ISO found locally, downloading the latest release...</span><br><span class="line">(worker1) Latest release for github.com/boot2docker/boot2docker is v17.11.0-ce</span><br><span class="line">(worker1) Downloading /Users/xishuai/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v17.11.0-ce/boot2docker.iso...</span><br></pre></td></tr></table></figure><p>执行上面命令，你会发现速度巨慢（如上），原因是从 GitHub 上下载一个<code>boot2docker.iso</code>文件（国内网络没办法），怎么解决呢？很简单，我们使用翻X的浏览器手动下载<code>boot2docker.iso</code>文件，然后拷贝到对应目录下（我电脑的目录<code>/Users/xishuai/.docker/machine/cache/</code>），然后再执行上面的命令，发现速度快的一批。</p><p>我们可以查看下创建的 Docker 主机信息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">manager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.11.0-ce   </span><br><span class="line">manager2   -        virtualbox   Running   tcp://192.168.99.101:2376           v17.11.0-ce   </span><br><span class="line">worker1    -        virtualbox   Running   tcp://192.168.99.102:2376           v17.11.0-ce   </span><br><span class="line">worker2    -        virtualbox   Running   tcp://192.168.99.103:2376           v17.11.0-ce</span><br></pre></td></tr></table></figure><p>可以看到，我们创建了四个 Docker 主机（两个 Manager 和两个 Worker），我们还可以连接到任何一台服务器进行操作，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1</span><br><span class="line">                        ##         .</span><br><span class="line">                  ## ## ##        ==</span><br><span class="line">               ## ## ## ## ##    ===</span><br><span class="line">           /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===</span><br><span class="line">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~</span><br><span class="line">           \______ o           __/</span><br><span class="line">             \    \         __/</span><br><span class="line">              \____\_______/</span><br><span class="line"> _                 _   ____     _            _</span><br><span class="line">| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __</span><br><span class="line">| &apos;_ \ / _ \ / _ \| __| __) / _` |/ _ \ / __| |/ / _ \ &apos;__|</span><br><span class="line">| |_) | (_) | (_) | |_ / __/ (_| | (_) | (__|   &lt;  __/ |</span><br><span class="line">|_.__/ \___/ \___/ \__|_____\__,_|\___/ \___|_|\_\___|_|</span><br><span class="line">Boot2Docker version 17.11.0-ce, build HEAD : e620608 - Tue Nov 21 18:11:40 UTC 2017</span><br><span class="line">Docker version 17.11.0-ce, build 1caf76c</span><br></pre></td></tr></table></figure><h2 id="2-Docker-Swarm-配置集群节点"><a href="#2-Docker-Swarm-配置集群节点" class="headerlink" title="2. Docker Swarm 配置集群节点"></a>2. Docker Swarm 配置集群节点</h2><p>我们执行下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 &quot;docker swarm init --advertise-addr 192.168.99.100&quot;</span><br><span class="line">Swarm initialized: current node (n0ub7dpn90rxjq97dr0g8we0w) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>上面是在<code>manager1</code>主机上，创建一个 Docker Swarm 管理节点（初始化集群的时候，会自动把当前节点设置为管理节点）。</p><p>接着，我们在<code>worker1</code>和<code>worker2</code>主机上，创建两个工作节点，并加入到集群中，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker1 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh worker2 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-envtxo4dl6df2ar3qldcccfdg 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>还有另外一个<code>manager2</code>主机，需要配置为管理节点，我们需要先在<code>manager1</code>主机上，获取管理节点对应的<code>token</code>，然后再配置为管理节点，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 &quot;docker swarm join-token manager&quot;</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-0koz1b98sco8r5cn3g61eahnu 192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">$ docker-machine ssh manager2 &quot;docker swarm join --token SWMTKN-1-5uwpqibnvmho1png8zmhcw8274yanohee32jyrcjlait9djhsk-0koz1b98sco8r5cn3g61eahnu 192.168.99.100:2377&quot;</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>配置好之后，我们进入<code>manager1</code>主机内（上面的命令也可以在主机内执行），然后查看集群节点的信息，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS</span><br><span class="line">n0ub7dpn90rxjq97dr0g8we0w *   manager1            Ready               Active              Leader</span><br><span class="line">t4cy67qp0bf2spgabsutwxnzt     manager2            Ready               Active              Reachable</span><br><span class="line">if0kmzp4ww3oy57y7cha7v36t     worker1             Ready               Active              </span><br><span class="line">jgg61cujzaeb3du5796fm0x2g     worker2             Ready               Active</span><br></pre></td></tr></table></figure><p><code>Leader</code>表示当然集群的头，<code>Reachable</code>可以理解为头的候选人，头一挂掉它就顶上去了。</p><hr><p>需要注意的是，我当天配置好之后，把所有的 Docker 主机都<code>stop</code>了，然后隔天重新<code>start</code>之后，出现了下面问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br><span class="line">Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It&apos;s possible that too few managers are online. Make sure more than half of the managers are online.</span><br></pre></td></tr></table></figure><p>好像是集群节点丢失了头，相关问题：<a href="https://q.cnblogs.com/q/96996/" target="_blank" rel="noopener">如何处理 docker swarm 集群”The swarm does not have a leader”问题</a>，按照文章进行解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --force-new-cluster</span><br><span class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.102 on eth1) - specify one with --advertise-addr</span><br><span class="line">$ docker swarm init --force-new-cluster --advertise-addr 192.168.99.102</span><br><span class="line">Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.</span><br><span class="line">$ docker node ls</span><br><span class="line">卡死</span><br><span class="line">$ docker-machine restart manager1 </span><br><span class="line">重启不了，一直转圈</span><br></pre></td></tr></table></figure><p>没办法，后来我只能删掉四个 Docker 主机，重新进行创建了。</p><h2 id="3-Docker-Service-部署单个集群服务"><a href="#3-Docker-Service-部署单个集群服务" class="headerlink" title="3. Docker Service 部署单个集群服务"></a>3. Docker Service 部署单个集群服务</h2><p>在部署集群服务之前，我们需要做些准备工作，因为 Docker 主机中没有配置 Docker 镜像加速地址，所以在拉取官方镜像的时候，肯定会非常慢，除了配置 Docker 镜像加速地址之外，我们还可以使用 Docker 私有镜像仓库，来解决这个问题。</p><p>参考文章：<a href="http://www.cnblogs.com/xishuai/p/ubuntu-docker-registry.html" target="_blank" rel="noopener">Ubuntu Docker Registry 搭建私有仓库</a></p><p>这边，我再简单说明下配置步骤，首先，在 Mac OS 上执行下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /Users/xishuai/Documents/Docker:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br><span class="line"></span><br><span class="line">$ docker tag nginx 192.168.99.1:5000/nginx:latest &amp;&amp; </span><br><span class="line">docker push 192.168.99.1:5000/nginx:latest &amp;&amp; </span><br><span class="line">docker pull 192.168.99.1:5000/nginx:latest</span><br><span class="line"></span><br><span class="line">$ curl http://192.168.99.1:5000/v2/_catalog</span><br><span class="line">&#123;&quot;repositories&quot;:[&quot;nginx&quot;]&#125;</span><br></pre></td></tr></table></figure><p>我们在 Mac OS 上创建了一个私有仓库容器，并把<code>nginx</code>镜像放到私有仓库中，因为没有使用 Https，所以在拉取和推送镜像的时候，会报如下错误（Mac OS 和 Docker 主机都会报错）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull 192.168.99.1:5000/nginx:latest</span><br><span class="line">The push refers to a repository [192.168.99.1:5000/nginx]</span><br><span class="line">Get https://192.168.99.1:5000/v1/_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>解决方式，我们需要分别在四个 Docker 主机中添加配置（Docker for Mac 在管理界面配置即可），命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo touch /etc/docker/daemon.json &amp;&amp; </span><br><span class="line">sudo chmod 777 /etc/docker/daemon.json &amp;&amp; </span><br><span class="line">sudo echo &apos;&#123; &quot;insecure-registries&quot;:    [&quot;192.168.99.1:5000&quot;] &#125;&apos; &gt; /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>然后重启四个 Docker 主机（Docker for Mac 也需要重启），命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine restart manager1 &amp;&amp; </span><br><span class="line">docker-machine restart manager2 &amp;&amp; </span><br><span class="line">docker-machine restart worker1 &amp;&amp; </span><br><span class="line">docker-machine restart worker2</span><br></pre></td></tr></table></figure><hr><p>上面比较啰嗦，我们接下来正式部署集群服务，还是拿<code>nginx</code>镜像做为示例，命令（<code>docker service create</code>命令<a href="http://www.yiibai.com/docker/service_create.html" target="_blank" rel="noopener">详细说明</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 4 -p 8088:80 --name nginx 192.168.99.1:5000/nginx:latest</span><br><span class="line">ap8h8srb8yh3mni0h2nz61njz</span><br><span class="line">overall progress: 4 out of 4 tasks </span><br><span class="line">1/4: running   [==================================================&gt;] </span><br><span class="line">2/4: running   [==================================================&gt;] </span><br><span class="line">3/4: running   [==================================================&gt;] </span><br><span class="line">4/4: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>--replicas 4</code>表示创建服务的实例个数（默认是一个），啥意思？比如4，就是在四个 Docker 主机上，分别创建一个<code>nginx</code>服务，如果是3，那就是三个 Docker 主机，或者你可以理解为 Docker 主机的个数，另外，<code>REPLICAS</code>会有进度显示，并且执行是异步的。</p><p>我们也可以手动设置实例个数，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale nginx=4</span><br></pre></td></tr></table></figure><p>部署好服务后，我们就可以进行查看了，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE                            PORTS</span><br><span class="line">ap8h8srb8yh3        nginx               replicated          4/4                 192.168.99.1:5000/nginx:latest   *:8080-&gt;8080/tcp</span><br><span class="line"></span><br><span class="line">$ docker service ps nginx</span><br><span class="line">ID                  NAME                IMAGE                            NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">l2rdrwzs5zog        nginx.1             192.168.99.1:5000/nginx:latest   manager1            Running             Running about a minute ago                       </span><br><span class="line">vsfczzbwanx3        nginx.2             192.168.99.1:5000/nginx:latest   manager2            Running             Running about a minute ago                           </span><br><span class="line">qtbgw5h6dsi9        nginx.3             192.168.99.1:5000/nginx:latest   worker              Running             Running about a minute ago                           </span><br><span class="line">za2ejnvb3n6z        nginx.4             192.168.99.1:5000/nginx:latest   worker2             Running             Running about a minute ago</span><br></pre></td></tr></table></figure><p>我们任意使用四个 Docker 主机中的一个 IP 地址，浏览器打开：<a href="http://192.168.99.100:8088/" target="_blank" rel="noopener">http://192.168.99.100:8088/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/1.png" alt=""></p><h2 id="4-Docker-Stack-部署多个集群服务，以及-GUI-管理页面"><a href="#4-Docker-Stack-部署多个集群服务，以及-GUI-管理页面" class="headerlink" title="4. Docker Stack 部署多个集群服务，以及 GUI 管理页面"></a>4. Docker Stack 部署多个集群服务，以及 GUI 管理页面</h2><p><code>docker service</code>部署的是单个服务，我们可以使用<code>docker stack</code>进行多服务编排部署，使用的同样是<code>docker-compose.yml</code>配置文件，示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">    image: 192.168.99.1:5000/nginx:latest</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 4</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: 192.168.99.1:5000/dockersamples/visualizer:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  portainer:</span><br><span class="line">    image: 192.168.99.1:5000/portainer/portainer:latest</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br></pre></td></tr></table></figure><p>如上所示，我们总共需要部署三个服务，出了<code>nginx</code>服务作为示例之外，<code>visualizer</code>（<a href="https://github.com/dockersamples/docker-swarm-visualizer" target="_blank" rel="noopener">官方地址</a>）和<code>portainer</code>（<a href="https://portainer.io/" target="_blank" rel="noopener">官方地址</a>）都是集群 GUI 管理服务。</p><p>部署命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml deploy-demo</span><br><span class="line">Creating service deploy-demo_nginx</span><br><span class="line">Creating service deploy-demo_visualizer</span><br><span class="line">Creating service deploy-demo_portainer</span><br></pre></td></tr></table></figure><p>部署成功之后，我们可以查看具体详情，命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack ls</span><br><span class="line">NAME                SERVICES</span><br><span class="line">deploy-demo         3</span><br></pre></td></tr></table></figure><p>查看<code>visualizer</code>GUI 集群管理，浏览器打开：<a href="http://192.168.99.100:8080/" target="_blank" rel="noopener">http://192.168.99.100:8080/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/2.png" alt=""></p><p>查看<code>portainer</code>GUI 集群管理，需要先配置账号信息，浏览器打开：<a href="http://192.168.99.100:9000/" target="_blank" rel="noopener">http://192.168.99.100:9000/</a></p><p><img src="/Docker/Docker三剑客之Docker-Swarm/3.gif" alt=""></p><p>可以看到，<code>portainer</code>比<code>visualizer</code>强大太多了，甚至我们所有的操作都可以在<code>portainer</code>上完成。</p><h2 id="5-docker-machine、docker-swarm、docker-node、docker-service-和-docker-stack-常用命令"><a href="#5-docker-machine、docker-swarm、docker-node、docker-service-和-docker-stack-常用命令" class="headerlink" title="5. docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令"></a>5. docker-machine、docker swarm、docker node、docker service 和 docker stack 常用命令</h2><h3 id="docker-machine-常用命令"><a href="#docker-machine-常用命令" class="headerlink" title="docker-machine 常用命令"></a>docker-machine 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker-machine create</td><td>创建一个 Docker 主机（常用<code>-d virtualbox</code>）</td></tr><tr><td>docker-machine ls</td><td>查看所有的 Docker 主机</td></tr><tr><td>docker-machine ssh</td><td>SSH 到主机上执行命令</td></tr><tr><td>docker-machine env</td><td>显示连接到某个主机需要的环境变量</td></tr><tr><td>docker-machine inspect</td><td>输出主机更多信息</td></tr><tr><td>docker-machine kill</td><td>停止某个主机</td></tr><tr><td>docker-machine restart</td><td>重启某台主机</td></tr><tr><td>docker-machine rm</td><td>删除某台主机</td></tr><tr><td>docker-machine scp</td><td>在主机之间复制文件</td></tr><tr><td>docker-machine start</td><td>启动一个主机</td></tr><tr><td>docker-machine status</td><td>查看主机状态</td></tr><tr><td>docker-machine stop</td><td>停止一个主机</td></tr></tbody></table><h3 id="docker-swarm-常用命令"><a href="#docker-swarm-常用命令" class="headerlink" title="docker swarm 常用命令"></a>docker swarm 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker swarm init</td><td>初始化集群</td></tr><tr><td>docker swarm join-token worker</td><td>查看工作节点的 token</td></tr><tr><td>docker swarm join-token manager</td><td>查看管理节点的 token</td></tr><tr><td>docker swarm join</td><td>加入集群中</td></tr></tbody></table><h3 id="docker-node-常用命令"><a href="#docker-node-常用命令" class="headerlink" title="docker node 常用命令"></a>docker node 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker node ls</td><td>查看所有集群节点</td></tr><tr><td>docker node rm</td><td>删除某个节点（<code>-f</code>强制删除）</td></tr><tr><td>docker node inspect</td><td>查看节点详情</td></tr><tr><td>docker node demote</td><td>节点降级，由管理节点降级为工作节点</td></tr><tr><td>docker node promote</td><td>节点升级，由工作节点升级为管理节点</td></tr><tr><td>docker node update</td><td>更新节点</td></tr><tr><td>docker node ps</td><td>查看节点中的 Task 任务</td></tr></tbody></table><h3 id="docker-service-常用命令"><a href="#docker-service-常用命令" class="headerlink" title="docker service 常用命令"></a>docker service 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker service create</td><td>部署服务</td></tr><tr><td>docker service inspect</td><td>查看服务详情</td></tr><tr><td>docker service logs</td><td>产看某个服务日志</td></tr><tr><td>docker service ls</td><td>查看所有服务详情</td></tr><tr><td>docker service rm</td><td>删除某个服务（<code>-f</code>强制删除）</td></tr><tr><td>docker service scale</td><td>设置某个服务个数</td></tr><tr><td>docker service update</td><td>更新某个服务</td></tr></tbody></table><h3 id="docker-stack-常用命令"><a href="#docker-stack-常用命令" class="headerlink" title="docker stack 常用命令"></a>docker stack 常用命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker stack deploy</td><td>部署新的堆栈或更新现有堆栈</td></tr><tr><td>docker stack ls</td><td>列出现有堆栈</td></tr><tr><td>docker stack ps</td><td>列出堆栈中的任务</td></tr><tr><td>docker stack rm</td><td>删除堆栈</td></tr><tr><td>docker stack services</td><td>列出堆栈中的服务</td></tr><tr><td>docker stack down</td><td>移除某个堆栈（不会删除数据）</td></tr></tbody></table><p>参考资料：</p><ul><li><a href="https://docs.docker.com/get-started/part4/" target="_blank" rel="noopener">Get Started, Part 4: Swarms</a></li><li><a href="https://github.com/yeasy/docker_practice/tree/master/swarm" target="_blank" rel="noopener">Docker 三剑客之 Docker Swarm</a></li><li><a href="http://www.jianshu.com/p/9eb9995884a5" target="_blank" rel="noopener">Docker Swarm 入门一篇文章就够了</a></li><li><a href="http://www.huangxiaobai.com/archives/2135" target="_blank" rel="noopener">Docker 的命令之集群节点管理 Swarm node</a></li><li><a href="http://www.yiibai.com/docker/service.html" target="_blank" rel="noopener">docker service 命令</a></li><li><a href="https://www.centos.bz/2017/01/docker-service-create/" target="_blank" rel="noopener">Docker 命令行参考(37) – docker service create 创建一个服务</a></li><li><a href="http://www.cnblogs.com/sparkdev/p/7044950.html" target="_blank" rel="noopener">Docker Machine 是什么？</a></li><li><a href="http://blog.csdn.net/wanglei_storage/article/details/77508620" target="_blank" rel="noopener">docker swarm 学习命令整理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Docker Machine 创建 Docker 主机&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Swarm 配置集群节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker Service 部署单个集群服务
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Swarm入门一篇文章就够了</title>
    <link href="http://blog.ozairs.com/Docker/Docker-Swarm%E5%85%A5%E9%97%A8%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://blog.ozairs.com/Docker/Docker-Swarm入门一篇文章就够了/</id>
    <published>2019-03-16T04:01:02.000Z</published>
    <updated>2019-03-16T04:18:27.583Z</updated>
    
    <content type="html"><![CDATA[<p>Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。</p><h2 id="1-Swarm-认识"><a href="#1-Swarm-认识" class="headerlink" title="1. Swarm 认识"></a>1. Swarm 认识</h2><p>Swarm 是目前 Docker 官方唯一指定（绑定）的集群管理工具。Docker 1.12  内嵌了 swarm mode 集群管理模式。</p><p>为了方便演示跨主机网络，我们需要用到一个工具——Docker Machine，这个工具与 Docker Compose、Docker Swarm 并称 Docker 三剑客，下面我们来看看如何安装 Docker Machine：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://github.com/docker/machine/releases/download/v0.9.0-rc2/docker-machine-`uname -s`-`uname -m` &gt;/tmp/docker-machine &amp;&amp;</span><br><span class="line">    chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">    sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><p>安装过程和 Docker Compose 非常类似。现在 Docker 三剑客已经全部到齐了。<br> 在开始之前，我们需要了解一些基本概念，有关集群的 Docker 命令如下：</p><ul><li>docker swarm：集群管理，子命令有 init, join,join-token, leave, update</li><li>docker node：节点管理，子命令有 demote, inspect,ls, promote, rm, ps, update</li><li>docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update</li><li>docker stack/deploy：试验特性，用于多应用部署，等正式版加进来再说。</li></ul><hr><h2 id="2-创建集群"><a href="#2-创建集群" class="headerlink" title="2. 创建集群"></a>2. 创建集群</h2><p>首先使用 Docker Machine 创建一个虚拟机作为 manger 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox manager1                                    </span><br><span class="line">Running pre-create checks...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">Creating machine...</span><br><span class="line">(manager1) Unable to get the latest Boot2Docker ISO release version:  Get https://api.github.com/repos/boot2docker/boot2docker/releases/latest: dial tcp: lookup api.github.com on [::1]:53: server misbehaving</span><br><span class="line">(manager1) Copying /home/zuolan/.docker/machine/cache/boot2docker.iso to /home/zuolan/.docker/machine/machines/manager1/boot2docker.iso...</span><br><span class="line">(manager1) Creating VirtualBox VM...</span><br><span class="line">(manager1) Creating SSH key...</span><br><span class="line">(manager1) Starting the VM...</span><br><span class="line">(manager1) Check network to re-create if needed...</span><br><span class="line">(manager1) Found a new host-only adapter: &quot;vboxnet0&quot;</span><br><span class="line">(manager1) Waiting for an IP...</span><br><span class="line">Waiting for machine to be running, this may take a few minutes...</span><br><span class="line">Detecting operating system of created instance...</span><br><span class="line">Waiting for SSH to be available...</span><br><span class="line">Detecting the provisioner...</span><br><span class="line">Provisioning with boot2docker...</span><br><span class="line">Copying certs to the local machine directory...</span><br><span class="line">Copying certs to the remote machine...</span><br><span class="line">Setting Docker configuration on the remote daemon...</span><br><span class="line">Checking connection to Docker...</span><br><span class="line">Docker is up and running!</span><br><span class="line">To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</span><br></pre></td></tr></table></figure><p>查看虚拟机的环境变量等信息，包括虚拟机的 IP 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  docker-machine env manager1</span><br><span class="line">export DOCKER_TLS_VERIFY=&quot;1&quot;</span><br><span class="line">export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH=&quot;/home/zuolan/.docker/machine/machines/manager1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME=&quot;manager1&quot;</span><br><span class="line"># Run this command to configure your shell: </span><br><span class="line"># eval $(docker-machine env manager1)</span><br></pre></td></tr></table></figure><p>然后再创建一个节点作为 work 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox worker1</span><br></pre></td></tr></table></figure><p>现在我们有了两个虚拟主机，使用 Machine 的命令可以查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls                             </span><br><span class="line">NAME     ACTIVE   DRIVER       STATE    URL                        SWARM  DOCKER   ERRORS</span><br><span class="line">manager1   -      virtualbox   Running  tcp://192.168.99.100:2376         v1.12.3   </span><br><span class="line">worker1    -      virtualbox   Running  tcp://192.168.99.101:2376         v1.12.3</span><br></pre></td></tr></table></figure><p>但是目前这两台虚拟主机并没有什么联系，为了把它们联系起来，我们需要 Swarm 登场了。<br> 因为我们使用的是 Docker Machine 创建的虚拟机，因此可以使用 docker-machine ssh 命令来操作虚拟机，在实际生产环境中，并不需要像下面那样操作，只需要执行 docker swarm 即可。</p><p>把 manager1 加入集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr 192.168.99.100:2377 --advertise-addr 192.168.99.100</span><br><span class="line">Swarm initialized: current node (23lkbq7uovqsg550qfzup59t6) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>用 –listen-addr 指定监听的 ip 与端口，实际的 Swarm 命令格式如下，本例使用 Docker Machine 来连接虚拟机而已：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --listen-addr &lt;MANAGER-IP&gt;:&lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>接下来，再把 work1 加入集群中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker1 docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>上面 join 命令中可以添加 –listen-addr $WORKER1_IP:2377 作为监听准备，因为有时候可能会遇到把一个 work 节点提升为 manger 节点的可能，当然本例子没有这个打算就不添加这个参数了。</p><blockquote><p>注意：如果你在新建集群时遇到双网卡情况，可以指定使用哪个 IP，例如上面的例子会有可能遇到下面的错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --listen-addr $MANAGER1_IP:2377</span><br><span class="line">Error response from daemon: could not choose an IP address to advertise since this system has multiple addresses on different interfaces (10.0.2.15 on eth0 and 192.168.99.100 on eth1) - specify one with --advertise-addr</span><br><span class="line">exit status 1</span><br></pre></td></tr></table></figure><p>发生错误的原因是因为有两个 IP 地址，而 Swarm 不知道用户想使用哪个，因此要指定 IP。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm init --advertise-addr 192.168.99.100 --listen-addr 192.168.99.100:2377 </span><br><span class="line">Swarm initialized: current node (ahvwxicunjd0z8g0eeosjztjx) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>集群初始化成功。</p><p>现在我们新建了一个有两个节点的“集群”，现在进入其中一个管理节点使用 docker node 命令来查看节点信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker node ls</span><br><span class="line">ID                       HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">23lkbq7uovqsg550qfzup59t6 *  manager1    Ready      Active         Leader</span><br><span class="line">dqb3fim8zvcob8sycri3hy98a    worker1     Ready      Active</span><br></pre></td></tr></table></figure><p>现在每个节点都归属于 Swarm，并都处在了待机状态。Manager1 是领导者，work1 是工人。</p><p>现在，我们继续新建虚拟机 manger2、worker2、worker3，现在已经有五个虚拟机了，使用 docker-machine ls 来查看虚拟机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME     ACTIVE    DRIVER       STATE     URL                         SWARM   DOCKER    ERRORS</span><br><span class="line">manager1   -       virtualbox   Running   tcp://192.168.99.100:2376           v1.12.3   </span><br><span class="line">manager2   -       virtualbox   Running   tcp://192.168.99.105:2376           v1.12.3   </span><br><span class="line">worker1    -       virtualbox   Running   tcp://192.168.99.102:2376           v1.12.3   </span><br><span class="line">worker2    -       virtualbox   Running   tcp://192.168.99.103:2376           v1.12.3   </span><br><span class="line">worker3    -       virtualbox   Running   tcp://192.168.99.104:2376           v1.12.3</span><br></pre></td></tr></table></figure><p>然后我们把剩余的虚拟机也加到集群中。</p><ul><li>添加 worker2 到集群中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>添加 worker3 到集群中：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker3 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>添加 manager2 到集群中：<br> 先从 manager1 中获取 manager 的 token：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker swarm join-token manager</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>然后添加 manager2 到集群中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker swarm join \</span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>现在再来查看集群信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager2 docker node ls</span><br><span class="line">ID                            HOSTNAME   STATUS   AVAILABILITY   MANAGER STATUS</span><br><span class="line">16w80jnqy2k30yez4wbbaz1l8     worker1     Ready     Active        </span><br><span class="line">2gkwhzakejj72n5xoxruet71z     worker2     Ready     Active        </span><br><span class="line">35kutfyn1ratch55fn7j3fs4x     worker3     Ready     Active        </span><br><span class="line">a9r21g5iq1u6h31myprfwl8ln *   manager2    Ready     Active        Reachable</span><br><span class="line">dpo7snxbz2a0dxvx6mf19p35z     manager1    Ready     Active        Leader</span><br></pre></td></tr></table></figure><h2 id="3-建立跨主机网络"><a href="#3-建立跨主机网络" class="headerlink" title="3. 建立跨主机网络"></a>3. 建立跨主机网络</h2><p>为了演示更清晰，下面我们把宿主机也加入到集群之中，这样我们使用 Docker 命令操作会清晰很多。<br> 直接在本地执行加入集群命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join \           </span><br><span class="line">    --token SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-8tn855hkjdb6usrblo9iu700o \</span><br><span class="line">    192.168.99.100:2377</span><br><span class="line">This node joined a swarm as a manager.</span><br></pre></td></tr></table></figure><p>现在我们有三台 manager，三台 worker。其中一台是宿主机，五台虚拟机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br><span class="line">ID                          HOSTNAME    STATUS    AVAILABILITY  MANAGER STATUS</span><br><span class="line">6z2rpk1t4xucffzlr2rpqb8u3    worker3     Ready     Active        </span><br><span class="line">7qbr0xd747qena4awx8bx101s *  user-pc     Ready     Active         Reachable</span><br><span class="line">9v93sav79jqrg0c7051rcxxev    manager2    Ready     Active         Reachable</span><br><span class="line">a1ner3zxj3ubsiw4l3p28wrkj    worker1     Ready     Active        </span><br><span class="line">a5w7h8j83i11qqi4vlu948mad    worker2     Ready     Active        </span><br><span class="line">d4h7vuekklpd6189fcudpfy18    manager1    Ready     Active          Leader</span><br></pre></td></tr></table></figure><p>查看网络状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME            DRIVER          SCOPE</span><br><span class="line">764ff31881e5        bridge          bridge          local                  </span><br><span class="line">fbd9a977aa03        host            host            local               </span><br><span class="line">6p6xlousvsy2        ingress         overlay         swarm            </span><br><span class="line">e81af24d643d        none            null            local</span><br></pre></td></tr></table></figure><p>可以看到在 swarm 上默认已有一个名为 ingress 的 overlay 网络, 默认在 swarm 里使用，本例子中会创建一个新的 overlay 网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create --driver overlay swarm_test</span><br><span class="line">4dm8cy9y5delvs5vd0ghdd89s</span><br><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID         NAME                DRIVER              SCOPE</span><br><span class="line">764ff31881e5        bridge              bridge              local</span><br><span class="line">fbd9a977aa03        host                host                local</span><br><span class="line">6p6xlousvsy2        ingress             overlay             swarm</span><br><span class="line">e81af24d643d        none                null                local</span><br><span class="line">4dm8cy9y5del        swarm_test          overlay             swarm</span><br></pre></td></tr></table></figure><p>这样一个跨主机网络就搭建好了，但是现在这个网络只是处于待机状态，下一小节我们会在这个网络上部署应用。</p><h2 id="4-在跨主机网络上部署应用"><a href="#4-在跨主机网络上部署应用" class="headerlink" title="4. 在跨主机网络上部署应用"></a>4. 在跨主机网络上部署应用</h2><p>首先我们上面创建的节点都是没有镜像的，因此我们要逐一 pull 镜像到节点中，这里我们使用前面搭建的私有仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker pull reg.example.com/library/nginx:alpine     </span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh manager2 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker1 docker pull reg.example.com/library/nginx:alpine </span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker2 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br><span class="line">$ docker-machine ssh worker3 docker pull reg.example.com/library/nginx:alpine</span><br><span class="line">alpine: Pulling from library/nginx</span><br><span class="line">e110a4a17941: Pulling fs layer</span><br><span class="line">... ...</span><br><span class="line">7648f5d87006: Pull complete</span><br><span class="line">Digest: sha256:65063cb82bf508fd5a731318e795b2abbfb0c22222f02ff5c6b30df7f23292fe</span><br><span class="line">Status: Downloaded newer image for reg.example.com/library/nginx:alpine</span><br></pre></td></tr></table></figure><p>上面使用 docker pull 分别在五个虚拟机节点拉取 nginx:alpine 镜像。接下来我们要在五个节点部署一组 Nginx 服务。</p><p>部署的服务使用 swarm_test 跨主机网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld --network=swarm_test nginx:alpine</span><br><span class="line">5gz0h2s5agh2d2libvzq6bhgs</span><br></pre></td></tr></table></figure><p>查看服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">5gz0h2s5agh2  helloworld  0/2       nginx:alpine</span><br></pre></td></tr></table></figure><p>查看 helloworld 服务详情（为了方便阅读，已调整输出内容）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME          IMAGE         NODE      DESIRED STATE   CURRENT STATE              ERROR</span><br><span class="line">ay081uome3   helloworld.1  nginx:alpine  manager1  Running         Preparing 2 seconds ago  </span><br><span class="line">16cvore0c96  helloworld.2  nginx:alpine  worker2   Running         Preparing 2 seconds ago</span><br></pre></td></tr></table></figure><p>可以看到两个实例分别运行在两个节点上。</p><p>进入两个节点，查看服务状态（为了方便阅读，已调整输出内容）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED        STATUS         PORTS            NAMES</span><br><span class="line">119f787622c2   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago  Up 4 minutes   80/tcp, 443/tcp  hello ...</span><br><span class="line">$ docker-machine ssh worker2 docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND         CREATED         STATUS        PORTS             NAMES</span><br><span class="line">5db707401a06   nginx:alpine  &quot;nginx -g ...&quot;   4 minutes ago   Up 4 minutes  80/tcp, 443/tcp   hello ...</span><br></pre></td></tr></table></figure><p>上面输出做了调整，实际的 NAMES 值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br></pre></td></tr></table></figure><p>记住上面这两个实例的名称。现在我们来看这两个跨主机的容器是否能互通：<br> 首先使用 Machine 进入 manager1 节点，然后使用 docker exec -i 命令进入 helloworld.1 容器中 ping 运行在 worker2 节点的 helloworld.2 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh manager1 docker exec -i helloworld.1.ay081uome3eejeg4mspa8pdlx \</span><br><span class="line">    ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (10.0.0.4): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.4: seq=0 ttl=64 time=0.591 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=1 ttl=64 time=0.594 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=2 ttl=64 time=0.624 ms</span><br><span class="line">64 bytes from 10.0.0.4: seq=3 ttl=64 time=0.612 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>然后使用 Machine 进入 worker2 节点，然后使用 docker exec -i 命令进入 helloworld.2 容器中 ping 运行在 manager1 节点的 helloworld.1 容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker exec -i helloworld.2.16cvore0c96rby1vp0sny3mvt \</span><br><span class="line">    ping helloworld.1.ay081uome3eejeg4mspa8pdlx </span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (10.0.0.3): 56 data bytes</span><br><span class="line">64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.466 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=1 ttl=64 time=0.465 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=2 ttl=64 time=0.548 ms</span><br><span class="line">64 bytes from 10.0.0.3: seq=3 ttl=64 time=0.689 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>可以看到这两个跨主机的服务集群里面各个容器是可以互相连接的。</p><p>为了体现 Swarm 集群的优势，我们可以使用虚拟机的 ping 命令来测试对方虚拟机内的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 ping helloworld.1.ay081uome3eejeg4mspa8pdlx</span><br><span class="line">PING helloworld.1.ay081uome3eejeg4mspa8pdlx (221.179.46.190): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.190: seq=0 ttl=63 time=48.651 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=1 ttl=63 time=63.239 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=2 ttl=63 time=47.686 ms</span><br><span class="line">64 bytes from 221.179.46.190: seq=3 ttl=63 time=61.232 ms</span><br><span class="line">^C</span><br><span class="line">$ docker-machine ssh manager1 ping helloworld.2.16cvore0c96rby1vp0sny3mvt</span><br><span class="line">PING helloworld.2.16cvore0c96rby1vp0sny3mvt (221.179.46.194): 56 data bytes</span><br><span class="line">64 bytes from 221.179.46.194: seq=0 ttl=63 time=30.150 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=1 ttl=63 time=54.455 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=2 ttl=63 time=73.862 ms</span><br><span class="line">64 bytes from 221.179.46.194: seq=3 ttl=63 time=53.171 ms</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>上面我们使用了虚拟机内部的 ping 去测试容器的延迟，可以看到延迟明显比集群内部的 ping 值要高。</p><h2 id="5-Swarm-集群负载"><a href="#5-Swarm-集群负载" class="headerlink" title="5. Swarm 集群负载"></a>5. Swarm 集群负载</h2><p>现在我们已经学会了 Swarm 集群的部署方法，现在来搭建一个可访问的 Nginx 集群吧。体验最新版的 Swarm 所提供的自动服务发现与集群负载功能。<br> 首先删掉上一节我们启动的 helloworld 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service rm helloworld                                 </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><p>然后在新建一个服务，提供端口映射参数，使得外界可以访问这些 Nginx 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create --replicas 2 --name helloworld -p 7080:80 --network=swarm_test nginx:alpine</span><br><span class="line">9gfziifbii7a6zdqt56kocyun</span><br></pre></td></tr></table></figure><p>查看服务运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls                                                                                </span><br><span class="line">ID           NAME         REPLICAS     IMAGE           COMMAND</span><br><span class="line">9gfziifbii7a  helloworld     2/2        nginx:alpine</span><br></pre></td></tr></table></figure><p>不知你有没有发现，虽然我们使用 –replicas 参数的值都是一样的，但是上一节中获取服务状态时，REPLICAS 返回的是 0/2，现在的 REPLICAS 返回的是 2/2。<br> 同样使用 docker service ps 查看服务详细状态时（下面输出已经手动调整为更易读的格式），可以看到实例的 CURRENT STATE 中是 Running 状态的，而上一节中的 CURRENT STATE 中全部是处于 Preparing 状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID          NAME      IMAGE     NODE    DESIRED STATE   CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...   helloworld.1  nginx:alpine  user-pc    Running         Running 13 seconds ago  </span><br><span class="line">7acmhj0u...   helloworld.2  nginx:alpine  worker2    Running         Running 6 seconds ago</span><br></pre></td></tr></table></figure><p>这就涉及到 Swarm 内置的发现机制了，目前 Docker 1.12 中 Swarm 已经内置了服务发现工具，我们不再需要像以前使用 Etcd 或者 Consul 这些工具来配置服务发现。对于一个容器来说如果没有外部通信但又是运行中的状态会被服务发现工具认为是 Preparing 状态，本小节例子中因为映射了端口，因此有了 Running 状态。<br> 现在我们来看 Swarm 另一个有趣的功能，当我们杀死其中一个节点时，会发生什么。<br> 首先 kill 掉 worker2 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh worker2 docker kill helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br><span class="line">helloworld.2.7acmhj0udzusv1d7lu2tbuhu4</span><br></pre></td></tr></table></figure><p>稍等几秒，再来看服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME          IMAGE     NODE   DESIRED STATE  CURRENT STATE   ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1     nginx:alpine  zuolan-pc  Running       Running 19 minutes ago  </span><br><span class="line">8f866igpl...  helloworld.2     nginx:alpine  manager1  Running       Running 4 seconds ago   </span><br><span class="line">7acmhj0u...   \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 seconds ago  ...exit...</span><br><span class="line">$ docker service ls           </span><br><span class="line">ID            NAME        REPLICAS  IMAGE         COMMAND</span><br><span class="line">9gfziifbii7a  helloworld  2/2       nginx:alpine</span><br></pre></td></tr></table></figure><p>可以看到即使我们 kill 掉其中一个实例，Swarm 也会迅速把停止的容器撤下来，同时在节点中启动一个新的实例顶上来。这样服务依旧还是两个实例在运行。<br> 此时如果你想添加更多实例可以使用 scale 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale helloworld=3</span><br><span class="line">helloworld scaled to 3</span><br></pre></td></tr></table></figure><p>查看服务详情，可以看到有三个实例启动了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps helloworld</span><br><span class="line">ID         NAME        IMAGE      NODE   DESIRED STATE  CURRENT STATE    ERROR</span><br><span class="line">9ikr3agyi...  helloworld.1    nginx:alpine  user-pc   Running        Running 30 minutes ago  8f866igpl...  helloworld.2    nginx:alpine  manager1  Running        Running 11 minutes ago  7acmhj0u...  \_ helloworld.2  nginx:alpine  worker2   Shutdown       Failed 11 minutes ago   exit137</span><br><span class="line">1vexr1jm...  helloworld.3    nginx:alpine   worker2   Running       Running 4 seconds ago</span><br></pre></td></tr></table></figure><p>现在如果想减少实例数量，一样可以使用 scale 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service scale helloworld=2</span><br><span class="line">helloworld scaled to 2</span><br></pre></td></tr></table></figure><hr><p>至此，Swarm的主要用法都已经介绍完了，主要讲述了 Swarm 集群网络的创建与部署。介绍了 Swarm 的常规应用，包括 Swarm 的服务发现、负载均衡等，然后使用 Swarm 来配置跨主机容器网络，并在上面部署应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。目前，Swarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Compose入门</title>
    <link href="http://blog.ozairs.com/Docker/Docker-Compose%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.ozairs.com/Docker/Docker-Compose入门/</id>
    <published>2019-03-16T03:32:37.000Z</published>
    <updated>2019-03-16T04:18:55.022Z</updated>
    
    <content type="html"><![CDATA[<p>Compose 是一个用户定义和运行多个容器的 Docker 应用程序。在 Compose 中你可以使用 YAML 文件来配置你的应用服务。然后，只需要一个简单的命令，就可以创建并启动你配置的所有服务。</p><p>使用 Compose 基本会有如下三步流程：</p><ol><li>在 Dockfile 中定义你的应用环境，使其可以在任何地方复制。</li><li>在 docker-compose.yml 中定义组成应用程序的服务，以便它们可以在隔离的环境中一起运行。</li><li>最后，运行<code>dcoker-compose up</code>，Compose 将启动并运行整个应用程序。</li></ol><h2 id="开始使用-Docker-Compose"><a href="#开始使用-Docker-Compose" class="headerlink" title="开始使用 Docker Compose"></a>开始使用 Docker Compose</h2><p>这里面将会在 Docker Compose 中构建一个简单的 Python 程序。应用程序将使用 Flask 框架，并在 Redis 中维护一个计数器。</p><p><strong>先决条件</strong></p><p>确认你已经安装了 Docker Engine 与 Docker Compose。你不需要安装 Python 或者 Redis，这两个都会在 Docker <a href="https://www.baidu.com/s?wd=%E9%95%9C%E5%83%8F&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">镜像</a>中提供。</p><h3 id="第一步：定义应用依赖"><a href="#第一步：定义应用依赖" class="headerlink" title="第一步：定义应用依赖"></a>第一步：定义应用依赖</h3><ol><li><p>为项目创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir composetest</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> composetest12</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个名为 app.py 的文件，并将如下内容粘贴进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">   retries = <span class="number">5</span></span><br><span class="line">   <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">       <span class="keyword">try</span>:</span><br><span class="line">           <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">       <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">           <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">               <span class="keyword">raise</span> exc</span><br><span class="line">           retries -= <span class="number">1</span></span><br><span class="line">           time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">   count = get_hit_count()</span><br><span class="line">   <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)<span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure><p>在这个例子中，redis 就是应用网络中 redis 容器的主机名。我们使用 Redis 的默认端口 6379。</p></li><li><p>在你的项目路径下创建另外一个叫做 requirements.txt 的文件，并将如下内容粘贴进去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis12</span><br></pre></td></tr></table></figure></li></ol><h3 id="第二步：创建-Dockerfile"><a href="#第二步：创建-Dockerfile" class="headerlink" title="第二步：创建 Dockerfile"></a>第二步：创建 Dockerfile</h3><p>在这一步中，你需要编写一个 Dockerfile 来构建一个 Docker 镜像。这个镜像包含 Python 应用的所有依赖，也包含 Python 其本身。</p><p>在你的项目路径下创建一个 Dockerfile 文件，并将如下内容粘贴进去：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.4</span>-alpine</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /code</span></span><br><span class="line"><span class="bash">WORKDIR /code</span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]12345</span></span><br></pre></td></tr></table></figure><p>这会告诉容器：</p><ul><li>构建一个基于 Python 3.4 的镜像</li><li>把当前目录添加到镜像中的 /code 路径下</li><li>把工作路径设置成 /code</li><li>安装 Python 依赖</li><li>设置容器的默认命令为 <code>python app.py</code></li></ul><p>有关如何编写 Dockerfiles 的更多信息，请参考 <a href="https://docs.docker.com/engine/tutorials/dockerimages/#building-an-image-from-a-dockerfile" target="_blank" rel="noopener">Docker user guide</a> 与 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a>。</p><h3 id="第三步：在-Compose-文件中定义一个服务"><a href="#第三步：在-Compose-文件中定义一个服务" class="headerlink" title="第三步：在 Compose 文件中定义一个服务"></a>第三步：在 Compose 文件中定义一个服务</h3><p>在工作路径下创建一个叫做 docker-compose.yml 并粘贴如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>这个 Compose 文件中定义了两个服务 web 与 redis。此 Web 服务：</p><ul><li>使用当前目录 Dockerfile 构建出来的镜像</li><li>将容器上暴露的5000端口转发到主机的5000端口。我们使用 Flask Web 服务器的默认端口 5000。</li></ul><p>而 Redis 服务使用从 Docker Hub 注册表中拉取的公有镜像。</p><h3 id="第四步：在-Compose-中构建并运行你的应用"><a href="#第四步：在-Compose-中构建并运行你的应用" class="headerlink" title="第四步：在 Compose 中构建并运行你的应用"></a>第四步：在 Compose 中构建并运行你的应用</h3><ol><li><p>在你的项目路径下通过 <code>docker-compose up</code> 命令启动你的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network "composetest_default" with the default driver</span><br><span class="line">Creating composetest_web_1 ...</span><br><span class="line">Creating composetest_redis_1 ...</span><br><span class="line">Creating composetest_web_1</span><br><span class="line">Creating composetest_redis_1 ... done</span><br><span class="line">Attaching to composetest_web_1, composetest_redis_1</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">redis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span><br><span class="line">web_1    |  * Restarting with stat</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">web_1    |  * Debugger is active!</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # Server initialized</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">web_1    |  * Debugger PIN: 330-787-903</span><br><span class="line">redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections12345678910111213141516171819</span><br></pre></td></tr></table></figure></li></ol><p>Compose 拉取一个 Redis 镜像，以你自己的代码构建一个镜像，并启动你定义的服务。在这种情况下，代码在构建时静态拷贝到镜像中。</p><ol><li><p>在浏览器中输入 <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000</a> 查看应用的运行情况。</p><p>你将在你的浏览器中看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I have been seen 1 times.1</span><br></pre></td></tr></table></figure></li><li><p>刷新一下浏览器，数值将会增加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! I have been seen 2 times.1</span><br></pre></td></tr></table></figure></li><li><p>切换到另外一个容器，输入 <code>docker image ls</code> 列举所有本地镜像。</p><p>镜像列表中将返回 reidis 与 web。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">composetest_web         latest              e2c21aa48cc1        4 minutes ago       93.8MB</span><br><span class="line">python                  3.4-alpine          84e6077c7ab6        7 days ago          82.5MB</span><br><span class="line">redis                   alpine              9d8fa9aa0e5b        3 weeks ago         27.5MB12345</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>docker inspect &lt;tag or id&gt;</code> 来检查镜像。</p></li><li><p>停止镜像，即可以在你的项目路径下使用 <code>docker-compose down</code> ，也可以在原始的终端上使用 CTRL+C 停止当前启动着的应用。</p></li></ol><h3 id="第五步：编辑-Compose-文件添加一个绑定挂载"><a href="#第五步：编辑-Compose-文件添加一个绑定挂载" class="headerlink" title="第五步：编辑 Compose 文件添加一个绑定挂载"></a>第五步：编辑 Compose 文件添加一个绑定挂载</h3><p>在你的项目路径下编辑 docker-compose.yml 为 web 服务添加一个绑定挂载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  web:</span></span><br><span class="line"><span class="attr">    build:</span> <span class="string">.</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">"5000:5000"</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">     -</span> <span class="string">.:/code</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">"redis:alpine"</span><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>这个新的 volumes 键将当前路径（项目路径）与容器中的 /code 路径挂载到一起，允许你及时修改代码而不用重新构建镜像。</p><h3 id="第六步：重新构建并在-Compose-中运行应用"><a href="#第六步：重新构建并在-Compose-中运行应用" class="headerlink" title="第六步：重新构建并在 Compose 中运行应用"></a>第六步：重新构建并在 Compose 中运行应用</h3><p>在你的项目路径下，输入 <code>docker-compose up</code> 命令使用更新后的 Compose 文件构建应用并启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up</span></span><br><span class="line">Creating network "composetest_default" with the default driver</span><br><span class="line">Creating composetest_web_1 ...</span><br><span class="line">Creating composetest_redis_1 ...</span><br><span class="line">Creating composetest_web_1</span><br><span class="line">Creating composetest_redis_1 ... done</span><br><span class="line">Attaching to composetest_web_1, composetest_redis_1</span><br><span class="line">web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">...123456789</span><br></pre></td></tr></table></figure><p>再次检查 Web 浏览器中的 Hello World 消息，然后刷新以查看计数增量。</p><h3 id="第七步：更新应用程序"><a href="#第七步：更新应用程序" class="headerlink" title="第七步：更新应用程序"></a>第七步：更新应用程序</h3><p>因为应用程序的代码通过 volume 挂载到容器中，你可以更改其代码并立即查看更改，而不必重新生成镜像。</p><ol><li><p>修改 app.py 中的欢迎语并保存。例如，将 Hello World！ 改成 Hello from Docker!:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">'Hello from Docker! I have been seen &#123;&#125; times.\n'</span>.format(count)<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>刷新你的浏览器。欢迎语已经更新，而计数器仍然在增长。</p></li></ol><h3 id="第八步：尝试一些其它命令"><a href="#第八步：尝试一些其它命令" class="headerlink" title="第八步：尝试一些其它命令"></a>第八步：尝试一些其它命令</h3><p>如果你希望你的应用程序在后台运行，你可以将 <code>-d</code> 标记传递给 <code>docker-compose up</code> 并使用 <code>docker-compose ps</code> 来查看当前运行的应用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></span><br><span class="line">Starting composetest_redis_1...</span><br><span class="line">Starting composetest_web_1...</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose ps</span></span><br><span class="line">Name                 Command            State       Ports</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">composetest_redis_1   /usr/local/bin/run         Up</span><br><span class="line">composetest_web_1     /bin/sh -c python app.py   Up      5000-&gt;5000/tcp123456789</span><br></pre></td></tr></table></figure><p><code>docker-compose run</code> 命令允许你为你的应用程序运行一次性命令。例如，查看哪些环境变量可以用于 web 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose run web env1</span></span><br></pre></td></tr></table></figure><p>通过 <code>docker-compose --help</code> 查看所有可用的命令。</p><p>如果你使用 <code>docker-compose up -d</code> 启动了 Compose，你可能希望在它们运行完成后停止服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose stop1</span></span><br></pre></td></tr></table></figure><p>你可以停掉所有一切，使用 down 命令完全移除容器。传递 —volumes 还可以删除 Redis 容器中所使用的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose down --volumes</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Compose 是一个用户定义和运行多个容器的 Docker 应用程序。在 Compose 中你可以使用 YAML 文件来配置你的应用服务。然后，只需要一个简单的命令，就可以创建并启动你配置的所有服务。&lt;/p&gt;
&lt;p&gt;使用 Compose 基本会有如下三步流程：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Docker" scheme="http://blog.ozairs.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>在Amazon ECS上部署Docker容器</title>
    <link href="http://blog.ozairs.com/AWS/%E5%9C%A8Amazon-ECS%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E5%AE%B9%E5%99%A8/"/>
    <id>http://blog.ozairs.com/AWS/在Amazon-ECS上部署Docker容器/</id>
    <published>2019-03-16T02:17:06.000Z</published>
    <updated>2019-03-16T02:53:00.117Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Elastic Container Service (Amazon ECS) 是用于在可扩展群集上运行 Docker 应用程序的 Amazon Web Service。在本教程中，您将了解如何在负载均衡器后面的 Amazon ECS 集群上运行支持 Docker 的示例应用程序，对该示例应用程序进行测试，然后删除您的资源以免产生费用。</p><p>在本教程中完成的所有操作均符合<a href="https://aws.amazon.com/cn/free/" target="_blank" rel="noopener">免费套餐</a>条件。</p><h4 id="管理-AWS-资源"><a href="#管理-AWS-资源" class="headerlink" title="管理 AWS 资源"></a>管理 AWS 资源</h4><p>登录控制台</p><h2 id="步骤-1：设置-Amazon-ECS-的首次运行"><a href="#步骤-1：设置-Amazon-ECS-的首次运行" class="headerlink" title="步骤 1：设置 Amazon ECS 的首次运行"></a>步骤 1：设置 Amazon ECS 的首次运行</h2><p>Amazon ECS 首次运行向导将引导您创建集群并启动示例 Web 应用程序。在此步骤中，您将进入 Amazon ECS 控制台并启动该向导。</p><hr><p>a. <a href="https://console.aws.amazon.com/ecs/home#/firstRun" target="_blank" rel="noopener">单击此处以打开 Amazon ECS 控制台首次运行向导</a>。</p><hr><p>b. 使用 Amazon ECS，您可以选择使用 Amazon Elastic Container Registry (Amazon ECR) 创建映像存储库，并向其推送一个映像作为首次运行向导的一部分（参见右侧的屏幕截图）。该功能目前在部分区域可用。 </p><ul><li>如果没有 Amazon ECR 选项，请跳至步骤 2。</li><li>如果有 Amazon ECR 选项，则取消选中 <em>Deploy a sample application onto an Amazon ECS Cluster</em> 旁边的复选框，然后选择 <strong>Continue</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/1.png" alt="deploy-docker-container-1"></p><h2 id="步骤-2：创建任务定义"><a href="#步骤-2：创建任务定义" class="headerlink" title="步骤 2：创建任务定义"></a>步骤 2：创建任务定义</h2><p><em>任务定义</em>类似于应用程序的蓝图。在此步骤中，您将指定一个任务定义，以便 Amazon ECS 分辨出将哪个 Docker 映像用于容器、该任务将使用多少个容器以及每个容器的资源分配情况。</p><hr><p>任务定义预加载了默认的配置值。</p><ul><li>查看默认值并选择 <strong>Next Step</strong>。</li></ul><p>如果您希望修改配置或想要了解更多内容，请参阅<a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definition_parameters.html" target="_blank" rel="noopener">任务定义参数</a>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/2.png" alt="deploy-docker-container-2"></p><h2 id="步骤-3：配置服务"><a href="#步骤-3：配置服务" class="headerlink" title="步骤 3：配置服务"></a>步骤 3：配置服务</h2><p>您现已创建了任务定义，接下来是配置 Amazon ECS <em>服务</em>。服务可启动并维护集群中任务定义的副本。例如，通过将某个应用程序作为服务来运行，Amazon ECS 将自动恢复任何已停止的任务并维持您所指定的副本数。</p><hr><p>a. 配置服务选项：</p><ul><li><strong>Service Name</strong>：默认的 <em>sample-webapp</em> 是一款由 AWS 提供的基于 Web 的“Hello World”应用程序。这意味着它可无限期运行，因此，通过将其作为服务来运行，如果任务的运行状况不佳或意外终止，该应用程序将重新启动。</li><li><strong>Desired number of tasks</strong>：若不超出 <a href="https://aws.amazon.com/cn/free/" target="_blank" rel="noopener">AWS 免费套餐</a>的范围，请保留默认值 <em>1</em>。此操作将为您的任务创建一个副本。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/3.png" alt="deploy-docker-container-3"></p><hr><p>b. Elastic Load Balancing：您可以选择将负载均衡器与您的服务配合使用。Amazon ECS 可以创建 Elastic Load Balancing (ELB) 负载均衡器，以在启动任务的各个容器实例间分配流量。</p><ul><li><strong>Container name: host port</strong>：选择 <em>Simple-app:80</em>。</li><li>为示例应用程序设置 <em>ELB listener protocol、ELB listener port 和 ELB health check</em> 的默认值。有关负载均衡配置的更多信息，请参阅 <a href="http://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html" target="_blank" rel="noopener">Service Load Balancing</a>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/4.png" alt="deploy-docker-container-3b"></p><hr><p>c. 将负载均衡器挂载到 Amazon ECS 服务之前，必须先创建服务要使用的 Identity and Access Management (IAM) 角色。此操作将允许 Amazon ECS 调用 Amazon EC2 和 Elastic Load Balancing API，以在负载均衡器中注册和取消注册实例。</p><ul><li>如果您还没有服务 IAM 角色，Amazon ECS 将创建一个名为 <em>ecsServiceRole</em> 的角色。</li><li>如果您有现有的 Amazon ECS 服务角色，请从下拉菜单中选择该角色。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/5.png" alt="deploy-docker-container-3c"></p><hr><p>d. 检查设置并选择 <strong>Next Step</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/6.png" alt="deploy-docker-container-3d"></p><h2 id="步骤-4：配置集群"><a href="#步骤-4：配置集群" class="headerlink" title="步骤 4：配置集群"></a>步骤 4：配置集群</h2><p>在<em>集群</em>上运行 Amazon ECS 任务，该集群是运行 Amazon ECS 容器代理的容器实例集合。在此步骤中，您将配置集群、检查安全设置并设置 IAM 角色。</p><hr><p>a. 按照以下配置设置执行操作：</p><ul><li><strong>Cluster name</strong>：输入 <em>sample-cluster</em>。</li><li><strong>EC2 instance type</strong>：默认的 <em>t2.micro</em> 实例类型可确保您不超出免费套餐的范围。CPU 和内存资源越多的实例类型可以处理的任务就越多。有关不同实例类型的更多信息，请参阅 <a href="https://aws.amazon.com/cn/ec2/instance-types/" target="_blank" rel="noopener">Amazon EC2 实例类型</a>。</li><li><strong>Number of instances</strong>：保留默认值 <em>1</em> 以启动一个要放置任务的集群中启动的 Amazon EC2 实例。集群中的实例越多，可在其上放置的任务就越多。</li><li><strong>Key pair</strong>：稍后通过 SSH 连接到实例时需要密钥对。您可通过选择 <em>None – unable to SSH</em>、选择现有密钥对或在 Amazon EC2 控制台中创建一个密钥对以继续操作。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/7.png" alt="deploy-docker-container-5a"></p><hr><p>b.（可选）安全组：默认值 <em>(Anywhere)</em> 可允许从整个 Internet 进行访问。您还可以选择 CIDR 块以限制对实例的访问。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/8.png" alt="deploy-docker-container-5b"></p><hr><p>c. 容器实例 IAM 角色：</p><ul><li>如果您没有 IAM 角色，Amazon ECS 向导将会为您创建一个。</li><li>如果您有现有的容器实例 IAM 角色，请从下拉菜单中选择该角色。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/10.png" alt="deploy-docker-container-5c"></p><hr><p>d. 选择 <strong>Review and Launch</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/11.png" alt="deploy-docker-container-5d"></p><h2 id="步骤-5：启动和查看资源"><a href="#步骤-5：启动和查看资源" class="headerlink" title="步骤 5：启动和查看资源"></a>步骤 5：启动和查看资源</h2><p>在上述步骤中，您配置了任务定义（类似于应用程序蓝图）、Amazon ECS 服务（可启动并维护任务定义的副本）和集群（是运行容器代理的容器实例集合）。在此步骤中，您将检查、启动和查看您所创建的资源。</p><hr><p>a. 在启动之前，您有最后一次机会来检查任务定义、任务配置和集群配置。</p><ul><li>选择 <strong>Launch instance &amp; run service</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/12.png" alt="deploy-docker-container-6"></p><hr><p>b. 您此时位于 <em>Launch Status</em> 页面上，该页面将显示启动状态并描述了过程的每一步。</p><ul><li>启动完成后，选择 <strong>View service</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/13.png" alt="deploy-docker-container-7"></p><h2 id="步骤-6：打开示例应用程序"><a href="#步骤-6：打开示例应用程序" class="headerlink" title="步骤 6：打开示例应用程序"></a>步骤 6：打开示例应用程序</h2><p>在此步骤中，您可通过将您的浏览器指向负载均衡器 DNS 名称来验证示例应用程序是否已启动并处于运行状态。</p><hr><p>a. 在“sample-webapp”页面上，单击您的负载均衡器名称。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/14.png" alt="deploy-docker-container-10"></p><hr><p>b. 现在将测试该示例应用程序：</p><ul><li>复制 ELB DNS 名称。</li><li>将其粘贴到新的浏览器窗口中。</li><li>按键盘上的 Enter 键以查看示例应用程序（在本示例中为静态网页）。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/15.png" alt="deploy-docker-container-12a"></p><h2 id="步骤-7：删除资源"><a href="#步骤-7：删除资源" class="headerlink" title="步骤 7：删除资源"></a>步骤 7：删除资源</h2><p>在本教程中，您启动了三种资源：一个 Amazon ECS 集群、一个 Amazon EC2 实例和一个负载均衡器。在此步骤中，您将清除所有资源以免产生不必要的费用。</p><hr><p>a. 重新导航至 Amazon ECS 控制台页面</p><ul><li>单击集群名称 (<strong>sample-cluster</strong>)。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/16.png" alt="deploy-docker-container-13"></p><hr><p>b. 选中 <em>sample-webapp</em> 旁边的复选框，然后单击 <strong>Update</strong>。</p><p><img src="/AWS/在Amazon-ECS上部署Docker容器/17.png" alt="deploy-docker-container-15"></p><hr><p>c. 为确保您不会意外删除带有活动任务的服务，您需要在 Amazon ECS 删除某个服务之前终止所有任务。 </p><ul><li>将任务数设置为 <em>0</em>，然后选择 <strong>Update Service</strong>。</li><li>更新服务之后，选择 <strong>Delete</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/18.png" alt="deploy-docker-container-14"></p><hr><p>d. 删除通过集群启动的 Amazon EC2 实例：</p><ul><li><a href="https://console.aws.amazon.com/ec2/v2/home" target="_blank" rel="noopener">进入 Amazon EC2 控制台</a></li><li>在左侧窗格中，选择 <strong>Instances</strong>。</li><li>选中名为 <em>ECS Instance – EC2ContainerService-default</em> 的实例旁边的复选框。</li><li>依次选择 <strong>Actions &gt;</strong> <strong>Instance State</strong> &gt; <strong>Terminate</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/19.png" alt="deploy-docker-container-17"></p><hr><p>e. 删除负载均衡器：</p><ul><li>在左侧窗格中，选择 <strong>Load Balancers</strong>。</li><li>选中您为服务创建的负载均衡器旁边的复选框（应以 <em>EC2Contai-EcsElast</em> 开头）。</li><li>右键单击并选择 <strong>Delete</strong>。</li></ul><p><img src="/AWS/在Amazon-ECS上部署Docker容器/20.png" alt="deploy-docker-container-19a"></p><h1 id="恭喜您！"><a href="#恭喜您！" class="headerlink" title="恭喜您！"></a>恭喜您！</h1><p>恭喜您！您已了解如何在 Amazon Elastic Container Service (Amazon ECS) 中配置、部署和删除支持 Docker 的应用程序。Amazon ECS 是一个可高度扩展的高性能容器管理服务，它支持 Docker 容器，并允许您在 Amazon EC2 实例的托管集群上轻松地运行应用程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Amazon Elastic Container Service (Amazon ECS) 是用于在可扩展群集上运行 Docker 应用程序的 Amazon Web Service。在本教程中，您将了解如何在负载均衡器后面的 Amazon ECS 集群上运行支持 Docke
      
    
    </summary>
    
      <category term="AWS" scheme="http://blog.ozairs.com/categories/AWS/"/>
    
    
      <category term="Docker" scheme="http://blog.ozairs.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>ssh-key git多账户配置</title>
    <link href="http://blog.ozairs.com/DevOps/ssh-key-git%E5%A4%9A%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.ozairs.com/DevOps/ssh-key-git多账户配置/</id>
    <published>2019-03-15T06:03:34.000Z</published>
    <updated>2019-03-15T06:05:03.611Z</updated>
    
    <content type="html"><![CDATA[<p>在使用git的时候，一般我们使用的远程Git服务器是github，这时只需简单的生成ssh-key密钥对并将公钥添加到github中就可以使用ssh了。</p><p>但在公司开发使用内部的git时，一般在gitlab,使用的邮箱一般是公司的邮箱，那么就需要配置多个ssh-key账户了。</p><p>假设user使用github的邮箱为<a href="https://link.jianshu.com?t=mailto:user1@163.com" target="_blank" rel="noopener">user1@163.com</a>;user2使用gitlab的邮箱为<a href="https://link.jianshu.com?t=mailto:user2@163.com" target="_blank" rel="noopener">user2@163.com</a>,下面是配置过程：</p><ol><li>首先进入用户主目录下的.ssh文件夹，我们生成的密钥对放在这儿</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br></pre></td></tr></table></figure><ol><li>分别为user1和user2生成密钥对：<br> 默认三次回车生成key的名字为id_rsa，注意在生成第二个的时候不要使用默认名，否则会覆盖第一个，在以下位置为第二个输入名字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#新建SSH key</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user1@163.com&quot;</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;user2@163.com&quot;</span><br><span class="line">#设置user2的命名为id_rsa_work </span><br><span class="line">Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_work</span><br></pre></td></tr></table></figure><p>此时在.ssh目录下就有两个密钥对文件id_rsa和id_rsa_work,我们将公钥分别拷至对应的Git服务器</p><ol><li>添加key到SSH agent中:<br> 此时还无法使用第二个服务器，因为Git会默认只读取到id_rsa,为了让SSH识别新的私钥，需将其添加到SSH agent中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa_work</span><br></pre></td></tr></table></figure><p>如果出现Could not open a connection to your authentication agent的错误，就试着用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa_work</span><br></pre></td></tr></table></figure><p>成功会显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Identity added: /c/Users/Windows用户名/.ssh/key名 (/c/Users/Windows用户名/.ssh/key名)</span><br></pre></td></tr></table></figure><p>注意：ssh-add 这个命令不是用来永久性的记住你所使用的私钥的。实际上，它的作用只是把你指定的私钥添加到 ssh-agent 所管理的一个 session 当中。而 ssh-agent 是一个用于存储私钥的临时性的 session 服务，也就是说当你重启之后，ssh-agent 服务也就重置了。</p><ol><li>创建并配置config文件使配置永久生效：<br> 在.ssh目录下新建一个文本文件，命令为config，不需要后缀，bash下可直接使用touch config,编辑以下内容：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># gitlab</span><br><span class="line">Host gitlab的IP</span><br><span class="line">    HostName gitlab的Host     //这里填你们公司的git网址即可</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_work</span><br><span class="line">    User user2</span><br><span class="line"># github</span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    User user1</span><br></pre></td></tr></table></figure><p>其规则就是：从上至下读取config的内容，在每个Host下寻找对应的私钥。按照你的情况修改就可以。</p><ol><li>使用：如果之前有设置全局用户名和邮箱的话，需要unset一下，可通过<code>$ git config --list</code>来查看全局配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset user.name</span><br><span class="line">$ git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>可以在不同的仓库下设置局部的用户名和邮箱用不同的账号登录，比如在公司的repository下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name &quot;user2&quot;  </span><br><span class="line">$ git config user.email &quot;user2@163.com&quot;</span><br></pre></td></tr></table></figure><ol><li>测试：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">#输出：Hi user1! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">$ ssh -T git@gitlab的IP</span><br><span class="line">#输出：Hi user2@163.com**, this is git@.....</span><br></pre></td></tr></table></figure><p>测试成功。<br> 如果出什么问题，可以通过<code>ssh -vT git@github.com</code>来输出编译信息，然后根据编译信息去解决问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用git的时候，一般我们使用的远程Git服务器是github，这时只需简单的生成ssh-key密钥对并将公钥添加到github中就可以使用ssh了。&lt;/p&gt;
&lt;p&gt;但在公司开发使用内部的git时，一般在gitlab,使用的邮箱一般是公司的邮箱，那么就需要配置多个ssh-
      
    
    </summary>
    
      <category term="DevOps" scheme="http://blog.ozairs.com/categories/DevOps/"/>
    
    
      <category term="ssh" scheme="http://blog.ozairs.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>使用Ansible进行自动化：构建VPC</title>
    <link href="http://blog.ozairs.com/Ansible/%E4%BD%BF%E7%94%A8Ansible%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%9A%E6%9E%84%E5%BB%BAVPC/"/>
    <id>http://blog.ozairs.com/Ansible/使用Ansible进行自动化：构建VPC/</id>
    <published>2019-03-14T11:19:52.000Z</published>
    <updated>2019-03-14T11:27:47.200Z</updated>
    
    <content type="html"><![CDATA[<p>在本文中，我们将讨论如何使用Ansible在AWS VPC中自动配置云网络。如果你不确定你在这里做什么，也许可以偷看介绍。我们将构建的自动化范围将轻松配置以下所有内容：</p><ul><li><strong>VPC和子网</strong>：创建VPC本身，以及跨三个可用区域的公共和私有子网：a，b和c</li><li><strong>Internet Gateway</strong>：为我们的公共资源配置网关以访问Internet</li><li><strong>NAT网关</strong>：配置NAT网关以允许我们的私有资源访问公共互联网</li><li><strong>VPC路由表</strong>：定义路由以使我们的子网成为公共或私有（使用公共或NAT网关路由公共流量）</li><li><strong>安全组</strong>：定义一些有用的安全组，用于限制仅在VPC内的通信，和/或允许来自公共互联网的SSH或HTTP / S流量</li><li><strong>私有DNS</strong>：创建一个专用的Route53托管区域，用于解决VPC内的资源</li></ul><p><img src="/Ansible/使用Ansible进行自动化：构建VPC/1.png" alt="img"></p><p>请注意，本文不是为了解释这些AWS资源如何工作，甚至是如何配置它们，而是具体说明如何使用Ansible <em>自动化</em>它们的配置。让我们开始吧！</p><hr><h3 id="VPC和子网"><a href="#VPC和子网" class="headerlink" title="VPC和子网"></a>VPC和子网</h3><h4 id="配置主机和组变量"><a href="#配置主机和组变量" class="headerlink" title="配置主机和组变量"></a>配置主机和组变量</h4><p>我们将首先为我们的VPC定义一个Ansible主机。该主机将充当“逻辑主机”（因为它不是我们可以连接以运行命令的实际主机），它将代表所有VPC配置。因此，在我们的清单中，我们定义一个<code>vpc</code>具有单个<code>vpc.ansibled</code>（名称只是名称，没有特殊）主机的组，然后将该<code>vpc</code>组放入一个名为的高级“项目”组中<code>project.ansibled</code>。</p><p>现在让我们定义配置VPC和子网时需要的变量。在全球范围内，<code>group_vars/all.yml</code>我们只想定义默认情况下我们不想尝试与主机建立SSH连接，只需在本地运行Ansible任务（几乎所有的自动化都是AWS云和无服务器）：</p><p>我们的通用“所有”组的一般全局变量</p><p>我们的<code>project.ansibled</code>团队将进行一些繁重的工作并提供高级定义，例如VPC名称和我们的AWS凭证。我们将在此组中放置所有主机，以便在Ansible执行时可以使用此配置。所以在<code>group_vars/project.ansibled.yml</code>：</p><p>接下来，我们定义VPC本身的一些细节：VPC的IP地址块，安全组和子网配置。这些我们将定义为主机的主机变量<code>vpc.ansibled</code>，因为我们希望它们特定于此主机，而其他主机（当我们绕过它们时）将不需要自己引用这些定义。</p><p>我们的“vpc.ansibled”逻辑主机的特定配置</p><h4 id="使用Ansible-Vault保护敏感信息"><a href="#使用Ansible-Vault保护敏感信息" class="headerlink" title="使用Ansible Vault保护敏感信息"></a>使用Ansible Vault保护敏感信息</h4><p>您可能想知道为什么存储我们的IAM凭证的vars <code>aws_access_key</code>和<code>aws_secret_key</code>vars看起来像那样。鉴于我们要将自动化提交到存储库，我们需要确保此敏感信息不会以纯文本形式显示 - 输入<a href="http://docs.ansible.com/ansible/2.4/vault.html" target="_blank" rel="noopener">Ansible Vault</a>，<a href="http://docs.ansible.com/ansible/2.4/vault.html" target="_blank" rel="noopener">Ansible的</a>一项功能，允许我们加密文件和字符串，使它们成为可能安全的版本控制。</p><p>要生成我们可以在运行时解密的这些加密字符串，首先我们将加密密码写入（git-ignored，或者最好不在repo目录中）文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo“my_vault_pass”&gt;〜/ ansibled.vault</span><br></pre></td></tr></table></figure><p>其次，将我们的纯文本值提供给<code>ansible-vault</code>程序，指定我们的密码文件，然后弹出一个加密的字符串，我们可以安全地存储在我们的Ansible vars中！</p><p><img src="/Ansible/使用Ansible进行自动化：构建VPC/2.png" alt="img"></p><p>您得到一个图像，因为Vault字符串在代码块中<strong>可怕</strong>地呈现</p><p>稍后，当我们想要执行自动化时，我们只需指定我们的保管库密码文件，或指定Ansible应该提示我们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃提示用户输入Vault密码</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml --ask-vault-pass</span><br><span class="line">＃从文件</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml中读取Vault密码--vault-password-file~ / ansibled.vault</span><br></pre></td></tr></table></figure><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>我们的Ansible任务（“代码”）将全部存放在一个<code>tasks/</code>目录下，并存放在<code>tasks/vpc/</code>与创建VPC相关的所有任务的子目录下。然后，我们的playbook将在运行时动态地包含这些任务列表，允许我们组织我们的任务来创建模块化的“代码”块。</p><p>我们的VPC自动化的第一阶段将涉及以下步骤：</p><ul><li>创建VPC</li><li>创建VPC子网</li><li>创建VPC安全组</li><li>为VPC创建Route53专用区域</li></ul><p>有了我们的主要VPC组件，我们现在可以为我们的VPC配置路由和网关：</p><ul><li>创建互联网网关</li><li>创建NAT网关（并更新VPC DNS）</li><li>为私有子网创建路由表</li><li>为公共子网创建路由表</li></ul><h4 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h4><p>现在我们已经编写了一些构建我们的VPC的任务，我们只需要将它与一个剧本联系在一起。我们只是针对该<code>vpc</code>组，使用我们的AWS凭证详细信息填充我们的环境，并使用该<code>include_tasks</code>指令来提取我们的VPC任务。简单！</p><h4 id="直截了当地了解事实"><a href="#直截了当地了解事实" class="headerlink" title="直截了当地了解事实"></a>直截了当地了解事实</h4><p>最后一个难题是为我们自动化的其他部分提供一种简单的方法来访问和利用我们刚刚提出的VPC基础设施的细节。例如，我们会希望能够容易地通过我们赋予他们的人类可读的名字（查找我们的VPC子网的ID <code>private-a</code>，<code>public-b</code>等等），就像我们建立我们的路由表上面的什么时候。因此，我们在以下位置创建“事实”任务列表<code>tasks/vpc/facts.yml</code>：</p><p>我们的VPC的这个“事实”任务列表现在可以包含在其他手册中以窥视AWS并发现有关我们VPC的一些重要信息！</p><p>而且……行动！</p><p>现在要自动构建我们的VPC，只需执行Ansible：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">＃提示用户输入Vault密码</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml --ask-vault-pass</span><br><span class="line">＃从文件</span><br><span class="line">ansible-playbook -i ansibled.inventory vpc.yml中读取Vault密码--vault-password-file ansibled.vault</span><br></pre></td></tr></table></figure><p>最后，在运行时拿一杯咖啡:)快乐的自动化！</p><hr><p><em>我喜欢自动化。这一系列的文章，自动化与Ansible，是一些Ansible bit’n bobs的记录，使我在管理软件基础设施时更轻松。</em></p><p><em>在</em><a href="https://github.com/tomwwright/ansibled" target="_blank" rel="noopener"><em>GitHub</em></a><em>或系列中的其他条目中<strong>全部检查</strong>：</em></p><ul><li><a href="https://medium.com/@tomwwright/automation-with-ansible-introduction-ccfa1baf8f5c" target="_blank" rel="noopener">Ansible自动化：简介</a></li><li>Ansible自动化：构建VPC（本文）</li><li><a href="https://medium.com/@tomwwright/automation-with-ansible-aws-elasticsearch-service-8d862cdb4a68" target="_blank" rel="noopener">Ansible自动化：AWS Elasticsearch</a></li><li><a href="https://medium.com/@tomwwright/automating-with-ansible-aurora-clusters-7272364777dd" target="_blank" rel="noopener">Ansible自动化：Aurora RDS集群</a></li><li><a href="https://medium.com/@tomwwright/automation-with-ansible-logentries-53cf595c2002" target="_blank" rel="noopener">Ansible自动化：Logentries</a></li></ul><p>【原文链接】：<a href="https://medium.com/@tomwwright/automating-with-ansible-building-a-vpc-c252944d3d2e" target="_blank" rel="noopener">https://medium.com/@tomwwright/automating-with-ansible-building-a-vpc-c252944d3d2e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本文中，我们将讨论如何使用Ansible在AWS VPC中自动配置云网络。如果你不确定你在这里做什么，也许可以偷看介绍。我们将构建的自动化范围将轻松配置以下所有内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;VPC和子网&lt;/strong&gt;：创建VPC本身，以及跨三个可用
      
    
    </summary>
    
      <category term="Ansible" scheme="http://blog.ozairs.com/categories/Ansible/"/>
    
    
      <category term="AWS" scheme="http://blog.ozairs.com/tags/AWS/"/>
    
  </entry>
  
</feed>
